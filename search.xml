<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[cocoapods结构解析]]></title>
    <url>%2F2020%2F09%2F20%2Fcocoapods%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[CocoaPods是用 Ruby 写的，并由若干个 Ruby 包 (gems) 构成的。在解析整合过程中，最重要的几个 gems 分别是： CocoaPods/CocoaPods, CocoaPods/Core, 和 CocoaPods/Xcodeproj (是的，CocoaPods 是一个依赖管理工具 – 利用依赖管理进行构建的！)。podspecs存储路径：~/.cocoapods缓存文件存储路径：~/Library/Caches/CocoaPods 核心组件CocoaPods/CocoaPod这是是一个面向用户的组件，每当执行一个 pod 命令时，这个组件都将被激活。该组件包括了所有使用 CocoaPods 涉及到的功能，并且还能通过调用所有其它的 gems 来执行任务。 CocoaPods/CoreCore 组件提供支持与 CocoaPods 相关文件的处理，文件主要是 Podfile 和 podspecs。 Podfile：Podfile 是一个文件，用于定义项目所需要使用的第三方库。该文件支持高度定制，你可以根据个人喜好对其做出定制。更多相关信息，请查阅 Podfile 指南。 Podspec：.podspec 也是一个文件，该文件描述了一个库是怎样被添加到工程中的。它支持的功能有：列出源文件、framework、编译选项和某个库所需要的依赖等。 CocoaPods/Xcodeproj这个 gem 组件负责所有工程文件的整合。它能够对创建并修改 .xcodeproj 和 .xcworkspace 文件。它也可以作为单独的一个 gem 包使用。如果你想要写一个脚本来方便的修改工程文件，那么可以使用这个 gem。 运行 pod install 命令当运行 pod install 命令时会引发许多操作。要想深入了解这个命令执行的详细内容，可以在这个命令后面加上 –verbose。运行指令后会有如下操作： 读取Podfile文件在安装期间，第一步是要弄清楚显示或隐式的声明了哪些第三方库。在加载 podspecs 过程中，CocoaPods 就建立了包括版本信息在内的所有的第三方库的列表。Podspecs 被存储在本地路径 ~/.cocoapods 中。 版本控制和冲突如果依赖的某些库同时使用了一个第三方库，但是版本不同，那么默认是向后兼容，既高版本的兼容低版本的；但是，总会有一些第三方库会存在不能向后兼容的问题，这时候就需要手动解决兼容问题。比如：同时依赖了一个库的1.2.5和2.1.3，那么需要用户通过明确指定使用的版本来解决冲突。 加载源文件CocoaPods 执行的下一步是加载源码。每个 .podspec 文件都包含一个源代码的索引，这些索引一般包裹一个 git 地址和 git tag。它们以 commit SHAs 的方式存储在 ~/Library/Caches/CocoaPods 中。这个路径中文件的创建是由 Core gem 负责的。CocoaPods 将依照 Podfile、.podspec 和缓存文件的信息将源文件下载到 Pods 目录中。 生成Pod.xcodeproj每次 pod install 执行，如果检测到改动时，CocoaPods 会利用 Xcodeproj gem 组件对 Pods.xcodeproj 进行更新。如果该文件不存在，则用使用默认配置。否则，会将已有的配置项加载至内存中。 安装第三方库当cocoapods往工程中添加一个第三方库时，不仅仅是添加了第三方库的源码，还会添加很多内容。由于每个第三方库会有一个独立的target，因此对于每个库，都会添加几个额外的文件： 一个包含编译选项的.xcconfig文件 一个同时包含编译设置和CocoaPods默认配置的私有.xcconfig文件 一个编译所必须的prefix.pch文件 一个编译必须的dummy.m文件 如果源码中包含资源bundle，那么在target的执行脚本Pods-Resources.sh中会添加bundle相关的指令。还有一个Pods-environment.h文件，其中包含一些宏，这些宏是用来检测某个组件是否来自pod。最后，将生成两个认可文件，一个是 plist，另一个是 markdown，这两个文件用于给最终用户查阅相关许可信息。 Podfile.lock 该文件记录了Pod中的依赖的每个组件，以及依赖组件的版本 Manifest.lock 这是每次运行 pod install 命令时创建的 Podfile.lock 文件的副本。如果你遇见过这样的错误 沙盒文件与 Podfile.lock 文件不同步 (The sandbox is not in sync with the Podfile.lock)。这是因为 Manifest.lock 文件和 Podfile.lock 文件不一致所引起。由于 Pods 所在的目录并不总在版本控制之下，这样可以保证开发者运行 app 之前都能更新他们的 pods，否则 app 可能会 crash，或者在一些不太明显的地方编译失败。 xcproj如果你已经依照我们的建议在系统上安装了 xcproj，它会对 Pods.xcodeproj 文件执行一下 touch 以将其转换成为旧的 ASCII plist 格式的文件。为什么要这么做呢？虽然在很久以前就不被其它软件支持了，但是 Xcode 仍然依赖于这种格式。如果没有 xcproj，你的 Pods.xcodeproj 文件将会以 XML 格式的 plist 文件存储，当你用 Xcode 打开它时，它会被改写，并造成大量的文件改动。 文件结构变化执行pod install 后，我们的工程结构发生了变化，在以前的基础上添加了如下文件： PodFile：依赖描述文件 Podfile.lock：当前安装的依赖库的版本 xxx.xcworkspace：xcworkspace文件，使用CocoaPod管理依赖的项目，XCode只能使用workspace编译项目，如果还只打开以前的xcodeproj文件进行开发，编译会失败 xcworkspace文件实际是一个文件夹，实际Workspace信息保存在contents.xcworkspacedata里，该文件的内容非常简单，实际上只指示它所使用的工程的文件目录 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;Workspace version = "1.0"&gt; &lt;FileRef location = "group:CardPlayer/CardPlayer.xcodeproj"&gt; &lt;/FileRef&gt; &lt;FileRef location = "group:Pods/Pods.xcodeproj"&gt; &lt;/FileRef&gt;&lt;/Workspace&gt; Pods/ Pods.xcodeproj，所有的第三方库都由Pods工程构建，每个三方库对应一个Pods工程中的Target。 每个第三方库都会在Pods目录下对应一个目录。 Headers，在Headers文件中有两个目录，Private和Public，其中包含第三方库的私有和公有的头文件，这些文件都是快捷连接，其真正的位置在每个三方库的文件夹目录下。 Target Support Files 支撑Target的文件 工程结构的变化Pods工程变化Pods工程会为每个依赖的第三方库定义一个Target，还会定义一个Pods-xxx的Target，每个Target会生成一个静态库 Pods工程会新建两个Configuration，每个Configuration会为不同的Target设置不同的xcconfig，xcconfig指出了头文件查找的目录，要链接的第三方，链接目录等。AFNetworking.xcconfig文件的内容： CONFIGURATION_BUILD_DIR = $PODS_CONFIGURATION_BUILD_DIR/AFNetworkingGCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1HEADER_SEARCH_PATHS = “${PODS_ROOT}/Headers/Private” “${PODS_ROOT}/Headers/Private/AFNetworking” “${PODS_ROOT}/Headers/Public” “${PODS_ROOT}/Headers/Public/AFNetworking”OTHER_LDFLAGS = -framework “CoreGraphics” -framework “MobileCoreServices” -framework “Security” -framework “SystemConfiguration”PODS_BUILD_DIR = $BUILD_DIRPODS_CONFIGURATION_BUILD_DIR = $PODS_BUILD_DIR/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)PODS_ROOT = ${SRCROOT}PODS_TARGET_SRCROOT = ${PODS_ROOT}/AFNetworkingPRODUCT_BUNDLE_IDENTIFIER = org.cocoapods.${PRODUCT_NAME:rfc1034identifier}SKIP_INSTALL = YES Header_SERACH_PATHS：编译时查找头文件的目录OTHER_LD_FLAGS：指明要链接的framework Pods-CardPlayer.debug.xcconfig文件的内容： GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1HEADER_SEARCH_PATHS = $(inherited) “${PODS_ROOT}/Headers/Public” “${PODS_ROOT}/Headers/Public/AFNetworking”LIBRARY_SEARCH_PATHS = $(inherited) “$PODS_CONFIGURATION_BUILD_DIR/AFNetworking”OTHER_CFLAGS = $(inherited) -isystem “${PODS_ROOT}/Headers/Public” -isystem “${PODS_ROOT}/Headers/Public/AFNetworking”OTHER_LDFLAGS = $(inherited) -ObjC -l”AFNetworking” -framework “CoreGraphics” -framework “MobileCoreServices” -framework “Security” -framework “SystemConfiguration”PODS_BUILD_DIR = $BUILD_DIRPODS_CONFIGURATION_BUILD_DIR = $PODS_BUILD_DIR/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)PODS_PODFILE_DIR_PATH = ${SRCROOT}/..PODS_ROOT = ${SRCROOT}/../Pods OTHER_LDFLAGS：说明了编译Pods时需要链接的第三方库，还需要链接其它framework所以我们在xcode里能看到AFNetworking依赖的framework: 主工程变化引入CocoaPods后，主工程的设置也会发生相应的变化，引入之前： Debug和Release中的Configuration没有设置任何配置文件，引入CocoaPods后的变化：可以看到，采用CocoaPods之后，Debug和Release设置了相应的配置文件，这些配置文件指明了头文件的查找目录和要链接的第三方库 编译并链接第三方库Podfile语法中文参考文档]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 配置远程登录服务器]]></title>
    <url>%2F2020%2F01%2F21%2Flinux%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[创建服务器创建谷歌GCP服务器 在服务器配置sshd_config登录服务器打开终端, 输入 1ssh root@&lt;这里是你服务器的ip地址&gt; 输入密码, 就完成了服务器的登录 使用vim打开sshd_config文件在服务器中打开sshd_config文件 1vi /etc/ssh/sshd_config 修改sshd_config文件中的几个地方 123RSAAuthentication yes # RSA认证PubkeyAuthentication yes # 公钥认证AuthorizedKeysFile .ssh/authorized_keys # 公钥认证文件路径 本地生成ssh-keygen回到本地, 使用ssh-keygen生成公钥和私钥 将生成的public key放到服务器进入/.ssh目录, 执行命令 1cat -n ~/.ssh/id_rsa.pub&gt;&gt;root@&lt;这里是你服务器的ip地址&gt;:~/.ssh/authorized_keys 期间会输入服务器的密码. 本地创建ssh的config文件, 并配置host在本机的目录~/.ssh下创建config文件 1touch config 然后使用vim打开进行编辑 1234567#ssh模版Host hostnameHostName xxx.xxx.xxx.xxxPort 22User root # 用户名ServerAliveInterval 60 # 每隔60秒 发送KeepAlive请求，保证不会因为超时空闲断开IdentityFile ~/.ssh/id_rsa #私钥地址 使用配置好的Host登录远端服务器使用命令 1ssh &lt;刚才配置的HostName&gt; 就完成了登录]]></content>
      <categories>
        <category>hide</category>
      </categories>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac配置Vim]]></title>
    <url>%2F2019%2F08%2F28%2FMac%E9%85%8D%E7%BD%AEVim%2F</url>
    <content type="text"><![CDATA[相信不少同学在Mac上使用过vi或者vim命令，这个命令是打开mac自带的vim编辑器的命令，如果只是简单的修改文件，使用vim无疑是很方便的；但是如果使用mac自带的vim来做大量文档编辑的工作，那就可能力不从心了。这个时候，你就需要更复杂的vim编辑器来负担这样的工作了,Mac目前有两个Vim客户端可供我们使用1、MacVim：使用Cocoa GUI，这是Mac上更新还很活跃的版本，也是Mac上最多人使用的版本。下载地址2、使用Carbon GUI的版本，但是这个版本目前基本上不再更新。下载地址 我主要是使用的MacVim，所以就记录一下MacVim的安装以及使用过程。 安装从上面提供的链接下载MacVim，并按照安装mac应用的步骤安装好MavVim。这个时候还没有结束。 想象一下，我们以前在terminal中打开一个文件是这样的：vi &lt;文件名称&gt;，这样很coooooooooool； 但是，我们现在使用MacVim，却得鼠标点击打开MacVim，然后再从MacVim打开文件。这样是不是比以前繁琐了很多。那么，能不能像从前一样，使用命令打开文件呢？ 答案是可以的。 我们先把MacVim打开,第一次打开MacVim是这个样子： 在MacVim的界面中我们输入:h mvim，MacVim会提示我们将mvim命令的路径添加到我们的PATH 添加PATH步骤： vi ~/.bash_podfile打开PATH所在路径 将MacVim提供的命令路径写入PATH：export PATH=/Applications/MacVim.app/Contents/bin:$PATH 执行source ~/.bash_podfile重启bash 这个时候，我们就可以直接在Terminal中使用mvim命令来打开文件了。 是不是觉得输入mvim命令还是不如vim命令舒服？那么我们就使用vim来打开MacVim! 使用命令mvim ~/.zshrc 或者mvim ~/.bashrc，如果你使用的是zsh那么使用前者，如果使用的是bash，那么使用后者。 打开后，在文件末尾新增一段文字alias vim=&#39;mvim&#39;，意思就是给mvim命令起一个别名。 然后保存退出，如果你是zsh使用source ~/.zshrc重新载入，如果是bash使用source ~/.bashrc载入。 接下来就是见证奇迹的时刻了，输入命令vim &lt;你要打开的文档&gt;，看看是不是使用MacVim打开了! 添加插件 经过上面的一系列骚操作，现在我们可以使用MacVim正常的进行编辑了，但是，我们还可以对MacVim进行更深层次的扩展，那就是给MacVim添加插件！ Vundle 命令12345678910# 安装插件:BundleInstall# 更新插件:BundleUpdate# 清除不需要的插件:BundleClean# 列出当前的插件:BundleList# 搜索插件:BundleSearch 配置~/.vimrc文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131" 关闭vim的所有扩展功能set nocompatible" 配置插件路径set rtp+=~/.vim/bundle/vundle/ call vundle#begin()" 在这里添加你想安装的Vim插件Bundle 'gmarik/vundle'" Python补全强力插件Bundle 'davidhalter/jedi'" 添加引号,括号配对补全Bundle 'jiangmiao/auto-pairs'" 添加/解除注释Bundle 'scrooloose/nerdcommenter'call vundle#end() " required"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" 一般设定"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" 设定默认解码set fenc=utf-8set fencs=utf-8,usc-bom,euc-jp,gb18030,gbk,gb2312,cp936"去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限set nocompatible" 显示中文帮助if version &gt;= 603 set helplang=cn set encoding=utf-8endif" 语法高亮syntax on" 设置配色colorscheme solarized "可能需要提前下载" 设置字体set guifont=Monaco:h14" 设置gvim启动窗口的位置，以及大小" winpos 300 105" set lines=30 columns=100" 开启行号显示set number"下面两行在进行编写代码时，在格式对起上很有用；"第一行，vim使用自动对起，也就是把当前行的对起格式应用到下一行；"第二行，依据上面的对起格式，智能的选择对起方式，对于类似C语言编"写上很有用set autoindentset smartindent"查询时非常方便，如要查找book单词，当输入到/b时，会自动找到第一"个b开头的单词，当输入到/bo时，会自动找到第一个bo开头的单词，依"次类推，进行查找时，使用此设置会快速找到答案，当你找要匹配的单词"时，别忘记回车set incsearch" 高亮当前行set cursorline" 启动的时候不显示那个援助索马里儿童的提示set shortmess=atI" 我的状态行显示的内容（包括文件类型和解码）set statusline=%F%m%r%h%w\[POS=%l,%v][%p%%]\%&#123;strftime(\"%d/%m/%y\ -\ %H:%M\")&#125;" 总是显示状态行set laststatus=2" 制表符为4set tabstop=4" 统一缩进为4set softtabstop=4set shiftwidth=4" 在c,c++,python文件中用空格代替制表符autocmd FileType c,cpp,python set shiftwidth=4 | set expandtab" 侦测文件类型filetype on" 载入文件类型插件filetype plugin on" 为特定文件类型载入相关缩进文件filetype indent on " 如果文件类型为.sh文件 if &amp;filetype == 'sh' call setline(1, "\#########################################################################") call append(line("."), "\# File Name: ".expand("%")) call append(line(".")+1, "\# Author: Sheldon") call append(line(".")+2, "\# mail: tinarychina@gmail.com") call append(line(".")+3, "\# Created Time: ".strftime("%F %R")) call append(line(".")+4, "\#########################################################################") call append(line(".")+5, "\#!/bin/bash") call append(line(".")+6, "") else call setline(1, "/*************************************************************************") call append(line("."), " &gt; File Name: ".expand("%")) call append(line(".")+1, " &gt; Author: Sheldon") call append(line(".")+2, " &gt; Mail: tinarychina@gmail.com ") call append(line(".")+3, " &gt; Created Time: ".strftime("%F %R")) call append(line(".")+4, " ************************************************************************/") call append(line(".")+5, "") endif if &amp;filetype == 'python' call append(line(".")+5, "\#!/usr/bin/env python") call append(line(".")+6, "\#coding: utf-8") call append(line(".")+7, "") endif if &amp;filetype == 'cpp' call append(line(".")+6, "#include&lt;iostream&gt;") call append(line(".")+7, "using namespace std;") call append(line(".")+8, "") endif if &amp;filetype == 'c' call append(line(".")+6, "#include&lt;stdio.h&gt;") call append(line(".")+7, "") endif " 新建文件后，自动定位到文件末尾 autocmd BufNewFile * normal Gendfunc vim 安装主题在~/.vim/路径下新建一个colors文件夹，然后下载主题，例如：https://github.com/tomasr/molokai，将下载好的molokai.vim放入colors文件夹中。 使用vim打开~/.vimrc，并添加：12345&quot; 代码颜色主题syntax onsyntax enableset t_Co=256colorscheme molokai 然后重新打开vim编辑器，就发现主题已经更换了]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zsh命令大全]]></title>
    <url>%2F2019%2F08%2F28%2Fzsh%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[bash和zsh两种shell功能非常相似，只不过zsh的功能比bash更强大一些。这两种shell的快捷键命令也非常相似，对于常用shell的人来说，了解一些快捷键操作将会十分有益，因为使用快捷键将能大大节约操作时间。大部分快捷键是用来快速导航或编辑当前命令行。 但是！！！ 记不住呀，所以记录一下~ ⌃ + u：清空当前行 ⌃ + a：移动到行首 ⌃ + e：移动到行尾 ⌃ + f：向前移动 ⌃ + b：向后移动 ⌃ + p：上一条命令 ⌃ + n：下一条命令 ⌃ + r：搜索历史命令 ⌃ + y：召回最近用命令删除的文字 ⌃ + h：删除光标之前的字符 ⌃ + d：删除光标所指的字符 ⌃ + w：删除光标之前的单词 ⌃ + k：删除从光标到行尾的内容 ⌃ + t：交换光标和之前的字符 ⌘ + Click：可以打开文件，文件夹和链接 ⌘ + n：新建窗口 ⌘ + t：新建标签页 ⌘ + w：关闭当前页 ⌘ + 数字&amp;⌘ + 方向键：切换标签页 ⌥⌘ + 数字：切换窗口 ⌘ + enter：切换全屏 ⌘ + d：左右分屏 ⇧⌘ + d：上下分屏 ⌘ + ;：自动补全历史记录 ⇧⌘ + h：自动补全剪贴板历史 ⌥⌘ + e：查找所有来定位某个标签页 ⌘ + r&amp;⌃ + l：清屏 ⌘ + /：显示光标位置 ⌥⌘ + b：历史回放 ⌘ + f：查找，然后用tab和⇧ + tab可以向右和向左补全，补全之后的内容会被自动复制， 还可以用⌥ + enter将查找结果输入终端]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac终端神器--iTerm2]]></title>
    <url>%2F2019%2F08%2F28%2FMac%E7%BB%88%E7%AB%AF%E7%A5%9E%E5%99%A8-iTerm2%2F</url>
    <content type="text"><![CDATA[打造人见人爱的终端 下载iTerm2 官网下载 安装完成后，在/bin目录下会多出一个zsh的文件。 Mac系统默认使用dash作为终端，可以使用命令修改默认使用zsh： 1chsh -s /bin/zsh]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git贮藏（Stashing）]]></title>
    <url>%2F2019%2F08%2F22%2FGit%E8%B4%AE%E8%97%8F%EF%BC%88Stashing%EF%BC%89%2F</url>
    <content type="text"><![CDATA[我们在工作中经常会遇到一种情况，当我们在项目的当前分支修改了一些代码，工作进行到一半，又需要去其他的分支处理一些事情；这个时候，你不想把修改了一半的代码提交到git，但不提交又无法切到其他分支；怎么办呢？ 我们可以使用Git的一个功能——Stashing（贮藏）。 作用Stashing可以将当前工作区已修改状态下的文件储存起来，在栈中增加一条存储。 用法列出所有的存储列表1git stash list 应用存储1git stash pop 重新应用最后一次的存储，同时，将其从栈中移走。 1git stash apply stash@&#123;0&#125; 通过存储名应用到当前工作区，但并不会从栈中移除。 取消贮藏1git stash show -p stash@&#123;0&#125; | git apply -R 取消之前所应用贮藏的修改。 移除贮藏1git stash drop &lt;stash name&gt; 从栈中移除贮藏 通过贮藏创建新分支1git stash branch &lt;branch name&gt; 创建一个新的分支，并且检出你贮藏工作时所做的提交，重新应用于你的工作，如果成功，将会丢弃贮藏。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS搭建远程私有库]]></title>
    <url>%2F2019%2F08%2F21%2FiOS%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E7%A7%81%E6%9C%89%E5%BA%93%2F</url>
    <content type="text"><![CDATA[iOS搭建远程私有库 一、创建远程私有索引库 这个库的作用是存放索引文件 二、将远程索引库链接（下载）到本地1pod repo add &lt;仓库名&gt; &lt;仓库源地址（SSH地址）&gt; 三、创建远程代码私有仓库1. 在本地创建 pod 项目1pod lib create &lt;pod库名字&gt; 执行结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051Cloning `https://github.com/CocoaPods/pod-template.git` into `&lt;我的pod库名称，手动马赛克&gt;`.Configuring &lt;我的pod库名称，手动马赛克&gt; template.------------------------------To get you started we need to ask a few questions, this should only take a minute.If this is your first time we recommend running through with the guide: - https://guides.cocoapods.org/making/using-pod-lib-create.html ( hold cmd and click links to open in a browser. )What platform do you want to use?? [ iOS / macOS ] &gt; iOSWhat language do you want to use?? [ Swift / ObjC ] &gt; ObjCWould you like to include a demo application with your library? [ Yes / No ] &gt; YesWhich testing frameworks will you use? [ Specta / Kiwi / None ] &gt; KiwiWould you like to do view based testing? [ Yes / No ] &gt; YesWhat is your class prefix? &gt; TYRunning pod install on your new library.Analyzing dependenciesFetching podspec for `&lt;我的pod库名称，手动马赛克&gt;` from `../`Downloading dependenciesInstalling &lt;我的pod库名称，手动马赛克&gt; (0.1.0)Installing FBSnapshotTestCase (2.1.4)Installing Kiwi (3.0.0)Generating Pods projectIntegrating client project[!] Please close any current Xcode sessions and use `&lt;我的pod库名称，手动马赛克&gt;.xcworkspace` for this project from now on.Sending statsPod installation complete! There are 3 dependencies from the Podfile and 3 total pods installed. Ace! you're ready to go! We will start you off by opening your project in Xcode open '&lt;我的pod库路径，手动马赛克&gt;'To learn more about the template see `https://github.com/CocoaPods/pod-template.git`.To learn more about creating a new pod, see `https://guides.cocoapods.org/making/making-a-cocoapod`. 2. 修改内容把需要提交的代码放到路径(当前项目根目录/项目名/Classes/)下面，删除ReplaceMe.m。 3. 修改.podspec文件4. 提交提交代码到本地pod库 1234git add .git commit -m "add file"git remote add origin &lt;远端pod库地址:https://gitlab.com/xxx.git&gt;git push -u origin master 打tag并提交tag到origin 12git tag 0.1.0git push --tags 验证本地spec文件是否有误 1pod lib lint 验证远程spec文件是否有误 1pod spec lint 上传.podspec索引文件到索引库 1pod repo push &lt;索引库名称&gt; &lt;.podspec文件名称&gt; --allow-warnings --use-libraries --verbose tip: 消除pod库警告inhibit_all_warnings!。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS常用第三方库整理]]></title>
    <url>%2F2019%2F08%2F19%2FiOS%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[整理我们在APP开发过程中经常或者必须使用的一些第三方的pod库。 主模块布局 Masonry 代码布局 UITableView-FDTemplateLayoutCell tableview自适应高度 指示器 MBProgressHUD SVProgressHUD Toast MJRefresh 网络 AFNetworking YTKNetwork 数据处理 MJExtension YYModel Protobuf 存储和读取结构化数据 数据库 FMDB WCDB 推送 JPush 极光 分享 UMengSocial 友盟 图片 SDWebImage 图片下载和缓存 MWPhotoBrowser 图片浏览 FLAnimatedImage gif动图加载 SDCycleScrollView 轮播图 音视频 LFLiveKit RTMP streaming SDK for iOS. 字符串处理 TTTAttributedLabel 富文本 YYText 动画 pop CYLTabBarController tabbar 动画 js-OC交互 WebViewJavascriptBridge 系统 Bugly UICKeyChainStore 钥匙串API Reachability 网络情况监测 CocoaLumberjack Mac和iOS上一个简捷、强大、灵活的日志框架 DoraemonKit 一款功能齐全的客户端（ iOS 、Android ）研发助手 MLeaksFinder 内存泄露 SAMKeychain 钥匙串API FLEX 可以在app中进行debug 其他 YYKit IQKeyboardManager 键盘管理 ReactiveObjC RAC BlocksKit]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WCDB的使用和封装]]></title>
    <url>%2F2019%2F08%2F13%2FWCDB%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[公司的项目所使用的数据库是FMDB，并对其进行了二次封装；由于年久失修，遂决定改为WCDB，因此，抽时间对WCDB进行了一番研究。WCDB是腾讯开源的一款供客户端使用的数据库，基于SQLCipher，支持iOS，macOS和Android。 特点易用WCDB通过深度封装数据库语言，使开发者可以通过OC或者Swift的代码方式使用数据库，无需为了拼接SQL而写一大坨代码； 高效WCDB通过框架层和SQLCipher源码优化，使其有更高效的表现； 完整WCDB覆盖了数据库使用过程中大多数的使用场景和需求； 加密：WCDB提供基于SQLCipher的数据库加密。 损坏修复：WCDB内建了Repair Kit用于修复损坏的数据库。 反注入：WCDB内建了对SQL注入的保护。 安装WCDB使用Cocoapods安装WCDB： 更新pod repo：pod repo update 在Podfile对应的target中，添加pod &#39;WCDB&#39; 执行pod install --verbose 打开workspace 引入头文件’#import ‘ 使用使用WCD分为2部分：ORM和CRUD。 ORMORM的作用就是映射数据库字段和我们的数据模型；WCDB使用内置的宏来连接类、属性与表、字段。共有三类宏，分别对应数据库的字段、索引和约束。 字段宏字段宏以WCDB_SYNTHESIZE开头，定义了类属性与字段之间的联系。 WCDB_SYNTHESIZE(className, propertyName)是最简单的的用法，直接使用propertyName作为数据库中字段的名称。 WCDB_SYNTHESIZE_COLUMN(className, propertyName, columnName)支持自定义字段名。 WCDB_SYNTHESIZE_DEFAULT(className, propertyName, defaultValue)自定义字段默认值（可以是任意C类型或NSString, NSData, NSNumber, NSNull）。 WCDB_SYNTHESIZE_COLUMN_DEFAULT(className, propertyName, cloumnName, defaultValue)。 字段宏参考 索引宏索引宏以WCDB_INDEX开头，定义了数据库的索引属性。支持定义索引的排序方式。 WCDB_INDEX(className, indexSubfixName, propertyName)是基础用法，直接指定某个字段为索引。同时，WCDB会将tableName + indexSubfixName作为该索引的名字。 WCDB_INDEX_ASC(className, indexSubfixName, propertyName)升序。 WCDB_INDEX_DESC(className, indexSubfixName, propertyName)降序。 WCDB_UNIQUE_INDEX(className, indexSubfixName, propertyName)唯一索引。 WCDB_UNIQUE_INDEX_ASC(className, indexSubfixName, propertyName)唯一索引升序排列。 WCDB_UNIQUE_INDEX_DESC(className, indexSubfixName, propertyName)唯一索引降序排列。 WCDB通过indexSubfixName匹配多索引。相同的indexSubfixName会被组合为多字段索引。 例如： 12WCDB_INDEX(WCTSampleORMIndex, &quot;_multiIndexSubfix&quot;, multiIndexPart1)WCDB_INDEX(WCTSampleORMIndex, &quot;_multiIndexSubfix&quot;, multiIndexPart2) 索引宏例子 约束宏约束宏包含了字段约束和表约束。 字段约束主键约束以WCDB_PRIMARY开头，定义了数据库的主键；支持自定义主键的排序方式、是否自增。 WCDB_PRIMARY(className, propertyName)是基础用法，直接使用propertyName作为数据库的主键。 WCDB_PRIMARY_ASC(className, propertyName)主键升序。 WCDB_PRIMARY_DESC(className, propertyName)主键降序。 WCDB_PRIMARY_AUTO_INCREMENT(className, propertyName)主键自增。 WCDB_PRIMARY_ASC_AUTO_INCREMENT(className, propertyName)主键自增及升序的组合。 WCDB_PRIMARY_DESC_AUTO_INCREMENT(className, propertyName)主键自增及降序组合。 非空约束：WCDB_NOT_NULL(className, propertyName)，当该字段插入数据为空时，数据库会返回错误。唯一约束：WCDB_UNIQUE(className, propertyName)，当该字段插入数据与其他列冲突时，数据库会返回错误。 注意：使用了主键自增后，创建的模型必须设置isAutoIncrement为YES。 表约束多主键约束以WCDB_MULTI_PRIMARY开头，定义了数据库的多主键，支持自定义每个主键的排序方式。 WCDB_MULTI_PRIMARY(className, constraintName, propertyName)为基础用法，多个主键通过constrainName匹配。 WCDB_MULTI_PRIMARY_ASC(className, constraintName, propertyName)多主键升序。 WCDB_MULTI_PRIMARY_DESC(className, constraintName, propertyName)多主键降序。 多字段唯一约束以WCDB_MULTI_UNIQUE开头，定义了数据库的多字段组合唯一，支持自定义每个字段的排序方式。 WCDB_MULTI_UNIQUE(className, constraintName, propertyName)基础用法。 WCDB_MULTI_UNIQUE_ASC(className, constraintName, propertyName)升序。 WCDB_MULTI_UNIQUE_DESC(className, constraintName, propertyName)降序。 表约束示例 修改字段由于SQLite只支持增加字段，并不支持删除和重命名字段。因此，WCDB在删除字段的时候只是将其定义删除；删除定义后，WCDB只是将该字段忽略，其旧数据依然在数据库中，但新增的数据基本不会因为该字段产生额外的性能和空间损耗。由于SQLite不支持修改字段名称，所以WCDB采用重新映射的方式。 CRUDWCDB提供了三个基础类进行数据库操作：WCTDatabase、WCTTable、WCTTransaction。它们的接口都是线程安全的。 WCTDatabase表示一个数据库，可以进行所有的数据库操作。 创建数据库WCTDatabase通过initWithPath:接口进行创建。该接口会同时创建path中不存在的目录。 12NSString* path = @"&lt;这里是数据库路径&gt;";WCTDatabase *database = [[WCTDatabase alloc] initWithPath:path]; 打开数据库WCDB采用懒加载的方式管理对象，因此SQLite连接会在第一次被访问的时候打开。开发者不需要手动打开数据库。 12345678// 判断数据库是否能够打开if ([database canOpen]) &#123; //...&#125;// 判断数据库是否已经打开if ([database isOpened]) &#123; //...&#125; 关闭数据库1[database close]; 注意：由于WCDB支持多线程访问数据库，因此，该接口会阻塞等待所有线程均已操作结束。 对于一个特定路径的数据库，WCDB会在所有对象对其的引用结束时，自动关闭数据库，并且回收内存和SQLite连接。因此，大多数的时候，开发者并不需要手动关闭数据库。 WCTTable表示一个表。等价于预设了class和tableName的WCTDatabase，仅可以进行数据库的CRUD。 12WCTTable* table = [database getTableOfName:tableName withClass:WCTSampleTable.class]; WCTTransaction表示一个事务。 1WCTTransaction *transaction = [database getTransaction]; 与WCTDatabase的事务不同，WCTTransaction可以在函数和对象之间传递，实现跨线程的事务。 12345678910111213//You can do a transaction in different threads using WCTTransaction.//But it's better to run serially, or an inner thread mutex will guarantee this.BOOL ret = [transaction begin];dispatch_async(dispatch_queue_create("other thread", DISPATCH_QUEUE_SERIAL), ^&#123; WCTSampleTransaction *object = [[WCTSampleTransaction alloc] init]; BOOL ret = [transaction insertObject:object into:tableName]; if (ret) &#123; [transaction commit]; &#125; else &#123; [transaction rollback]; &#125;&#125;); CRUD操作创建数据库12345678910BOOL ret = [database createTableAndIndexesOfName:tableName withClass:WCTSampleTable.class];// 或者BOOL ret = [database createTableOfName:tableName withColumnDefList:&#123; WCTSampleTable.intValue.def(WCTColumnTypeInteger32), WCTSampleTable.stringValue.def(WCTColumnTypeString) &#125;]; 将数据插入表 insertObject:into:和insertObjects:into:，插入单个或多个对象 insertOrReplaceObject:into和insertOrReplaceObjects:into，插入单个或多个对象。当对象的主键在数据库内已经存在时，更新数据；否则插入对象。 insertObject:onProperties:into:和insertObjects:onProperties:into:，插入单个或多个对象的部分属性 insertOrReplaceObject:onProperties:into和insertOrReplaceObjects:onProperties:into，插入单个或多个对象的部分属性。当对象的主键在数据库内已经存在时，更新数据；否则插入对象。 删除数据 deleteAllObjectsFromTable:删除表内的所有数据 deleteObjectsFromTable:后可组合接 where、orderBy、limit、offset以删除部分数据 更新数据 updateAllRowsInTable:onProperties:withObject:，通过object更新数据库中所有指定列的数据 updateRowsInTable:onProperties:withObject:后可组合接 where、orderBy、limit、offset以通过object更新指定列的部分数据 updateAllRowsInTable:onProperty:withObject:，通过object更新数据库某一列的数据 updateRowsInTable:onProperty:withObject:后可组合接 where、orderBy、limit、offset以通过object更新某一列的部分数据 updateAllRowsInTable:onProperties:withRow:，通过数组更新数据库中的所有指定列的数据 updateRowsInTable:onProperties:withRow:后可组合接 where、orderBy、limit、offset以通过数组更新指定列的部分数据 updateAllRowsInTable:onProperty:withRow:，通过数组更新数据库某一列的数据 updateRowsInTable:onProperty:withRow:后可组合接 where、orderBy、limit、offset以通过数组更新某一列的部分数 查找数据 getOneObjectOfClass:fromTable:后可接 where、orderBy、limit、offset以从数据库中取出一行数据并组合成object getOneObjectOnResults:fromTable:后可接 where、orderBy、limit、offset以从数据库中取出一行数据的部分列并组合成object getOneRowOnResults:fromTable:后可接 where、orderBy、limit、offset以从数据库中取出一行数据的部分列并组合成数组 getOneColumnOnResult:fromTable:后可接 where、orderBy、limit、offset以从数据库中取出一列数据并组合成数组 getOneDistinctColumnOnResult:fromTable:后可接 where、orderBy、limit、offset以从数据库中取出一列数据，并取distinct后组合成数组。 getOneValueOnResult:fromTable:后可接 where、orderBy、limit、offset以从数据库中取出一行数据的某一列 getAllObjectsOfClass:fromTable:，取出所有数据，并组合成object getObjectsOfClass:fromTable:后可接 where、orderBy、limit、offset以从数据库中取出一部分数据，并组合成object getAllObjectsOnResults:fromTable:，取出所有数据的指定列，并组合成object getObjectsOnResults:fromTable:后可接where、orderBy、limit、offset以从数据库中取出一部分数据的指定列，并组合成object getAllRowsOnResults:fromTable:，取出所有数据的指定列，并组合成数组 getRowsOnResults:fromTable:后可接where、orderBy、limit、offset以从数据库中取出一部分数据的指定列，并组合成数组 CRUD示例 链式接口WCDB对于增删改查操作，都提供了对应的类以实现链式调用 WCTInsert WCTDelete WCTUpdate WCTSelect WCTRowSelect WCTMultiSelect 123456WCTSelect *select = [database prepareSelectObjectsOnResults:Message.localID.max() fromTable:@"message"];NSArray&lt;Message *&gt; *objects = [[[[select where:Message.localID &gt; 0] groupBy:&#123;Message.content&#125;] orderBy:Message.createTime.order()] limit:10].allObjects; 其他事务调试SQL[WCTStatistics SetGlobalSQLTrace:]会监控所有执行的SQL，该接口可用于调试，确定SQL是否执行正确。 1234//SQL Execution Monitor[WCTStatistics SetGlobalSQLTrace:^(NSString *sql) &#123; NSLog(@"SQL: %@", sql);&#125;]; WINQ自定义类型隔离C++代码关于数据库加密高级用法主键自增(Auto Increment)as重定向多表查询基础类共享对于同一个路径的数据库，不同的WCTDatabase、WCTTable、WCTTransaction对象共享同一个WCDB核心。 1234WCTDatabase* database1 = [[WCTDatabase alloc] initWithPath:path];WCTDatabase* database2 = [[WCTDatabase alloc] initWithPath:path];database1.tag = 1;NSLog(@"%d", database2.tag);//print 1 文件操作WCDB提供了删除数据库、移动数据库、获取数据库占用空间和使用路径的文件操作接口。 1234- (BOOL)removeFilesWithError:(WCTError **)error;- (BOOL)moveFilesToDirectory:(NSString *)directory withExtraFiles:(NSArray&lt;NSString *&gt; *)extraFiles andError:(WCTError **)error;- (NSArray&lt;NSString *&gt; *)getPaths;- (NSUInteger)getFilesSizeWithError:(WCTError **)error; 若是一个线程正在操作数据库，而另一个线程进行移动数据库的操作，可能会导致数据库的损坏；因此，文件操作通常放在关闭数据库后。 1234567[database close:^&#123; WCTError *error = nil; BOOL ret = [database moveFilesToDirectory:otherDirectory withError:&amp;error]; if (!ret) &#123; NSLog(@"Move files Error %@", error); &#125;&#125;];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jenkins执行GitHub中的Python代码]]></title>
    <url>%2F2019%2F08%2F13%2Fjenkins%E6%89%A7%E8%A1%8CGitHub%E4%B8%AD%E7%9A%84Python%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[jenkins是很好用的一个自动化测试和执行代码的工具，查看如何安装jenkins; 我们的代码是存储在代码仓库里面的，一般，我们使用GitHub来存放我们的代码； 那么，怎么使用jenkins来直接执行我们存放在GitHub中的代码呢？ jenkins 创建一个任务 配置jenkins选择GitHub项目 填写源码管理 如果没有凭证，就点击Credentials右边的添加注意：这里添加的是SSH的私钥 如何查询自己的ssh密钥？ 进入ssh文件夹 1cd ~/.ssh 查看私钥文件 1cat id_rsa 定时构建（可选） 每次构建之前清空一下Jenkins工作空间，避免拉取的代码有冲突 构建在构建选项中选择增加构建步骤-&gt;Execute shell; 然后填写需要执行的脚本： 最后点击保存，然后就可以build我的项目啦！]]></content>
      <categories>
        <category>jenkins</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git本地库连接远端库]]></title>
    <url>%2F2019%2F08%2F13%2Fgit%E6%9C%AC%E5%9C%B0%E5%BA%93%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%AB%AF%E5%BA%93%2F</url>
    <content type="text"><![CDATA[我们使用git有时候会有这种情况：我们只在本地创建了git仓库，并没有在GitHub上创建远端仓库；当我们在本的的git仓库提交了几次修改后，想要将此git仓库放在GitHub，那么我们需要怎么做呢？ 连接远程仓库假设我们已经在GitHub上创建了一个空的仓库 先cd到我们本地git仓库所在的目录,然后执行git连接操作 1git remote add origin git@github.com:FlameTinary/TYPythonTools.git 错误步骤然后执行git pull，会发现，报错了： 123456789101112131415161718192021222324warning: no common commitsremote: Enumerating objects: 4, done.remote: Counting objects: 100% (4/4), done.remote: Compressing objects: 100% (4/4), done.Unpacking objects: 100% (4/4), done.remote: Total 4 (delta 0), reused 0 (delta 0), pack-reused 0From github.com:FlameTinary/TYPythonTools * [new branch] master -&gt; origin/masterThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details. git pull &lt;remote&gt; &lt;branch&gt;If you wish to set tracking information for this branch you can do so with: git branch --set-upstream-to=origin/&lt;branch&gt; master ✘ sheldon@tianyudeMacBook-Pro  ~/Documents/TYPythonTools   master  git pull remote masterfatal: &apos;remote&apos; does not appear to be a git repositoryfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 执行git pull origin master --allow-unrelated-histories也不行； 那么怎么办呢？ 正确步骤原来是我们本的的branch和远端的branch无法对应起来； 可以执行git branch --set-upstream-to=origin/master master，会出现： 1Branch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;origin&apos;. 然后我们再执行git pull origin master --allow-unrelated-histories； 最后将本地内容推送到远端： 1git push -u origin master 大功告成！！ 总结：1. 连接远端仓库1git remote add origin git@github.com:FlameTinary/TYPythonTools.git 2. 连接分支1git branch --set-upstream-to=origin/master master 3. 拉取远端代码1git pull origin master --allow-unrelated-histories 4. 推送本地代码到远端1git push -u origin master]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决jenkins在装有anaconda环境的机器上执行Python文件，Python环境错误的问题]]></title>
    <url>%2F2019%2F08%2F13%2F%E8%A7%A3%E5%86%B3jenkins%E5%9C%A8%E8%A3%85%E6%9C%89anaconda%E7%8E%AF%E5%A2%83%E7%9A%84%E6%9C%BA%E5%99%A8%E4%B8%8A%E6%89%A7%E8%A1%8CPython%E6%96%87%E4%BB%B6%EF%BC%8CPython%E7%8E%AF%E5%A2%83%E9%94%99%E8%AF%AF%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[使用jenkins定时执行某些任务或者执行测试是很方便的一个工作，但是有些时候如果碰到一些环境或者冲突方面的问题也是比较头疼的。 python分为2.7和3.0以上两个大版本，所以一些朋友的电脑中会同时存在这两种版本。由于我的电脑是MacBook pro， 所以系统中自动安装的2.7的版本。 但我需要使用3.7的版本作为主要开发，且系统中的2.7版本也不能删除，因为系统的一些功能需要依赖2.7的版本。 所以，在经过双版本的折腾后，还是选择了Anaconda的怀抱。 以前一直使用Jenkins自动执行iOS程序，最近写了一个Python的工具，需要定时执行，所以也是用Jenkins来操作；但是，问题来了，在Jenkins中的Execute shell中直接写了： 1python "文件路径" 这样却报错了… 可是明明在Terminal中执行没有问题啊！！ 第一次猜测可能是Jenkins找不到python的路径，所以在Jenkins -&gt; Manage Jenkins -&gt; Configure System -&gt; 全局属性 -&gt; Environment variables -&gt; 中添加了Python的路径，然并卵！ 继续折腾，既然找不到包，那么我就把包放在工程文件所在的路径中，最后还是找不到! 最后直接使用python绝对路径执行文件 1/anaconda3/bin/python ~/Documents/TYPythonTools/TYChartRobot.py]]></content>
      <categories>
        <category>jenkins</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Command Line Tools 使用]]></title>
    <url>%2F2019%2F08%2F12%2FCommand-Line-Tools-%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[安装相关命令查看目前我使用的工具XCODE版本12345# commandxcode-select --print-path# print/Applications/Xcode.app/Contents/Developer 选择XCODE中的默认版本用于我的命令行工具12345678# commandsudo xcode-select -switch &lt;path/to/&gt;Xcode.app# 注释`&lt;path/to/&gt;`是路径要使用的开发Xcode.app包# 实例sudo xcode-select -switch /Applications/Xcode5.1.1/Xcode.app 使用xcodebuild是一个命令行工具，可以让你的工程通过projects、workspaces进行编译、测试、分析、打包。它可以运行在包含一个或多个Target的工程上面，或者在projects 、workspaces包含scheme上面。 列出所有的Target123456789101112131415161718192021222324# commandxcodebuild -list -project &lt;your project name&gt;.xcodeproj# 注释`&lt;your project name&gt;`是你工程的名称# 示例xcodebuild -list -project TYDemos.xcodeproj# print Information about project "TYDemos": Targets: TYDemos qwer Build Configurations: Debug Release If no build configuration is specified and -scheme is not passed then "Release" is used. Schemes: qwer TYDemos 编译你工程的配置和schemes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158# commandxcodebuild -scheme &lt;your scheme name&gt; build# 注释`&lt;your scheme name&gt;`是你选择特定的编译和执行的一个scheme# 示例xocdebuild -scheme TYGameSceneDemo build# printnote: Using new build systemnote: Planning build2019-06-13 11:23:50.516 xcodebuild[61408:7436815] DTDeviceKit: deviceType from 00008006-000F29961AC1002E was NULL2019-06-13 11:23:50.516 xcodebuild[61408:7436815] DTDeviceKit: deviceType from 00008006-000F29961AC1002E was NULL2019-06-13 11:23:50.516 xcodebuild[61408:7436815] iPhoneSupport: 📱&lt;DVTiOSDevice (0x7ff824b6d8b0), Sheldon’s iPhone 7plus, iPhone, 12.2 (16E227), 312a7baecea95257c11a5eb61d1203138faac05c&gt; unable to mount DeveloperDiskImage (Error Domain=com.apple.dtdevicekit Code=601 "Could not find platform" UserInfo=&#123;NSLocalizedDescription=Could not find platform&#125;)note: Constructing build descriptionCreateBuildDirectory /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo builtin-create-build-directory /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/ProductsCreateBuildDirectory /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo builtin-create-build-directory /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindexMkDir /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo /bin/mkdir -p /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.appProcessProductPackaging /Users/sheldon/Library/MobileDevice/Provisioning\ Profiles/e91c7402-e02a-45ac-aff3-c73c563abcfb.mobileprovision /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app/embedded.mobileprovision (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo builtin-productPackagingUtility /Users/sheldon/Library/MobileDevice/Provisioning\ Profiles/e91c7402-e02a-45ac-aff3-c73c563abcfb.mobileprovision -o /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app/embedded.mobileprovisionWriteAuxiliaryFile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/DerivedSources/Entitlements.plist (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo write-file /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/DerivedSources/Entitlements.plistProcessProductPackaging "" /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo.app.xcent (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemoEntitlements:&#123; "application-identifier" = "CC9XV3GRSV.top.sheldon.TYGameSceneDemo"; "com.apple.developer.team-identifier" = CC9XV3GRSV; "get-task-allow" = 1; "keychain-access-groups" = ( "CC9XV3GRSV.top.sheldon.TYGameSceneDemo" );&#125; builtin-productPackagingUtility -entitlements -format xml -o /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo.app.xcentWriteAuxiliaryFile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/all-product-headers.yaml (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo write-file /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/all-product-headers.yamlWriteAuxiliaryFile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo.hmap (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo write-file /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo.hmapWriteAuxiliaryFile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-project-headers.hmap (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo write-file /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-project-headers.hmapWriteAuxiliaryFile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-own-target-headers.hmap (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo write-file /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-own-target-headers.hmapWriteAuxiliaryFile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-generated-files.hmap (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo write-file /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-generated-files.hmapWriteAuxiliaryFile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-all-non-framework-target-headers.hmap (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo write-file /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-all-non-framework-target-headers.hmapWriteAuxiliaryFile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-all-target-headers.hmap (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo write-file /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-all-target-headers.hmapCompileC /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/GameViewController.o /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/GameViewController.m normal arm64 objective-c com.apple.compilers.llvm.clang.1_0.compiler (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo export LANG=en_US.US-ASCII /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -x objective-c -arch arm64 -fmessage-length=178 -fdiagnostics-show-note-include-stack -fmacro-backtrace-limit=0 -fcolor-diagnostics -std=gnu11 -fobjc-arc -fobjc-weak -fmodules -gmodules -fmodules-cache-path=/Users/sheldon/Library/Developer/Xcode/DerivedData/ModuleCache.noindex -fmodules-prune-interval=86400 -fmodules-prune-after=345600 -fbuild-session-file=/Users/sheldon/Library/Developer/Xcode/DerivedData/ModuleCache.noindex/Session.modulevalidation -fmodules-validate-once-per-build-session -Wnon-modular-include-in-framework-module -Werror=non-modular-include-in-framework-module -Wno-trigraphs -fpascal-strings -O0 -fno-common -Wno-missing-field-initializers -Wno-missing-prototypes -Werror=return-type -Wdocumentation -Wunreachable-code -Wno-implicit-atomic-properties -Werror=deprecated-objc-isa-usage -Wno-objc-interface-ivars -Werror=objc-root-class -Wno-arc-repeated-use-of-weak -Wimplicit-retain-self -Wduplicate-method-match -Wno-missing-braces -Wparentheses -Wswitch -Wunused-function -Wno-unused-label -Wno-unused-parameter -Wunused-variable -Wunused-value -Wempty-body -Wuninitialized -Wconditional-uninitialized -Wno-unknown-pragmas -Wno-shadow -Wno-four-char-constants -Wno-conversion -Wconstant-conversion -Wint-conversion -Wbool-conversion -Wenum-conversion -Wno-float-conversion -Wnon-literal-null-conversion -Wobjc-literal-conversion -Wshorten-64-to-32 -Wpointer-sign -Wno-newline-eof -Wno-selector -Wno-strict-selector-match -Wundeclared-selector -Wdeprecated-implementations -DDEBUG=1 -DOBJC_OLD_DISPATCH_PROTOTYPES=0 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS12.2.sdk -fstrict-aliasing -Wprotocol -Wdeprecated-declarations -miphoneos-version-min=12.2 -g -Wno-sign-conversion -Winfinite-recursion -Wcomma -Wblock-capture-autoreleasing -Wstrict-prototypes -Wno-semicolon-before-method-body -Wunguarded-availability -fembed-bitcode-marker -index-store-path /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Index/DataStore -iquote /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-generated-files.hmap -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-own-target-headers.hmap -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-all-target-headers.hmap -iquote /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-project-headers.hmap -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/include -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/DerivedSources-normal/arm64 -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/DerivedSources/arm64 -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/DerivedSources -F/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos -MMD -MT dependencies -MF /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/GameViewController.d --serialize-diagnostics /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/GameViewController.dia -c /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/GameViewController.m -o /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/GameViewController.oCompileC /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/AppDelegate.o /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/AppDelegate.m normal arm64 objective-c com.apple.compilers.llvm.clang.1_0.compiler (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo export LANG=en_US.US-ASCII /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -x objective-c -arch arm64 -fmessage-length=178 -fdiagnostics-show-note-include-stack -fmacro-backtrace-limit=0 -fcolor-diagnostics -std=gnu11 -fobjc-arc -fobjc-weak -fmodules -gmodules -fmodules-cache-path=/Users/sheldon/Library/Developer/Xcode/DerivedData/ModuleCache.noindex -fmodules-prune-interval=86400 -fmodules-prune-after=345600 -fbuild-session-file=/Users/sheldon/Library/Developer/Xcode/DerivedData/ModuleCache.noindex/Session.modulevalidation -fmodules-validate-once-per-build-session -Wnon-modular-include-in-framework-module -Werror=non-modular-include-in-framework-module -Wno-trigraphs -fpascal-strings -O0 -fno-common -Wno-missing-field-initializers -Wno-missing-prototypes -Werror=return-type -Wdocumentation -Wunreachable-code -Wno-implicit-atomic-properties -Werror=deprecated-objc-isa-usage -Wno-objc-interface-ivars -Werror=objc-root-class -Wno-arc-repeated-use-of-weak -Wimplicit-retain-self -Wduplicate-method-match -Wno-missing-braces -Wparentheses -Wswitch -Wunused-function -Wno-unused-label -Wno-unused-parameter -Wunused-variable -Wunused-value -Wempty-body -Wuninitialized -Wconditional-uninitialized -Wno-unknown-pragmas -Wno-shadow -Wno-four-char-constants -Wno-conversion -Wconstant-conversion -Wint-conversion -Wbool-conversion -Wenum-conversion -Wno-float-conversion -Wnon-literal-null-conversion -Wobjc-literal-conversion -Wshorten-64-to-32 -Wpointer-sign -Wno-newline-eof -Wno-selector -Wno-strict-selector-match -Wundeclared-selector -Wdeprecated-implementations -DDEBUG=1 -DOBJC_OLD_DISPATCH_PROTOTYPES=0 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS12.2.sdk -fstrict-aliasing -Wprotocol -Wdeprecated-declarations -miphoneos-version-min=12.2 -g -Wno-sign-conversion -Winfinite-recursion -Wcomma -Wblock-capture-autoreleasing -Wstrict-prototypes -Wno-semicolon-before-method-body -Wunguarded-availability -fembed-bitcode-marker -index-store-path /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Index/DataStore -iquote /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-generated-files.hmap -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-own-target-headers.hmap -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-all-target-headers.hmap -iquote /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-project-headers.hmap -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/include -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/DerivedSources-normal/arm64 -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/DerivedSources/arm64 -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/DerivedSources -F/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos -MMD -MT dependencies -MF /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/AppDelegate.d --serialize-diagnostics /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/AppDelegate.dia -c /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/AppDelegate.m -o /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/AppDelegate.oWriteAuxiliaryFile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/TYGameSceneDemo.LinkFileList (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo write-file /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/TYGameSceneDemo.LinkFileListCompileC /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/main.o /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/main.m normal arm64 objective-c com.apple.compilers.llvm.clang.1_0.compiler (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo export LANG=en_US.US-ASCII /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -x objective-c -arch arm64 -fmessage-length=178 -fdiagnostics-show-note-include-stack -fmacro-backtrace-limit=0 -fcolor-diagnostics -std=gnu11 -fobjc-arc -fobjc-weak -fmodules -gmodules -fmodules-cache-path=/Users/sheldon/Library/Developer/Xcode/DerivedData/ModuleCache.noindex -fmodules-prune-interval=86400 -fmodules-prune-after=345600 -fbuild-session-file=/Users/sheldon/Library/Developer/Xcode/DerivedData/ModuleCache.noindex/Session.modulevalidation -fmodules-validate-once-per-build-session -Wnon-modular-include-in-framework-module -Werror=non-modular-include-in-framework-module -Wno-trigraphs -fpascal-strings -O0 -fno-common -Wno-missing-field-initializers -Wno-missing-prototypes -Werror=return-type -Wdocumentation -Wunreachable-code -Wno-implicit-atomic-properties -Werror=deprecated-objc-isa-usage -Wno-objc-interface-ivars -Werror=objc-root-class -Wno-arc-repeated-use-of-weak -Wimplicit-retain-self -Wduplicate-method-match -Wno-missing-braces -Wparentheses -Wswitch -Wunused-function -Wno-unused-label -Wno-unused-parameter -Wunused-variable -Wunused-value -Wempty-body -Wuninitialized -Wconditional-uninitialized -Wno-unknown-pragmas -Wno-shadow -Wno-four-char-constants -Wno-conversion -Wconstant-conversion -Wint-conversion -Wbool-conversion -Wenum-conversion -Wno-float-conversion -Wnon-literal-null-conversion -Wobjc-literal-conversion -Wshorten-64-to-32 -Wpointer-sign -Wno-newline-eof -Wno-selector -Wno-strict-selector-match -Wundeclared-selector -Wdeprecated-implementations -DDEBUG=1 -DOBJC_OLD_DISPATCH_PROTOTYPES=0 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS12.2.sdk -fstrict-aliasing -Wprotocol -Wdeprecated-declarations -miphoneos-version-min=12.2 -g -Wno-sign-conversion -Winfinite-recursion -Wcomma -Wblock-capture-autoreleasing -Wstrict-prototypes -Wno-semicolon-before-method-body -Wunguarded-availability -fembed-bitcode-marker -index-store-path /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Index/DataStore -iquote /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-generated-files.hmap -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-own-target-headers.hmap -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-all-target-headers.hmap -iquote /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-project-headers.hmap -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/include -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/DerivedSources-normal/arm64 -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/DerivedSources/arm64 -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/DerivedSources -F/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos -MMD -MT dependencies -MF /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/main.d --serialize-diagnostics /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/main.dia -c /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/main.m -o /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/main.oLd /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app/TYGameSceneDemo normal arm64 (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo export IPHONEOS_DEPLOYMENT_TARGET=12.2 /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -arch arm64 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS12.2.sdk -L/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos -F/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos -filelist /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/TYGameSceneDemo.LinkFileList -Xlinker -rpath -Xlinker @executable_path/Frameworks -miphoneos-version-min=12.2 -dead_strip -Xlinker -object_path_lto -Xlinker /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/TYGameSceneDemo_lto.o -Xlinker -export_dynamic -Xlinker -no_deduplicate -fembed-bitcode-marker -fobjc-arc -fobjc-link-runtime -Xlinker -dependency_info -Xlinker /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/TYGameSceneDemo_dependency_info.dat -o /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app/TYGameSceneDemoCopy SceneKit assets /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/art.scnassets (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo /Applications/Xcode.app/Contents/Developer/usr/bin/copySceneKitAssets /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/art.scnassets -o /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app/art.scnassets --target-platform=iphoneos --target-version=12.2 --target-build-dir=/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos --resources-folder-path=TYGameSceneDemo.appcopySceneKitAssets: Copy ship.scncopySceneKitAssets: Copy texture.pngcopySceneKitAssets: Running scntool on /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app/art.scnassets/ship.scnCompileAssetCatalog /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/Assets.xcassets (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo /Applications/Xcode.app/Contents/Developer/usr/bin/actool --output-format human-readable-text --notices --warnings --export-dependency-info /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/assetcatalog_dependencies --output-partial-info-plist /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/assetcatalog_generated_info.plist --app-icon AppIcon --compress-pngs --enable-on-demand-resources YES --sticker-pack-identifier-prefix top.sheldon.TYGameSceneDemo.sticker-pack. --target-device iphone --target-device ipad --minimum-deployment-target 12.2 --platform iphoneos --product-type com.apple.product-type.application --compile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/Assets.xcassets/* com.apple.actool.compilation-results *//Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/assetcatalog_generated_info.plistCompileStoryboard /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/Base.lproj/Main.storyboard (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo export XCODE_DEVELOPER_USR_PATH=/Applications/Xcode.app/Contents/Developer/usr/bin/.. /Applications/Xcode.app/Contents/Developer/usr/bin/ibtool --errors --warnings --notices --module TYGameSceneDemo --output-partial-info-plist /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Base.lproj/Main-SBPartialInfo.plist --auto-activate-custom-fonts --target-device iphone --target-device ipad --minimum-deployment-target 12.2 --output-format human-readable-text --compilation-directory /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Base.lproj /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/Base.lproj/Main.storyboardCompileStoryboard /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/Base.lproj/LaunchScreen.storyboard (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo export XCODE_DEVELOPER_USR_PATH=/Applications/Xcode.app/Contents/Developer/usr/bin/.. /Applications/Xcode.app/Contents/Developer/usr/bin/ibtool --errors --warnings --notices --module TYGameSceneDemo --output-partial-info-plist /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Base.lproj/LaunchScreen-SBPartialInfo.plist --auto-activate-custom-fonts --target-device iphone --target-device ipad --minimum-deployment-target 12.2 --output-format human-readable-text --compilation-directory /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Base.lproj /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/Base.lproj/LaunchScreen.storyboardProcessInfoPlistFile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app/Info.plist /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/Info.plist (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo builtin-infoPlistUtility /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/Info.plist -producttype com.apple.product-type.application -genpkginfo /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app/PkgInfo -expandbuildsettings -format binary -platform iphoneos -additionalcontentfile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Base.lproj/LaunchScreen-SBPartialInfo.plist -additionalcontentfile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Base.lproj/Main-SBPartialInfo.plist -additionalcontentfile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/assetcatalog_generated_info.plist -requiredArchitecture arm64 -o /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app/Info.plistLinkStoryboards (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo export XCODE_DEVELOPER_USR_PATH=/Applications/Xcode.app/Contents/Developer/usr/bin/.. /Applications/Xcode.app/Contents/Developer/usr/bin/ibtool --errors --warnings --notices --module TYGameSceneDemo --target-device iphone --target-device ipad --minimum-deployment-target 12.2 --output-format human-readable-text --link /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Base.lproj/LaunchScreen.storyboardc /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Base.lproj/Main.storyboardcCodeSign /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo export CODESIGN_ALLOCATE=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/codesign_allocateSigning Identity: "iPhone Developer: sheldondev@163.com (***********)"Provisioning Profile: "iOS Team Provisioning Profile: top.sheldon.TYGameSceneDemo" (e91c7402-e02a-45ac-aff3-c73c563abcfb) /usr/bin/codesign --force --sign A4F946689397857CA5F807E9FFB76913085216E4 --entitlements /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo.app.xcent --timestamp=none /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.appValidate /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo builtin-validationUtility /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.appTouch /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app (in target: TYGameSceneDemo) cd /Users/sheldon/Documents/TYDemos/TYGameSceneDemo /usr/bin/touch -c /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app** BUILD SUCCEEDED ** 参考通过Xcode命令行编译用xcconfig文件配置iOS app环境变量官方文档]]></content>
      <categories>
        <category>hide</category>
      </categories>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java注解]]></title>
    <url>%2F2019%2F08%2F12%2Fjava%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[什么是注解注解，顾名思义，注解,就是对某一事物进行添加注释说明，会存放一些信息，这些信息可能对以后某个时段来说是很有用处的。 java中的注解Java注解又叫java标注，java提供了一套机制，使得我们可以对方法、类、参数、包、域以及变量等添加标准(即附上某些信息)。且在以后某个时段通过反射将标注的信息提取出来以供使用。 自定义注解为什么自定义注解Java从1.5版本以后默认内置三个标注： @Override:只能用在方法之上的，用来告诉别人这一个方法是改写父类的。 @Deprecated:建议别人不要使用旧的API的时候用的,编译的时候会用产生警告信息,可以设定在程序里的所有的元素上。 @SuppressWarnings:这一个类型可以来暂时把一些警告信息消息关闭。但是，仅仅这三个标注是不能满足我们开发时一些需求的。所以java允许我们自定义注解来使用。怎么自定义注解自定义步骤大致分为两步： 通过@interface关键字声明注解名称，以及注解的成员属性或者叫做注解的参数。 使用java内置的四个元注解对这个自定义标注的功能和范围进行一些限制。 元注解元注解，就是定义注解的注解，也就是说这些元注解是的作用就是专门用来约束其它注解的注解。请区别上面那三个注解，他们也是通过元注解定义而来的。元注解有哪些呢，主要有四个@Target,@Retention,@Documented,@Inherited @Target 表示该注解用于什么地方，可能的 ElemenetType 参数包括： ElemenetType.CONSTRUCTOR 构造器声明 ElemenetType.FIELD 域声明（包括 enum 实例） ElemenetType.LOCAL_VARIABLE 局部变量声明 ElemenetType.METHOD 方法声明 ElemenetType.PACKAGE 包声明 ElemenetType.PARAMETER 参数声明 ElemenetType.TYPE 类，接口（包括注解类型）或enum声明 @Retention 表示在什么级别保存该注解信息。可选的 RetentionPolicy 参数包括： RetentionPolicy.SOURCE 注解将被编译器丢弃 RetentionPolicy.CLASS 注解在class文件中可用，但会被VM丢弃 RetentionPolicy.RUNTIME VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。 @Documented 将此注解包含在 javadoc 中 @Inherited 允许子类继承父类中的注解 自定义 1234567891011import java.lang.annotation.*;@Target(ElementType.TYPE) // 这个标注用于类@Retention(RetentionPolicy.RUNTIME) //这个标注会一直保留到运行时@Documented // 将此注解包含在javadoc中public @interface TYDescription &#123; String Value();&#125; 12345678910import java.lang.annotation.*;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface TYName &#123; String originate(); String community();&#125; 使用注解12@TYName(originate = "Sheldon", community = "sheldon.com")@TYDescription(Value = "desc String!!!") 注意参考]]></content>
      <categories>
        <category>hide</category>
      </categories>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kvocontroller使用和解析]]></title>
    <url>%2F2019%2F08%2F12%2Fkvocontroller%E4%BD%BF%E7%94%A8%E5%92%8C%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[facebook/KVOController是对Cocoa中KVO的封装。它提供简单、现代的API，并且是线程安全的。优点如下： 通知是通过block、action或者NSKeyValueObserving回调（即-observeValueForKeyPath:ofObject:change:context）来实现； 不会出现移除observer的异常； 在controller销毁时隐式地移除observer； 保证了线程安全。简单地说，KVOController让我们更优雅、简单、安全地使用KVO。 使用KVOController12345678// 导入框架#import &lt;KVOController/KVOController.h&gt;@interface ViewController ()// 设置示例模型和示例按钮@property (nonatomic, strong)TestModel *model;@property (nonatomic, strong)UIButton *button;@end 12345678910111213141516171819202122//设置KVOFBKVOController *kvoController = [FBKVOController controllerWithObserver:self];self.KVOController = kvoController;//设置modelself.model = [TestModel new];self.model.name = @"hah";// 添加一个buttonself.button = [UIButton buttonWithType:UIButtonTypeSystem];self.button.frame = CGRectMake(100, 100, 100, 50);[self.button setTitle:self.model.name forState:UIControlStateNormal];[self.button addTarget:self action:@selector(buttonClick:) forControlEvents:UIControlEventTouchUpInside];[self.view addSubview:self.button];//添加监听[self.KVOController observe:self.model keyPath:FBKVOKeyPath(_model.name) options:NSKeyValueObservingOptionNew block:^(id _Nullable observer, id _Nonnull object, NSDictionary&lt;NSString *,id&gt; * _Nonnull change) &#123; NSLog(@"%@", change); NSString *title = (NSString *)change[@"new"]; [self.button setTitle:title forState:UIControlStateNormal]; &#125;]; 1234// button 点击方法- (void)buttonClick:(UIButton *)sender &#123; self.model.name = [self.model.name isEqual: @"hah"] ? @"gogo" : @"hah";&#125; 源码分析 KVOController详解 如何优雅地使用 KVO]]></content>
      <categories>
        <category>hide</category>
      </categories>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Notification与多线程]]></title>
    <url>%2F2019%2F08%2F12%2FNotification%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[原文： In a multithreaded application, notifications are always delivered in the thread in which the notification was posted, which may not be the same thread in which an observer registered itself. 翻译： 在多线程应用中，Notification在哪个线程中post，就在哪个线程中被转发，而不一定是在注册观察者的那个线程中。 举个🌰： 123456789// 主线程中add[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(observerSelect) name:@"qwer" object:nil];NSLog(@"1.current thread -- %@", [NSThread currentThread]);// 子线程中postdispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0 * NSEC_PER_SEC)), dispatch_get_global_queue(0, 0), ^&#123; NSLog(@"3.current thread -- %@", [NSThread currentThread]); [[NSNotificationCenter defaultCenter] postNotificationName:@"qwer" object:nil];&#125;); 123- (void)observerSelect &#123; NSLog(@"2.current thread -- %@", [NSThread currentThread]);&#125; 打印结果：1232019-03-26 11:24:29.987543+0800 timerTest[46207:2785353] 1.current thread -- &lt;NSThread: 0x600002814d00&gt;&#123;number = 1, name = main&#125;2019-03-26 11:24:33.270912+0800 timerTest[46207:2785409] 3.current thread -- &lt;NSThread: 0x60000284e880&gt;&#123;number = 3, name = (null)&#125;2019-03-26 11:24:33.271095+0800 timerTest[46207:2785409] 2.current thread -- &lt;NSThread: 0x60000284e880&gt;&#123;number = 3, name = (null)&#125; 虽然我们在主线程中注册了通知者，但在全局队列中post，并不是在主线程中处理的，所以，我们在处理回调结果时，一定要注意线程问题。 那么，我们如何能在子线程中post，在主线程中进行处理呢？ 看看官方文档： For example, if an object running in a background thread is listening for notifications from the user interface, such as a window closing, you would like to receive the notifications in the background thread instead of the main thread. In these cases, you must capture the notifications as they are delivered on the default thread and redirect them to the appropriate thread. 翻译： 例如，如果在后台线程中运行的对象正在侦听来自用户界面的通知（例如关闭窗口），则您希望在后台线程而不是主线程中接收通知。在这些情况下，您必须捕获在默认线程上传递的通知，并将它们重定向到相应的线程。 根据官方文档修改我们上面的例子： 123456@interface ViewController () &lt;NSMachPortDelegate&gt;@property (nonatomic) NSMutableArray *notifications; // 通知队列@property (nonatomic) NSThread *notificationThread; // 期望线程@property (nonatomic) NSLock *notificationLock; // 用于对通知队列加锁的锁对象，避免线程冲突@property (nonatomic) NSMachPort *notificationPort; // 用于向期望线程发送信号的通信端口@end 123456789101112131415161718192021// 初始化self.notifications = [[NSMutableArray alloc] init];self.notificationLock = [[NSLock alloc] init]; self.notificationThread = [NSThread currentThread];self.notificationPort = [[NSMachPort alloc] init];self.notificationPort.delegate = self; // 往当前线程的run loop添加端口源// 当Mach消息到达而接收线程的run loop没有运行时，则内核会保存这条消息，直到下一次进入run loop[[NSRunLoop currentRunLoop] addPort:self.notificationPort forMode:(__bridge NSString *)kCFRunLoopCommonModes]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(observerSelectNotification:) name:@"qwer" object:nil];NSLog(@"1.current thread -- %@", [NSThread currentThread]); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0 * NSEC_PER_SEC)), dispatch_get_global_queue(0, 0), ^&#123; NSLog(@"3.current thread -- %@", [NSThread currentThread]); [[NSNotificationCenter defaultCenter] postNotificationName:@"qwer" object:nil];&#125;); 1234567891011121314151617// Delegates are sent this if they respond, otherwise they// are sent handlePortMessage:; argument is the raw Mach message- (void)handleMachMessage:(void *)msg&#123; [self.notificationLock lock]; NSLog(@"5.current thread -- %@", [NSThread currentThread]); while ([self.notifications count]) &#123; NSNotification *notification = [self.notifications objectAtIndex:0]; [self.notifications removeObjectAtIndex:0]; [self.notificationLock unlock]; [self observerSelectNotification:notification]; [self.notificationLock lock]; &#125;; [self.notificationLock unlock];&#125; 123456789101112131415161718- (void)observerSelectNotification:(NSNotification *)notification &#123; if ([NSThread currentThread] != _notificationThread) &#123; NSLog(@"4.current thread -- %@", [NSThread currentThread]); // Forward the notification to the correct thread. [self.notificationLock lock]; [self.notifications addObject:notification]; [self.notificationLock unlock]; [self.notificationPort sendBeforeDate:[NSDate date] components:nil from:nil reserved:0]; &#125; else &#123; NSLog(@"2.current thread -- %@", [NSThread currentThread]); NSLog(@"process notification"); &#125;&#125; 运行结果：1234562019-03-26 11:58:30.826178+0800 timerTest[47621:2830678] 1.current thread -- &lt;NSThread: 0x6000023c93c0&gt;&#123;number = 1, name = main&#125;2019-03-26 11:58:33.826488+0800 timerTest[47621:2830764] 3.current thread -- &lt;NSThread: 0x600002388740&gt;&#123;number = 3, name = (null)&#125;2019-03-26 11:58:33.826702+0800 timerTest[47621:2830764] 4.current thread -- &lt;NSThread: 0x600002388740&gt;&#123;number = 3, name = (null)&#125;2019-03-26 11:58:33.826899+0800 timerTest[47621:2830678] 5.current thread -- &lt;NSThread: 0x6000023c93c0&gt;&#123;number = 1, name = main&#125;2019-03-26 11:58:33.827061+0800 timerTest[47621:2830678] 2.current thread -- &lt;NSThread: 0x6000023c93c0&gt;&#123;number = 1, name = main&#125;2019-03-26 11:58:33.827151+0800 timerTest[47621:2830678] process notification 可以看到，我们在全局dispatch队列中抛出的Notification，如愿地在主线程中接收到了。 这种实现方式的具体解析及其局限性大家可以参考官方文档Delivering Notifications To Particular Threads，在此不多做解释。当然，更好的方法可能是我们自己去子类化一个NSNotificationCenter，或者单独写一个类来处理这种转发。 参考： Notification Programming Topics Threading Programming Guide Notification与多线程]]></content>
      <categories>
        <category>hide</category>
      </categories>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下配置多个ssh-key]]></title>
    <url>%2F2019%2F08%2F12%2FMac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAssh-key%2F</url>
    <content type="text"><![CDATA[在我们的工作经常会遇到公司的git仓库需要配置SSH-Key，而自己的github也需要配置SSH-Key，如果你不想使用同一个SSH-Key，那么可以生成多个SSH-Key，从而分别配置不同的仓库。 打开终端，查看当前~/.ssh路径中存在的SSH-Key： 我的路径下已经存在了一个SSH-Key了，那么接下来再创建一个SSH-Key: 使用命令创建：1ssh-keygen -t rsa -C "这里填写你的邮箱地址" 在Enter file in which to save the key (&lt;文件路径&gt;):这里输入自定义的SSH-Key名称（必须写，不然会默认覆盖原来的Key） 例如：1Enter file in which to save the key (&lt;文件路径&gt;): id_rsa_github 然后输入密码（密码不可见）：12Enter passphrase (empty for no passphrase):Enter same passphrase again: 当看到这样的字样，说明创建成功了： 将SSH-Key添加到ssh-agent中：1ssh-add id_rsa_github 输入密码:1Enter passphrase for id_rsa_github: 添加成功：1Identity added: id_rsa_github (&lt;邮箱地址&gt;) 查看公钥：1cat id_rsa_github.pub 将公钥配置到github的ssh-key中；最后验证是否联通：1ssh -T git@github.com 成功字样：1Hi &lt;这里是github的用户名&gt;! You've successfully authenticated, but GitHub does not provide shell access.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jenkins 打包流程]]></title>
    <url>%2F2019%2F08%2F12%2Fjenkins%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[安装jenkins我们使用Homebrew安装jenkins 安装Homebrew 首先确认机器有没有安装Homebrew 1brew -v 如果未安装，则安装Homebrew 1$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装java环境 1brew install Caskroom/cask/java 由于现在的java最高版本为12.0，jenkins不支持，所以我们安装一个第三方的java 1brew cask install homebrew/cask-versions/adoptopenjdk8 安装jenkins 1brew install jenkins 链接文件 1ln -sfv /usr/local/opt/jenkins/*.plist ~/Library/LaunchAgents 启动jenkins 1launchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist]]></content>
      <categories>
        <category>hide</category>
      </categories>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人简历]]></title>
    <url>%2F2019%2F03%2F28%2FcurriculumVitae%2F</url>
    <content type="text"><![CDATA[个人信息 table th:nth-of-type(1) { width: 20%; } 姓名 / 性别 田宇 / 男 专业 网络工程 毕业院校 中北大学信息商务学院 E-mail tinarychina@gmail.com / ty24089@163.com 电话/微信 17722529692 工作年限 5年 技术博客 https://sheldon.top 求职意向 iOS开发工程师 现居/期望城市 北京市 工作经历深圳市闪拍精灵网络技术有限公司（2016.05-2018.12） 负责客户端核心功能的开发和维护以及产品的迭代开发和优化，编写相关开发文档，参与需求评审和接口评审并讨论相关问题，在客户端组分配开发任务以及控制开发进度；在开发过程中协调API后台、移动端、web的工作。 作品：90秒、Ai优惠、快淘优品、惠拍优品、闪电拍卖项目内容： 项目架构以MVC为主，部分项目使用MVVM，统一后台接口规范 RESTful 风格。 项目以Objective-C语言为主，部分页面使用Swift编写。 部分项目使用响应式框架，主要是为了解决数据变化引起的页面布局和结构的改变。 项目使用自定义埋点（90秒使用GrowingIO无埋点框架）,运用分类为按钮添加action监听，添加编码属性。 使用GCD和自定义NSOpration处理数据内容，接口调用等。 使用Runtime实现通过CMS配置相关内容，控制页面跳转不同页面。 自定义DispatchTimer并管理Timer组，实现使用CACurrentMediaTime()计算倒计时数据，抛弃控制器做计算的过程，减轻控制器负担。 封装TableView，减少控制器中相关代码量。 使用CABasicAnimation实现相关页面动画效果。 北京圣合软件科技有限公司（2015.03-2016.02） 负责客户端相关功能的开发和迭代维护，配合其他相关部门提供相应的产品技术支持。 作品：留留学项目内容：项目严格遵循MVC设计框架模式开发,降低耦合度；多处使用GCD多线程技术；使用Block回调机制进行多页面之间传值；在应用内部使用系统提供的内置浏览器控件，加载网页数据；集成了第三方SDK环信即时聊天系统，使用户之间可以实时聊天并使用苹果公司的APNS服务，实时的推送消息到用户；集成第三方分享平台，将链接分享至第三方社交应用等。 世界邦信息技术有限公司（2013.07-2015.02） 负责公司iPhone手机客户端的的开发和维护，协助高级开发人员完成项目的开发和迭代。 作品：行程大师、全球地铁图项目内容：通过自定义UI控件与控件之间的搭配使用，使App界面丰富多彩，方便用户使用和交互；使用RunLoop中的commonModes实现拖动页面和scrollView滚动之间互不干扰；混合开发，在应用内部使用系统提供的内置浏览器控件，加载网页数据，达到更快捷的开发App并且方便于维护；使用苹果公司的APNS服务，实时的推送消息到用户等。 技能列表 精通Objective-C语言，熟练掌握iOS平台各类API，熟悉iOS内存管理机制，熟悉iOS多线程。 熟悉Swift语言及其特性以及SDK等。 能熟练的运用AFNetworking、SDWebImage、Masonry、Reactivecocoa等开源项目。 能熟练使用纯代码或者Storyboard，xib进行开发。 能熟练的使用Instruments下的性能调试工具进行性能优化。 熟悉网络数据(JSON/XML)的请求以及解析并转化模型，Charles网络数据抓包分析。 熟练使用Git、SVN等代码管理工具。 熟悉MVC、MVVM、委托代理、通知观察等开发模式。 熟悉TCP/UDP/HTTP/HTTPS/XMPP等协议。 熟悉腾讯Bugly的Crash错误分析，熟悉GrowingIO无埋点技术等。 熟悉持续集成Jenkins,fastlane等工具。 熟悉iOS数据持久化，NSUserDefaults、NSKeyedArchiver、SQLite3、 CoreData等。 熟悉后台接口规范以及各种调试工具。 了解React Native、Weex、Flutter等跨平台开发技术。 兴趣爱好 搭建过VPN，目前使用的为自己在Google Cloud Platform搭建的CentOS7服务器。 使用Python编写一些抓取图片的小脚本。 搭建过持续集成jenkins+fir+钉钉机器人通知等持续集成工具，可以自动打包、上传并通知测试人员。 个人喜欢各种球类运动和唱歌。 自我评价 责任心强，性格外向，人际沟通能力良好，有协调团队工作的能力，喜欢拥抱新技术。 工作认真负责，认真对待每一件事情，每一个技术点，反馈及时，能做到尽早暴露风险以及问题 工作经验丰富，开发快速，有良好的编程能力和习惯，喜欢规范化代码以及积极优化代码。 作品链接 90秒、Ai优惠、快淘优品、惠拍优品、闪电拍卖 社交主页 个人博客：Sheldon’s blog GitHub：Sheldon 简书：搁浅的青蛙]]></content>
      <categories>
        <category>hide</category>
      </categories>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详细解析HTTP和HTTPS]]></title>
    <url>%2F2019%2F03%2F04%2F%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90HTTP%E5%92%8CHTTPS%2F</url>
    <content type="text"><![CDATA[HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。为了解决HTTP协议的这一缺陷，需要使用另一种协议：HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 HTTP和HTTPS的基本概念HTTP（HyperText Transfer Protocol：超文本传输协议）：是互联网上应用最为广泛的一种协议，用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 http:// 打头的都是标准 HTTP 服务。 HTTPS（Hypertext Transfer Protocol Secure：超文本传输安全协议）：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式： TCP 三次同步握手 客户端验证服务器数字证书 DH 算法协商对称加密算法的密钥、hash 算法的密钥 SSL 安全加密隧道协商完成 网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。 HTTPS协议的主要作用有两种： 建立一个信息安全通道，来保证数据传输的安全 确认网站的真实性 HTTP与HTTPS有什么区别 HTTP协议是明文传输，因此HTTP协议非常不安全；HTTPS（SSL+HTTP）数据传输过程是加密的，安全性较好。 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。 HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。 http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。 HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。 TCP 三次握手 第一次握手：客户端尝试连接服务器，向服务器发送 syn 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认 第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个 SYN包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态 第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手 HTTPS的工作原理 客户端发起HTTPS请求用户在浏览器里输入一个 https 网址，然后连接到 server 的 443 端口。 服务端配置采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl 就是个不错的选择，有 1 年的免费服务)。这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。 传送证书这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。 客户端解析证书这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。 传送加密信息这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 服务端解密信息服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 传输加密后的信息这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。 客户端解密信息客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git服务器的搭建]]></title>
    <url>%2F2019%2F01%2F22%2FGit%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。搭建Git服务器需要准备一台运行Linux的机器，这样，通过几条简单的apt命令就可以完成安装。 第一步，安装Git1$ sudo apt-get install git 第二步，创建一个git用户，用来运行git服务：1$ sudo adduser git 第三步，创建证书登录：收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。 第四步，初始化Git仓库：先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令：1$ sudo git init --bare sample.git Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：1$ sudo chown -R git:git sample.git 第五步，禁用shell登录：出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行：1git:x:1001:1001:,,,:/home/git:/bin/bash 改为：1git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。 第六步，克隆远程仓库：现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行：123$ git clone git@server:/srv/sample.gitCloning into &apos;sample&apos;...warning: You appear to have cloned an empty repository.]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3-Mac安装Python3]]></title>
    <url>%2F2019%2F01%2F21%2Fpython3-Mac%E5%AE%89%E8%A3%85Python3%2F</url>
    <content type="text"><![CDATA[因为Python是跨平台的，它可以运行在Windows、Mac和各种Linux/Unix系统上。在Windows上写Python程序，放到Linux上也是能够运行的。要开始学习Python编程，首先就得把Python安装到你的电脑里。安装后，你会得到Python解释器（就是负责运行Python程序的），一个命令行交互环境，还有一个简单的集成开发环境。 安装Python3系统自带的Python版本是2.7。要安装最新的Python 3.7，有两个方法： 方法一：从Python官网下载Python 3.7的安装程序（网速慢的同学请移步国内镜像），双击运行并安装； 方法二：如果安装了Homebrew，直接通过命令brew install python3安装即可。 直接运行.py文件在文件开头添加：1#!/usr/bin/env python3 然后通过命令给文件权限：1chmod a+x hello.py 就可以通过命令./hello.py直接运行.py文件了。]]></content>
      <categories>
        <category>后台</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7+Python3+Django]]></title>
    <url>%2F2019%2F01%2F21%2FCentOS7-Python3-Django%2F</url>
    <content type="text"><![CDATA[CentOS 7中布置Python3和DjangoCentos7中默认安装了python2.7.5，因为一些命令要用它，比如：yum；它使用的是python2.7.5。当我们在命令行里输入 1python -V 就可以看到版本为2.7.5。 安装各种依赖包： 12yum -y groupinstall "Development tools"yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel gcc automake autoconf libtool make wget 安装python3因为我们要安装python3版本，所以python要指向python3才行，目前还没有安装python3，先备份，备份之前先安装相关包，用于下载编译python3 1yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make 这几个包必须得安装，否则安装python3时可能会出现各种错误。运行下面两个命令，进行备份 12cd /usr/binmv python python.bak 下载python3.6.3 1wget https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tar.xz 解压 1tar -xvJf Python-3.6.3.tar.xz 进入解压好的python3.6.3文件夹 1cd Python-3.6.3 编译安装 123./configure prefix=/usr/local/python3makemake install 安装完毕，/usr/local/目录下就会有python3了。 实现Python3和Python2的共存添加Python3的软链 1ln -s /usr/local/python3/bin/python3 /usr/bin/python 这个时候在执行命令python -V和python2 -V，就能看到python3和python2的版本了。 添加pip3的软链 1ln -s /usr/local/python3/bin/pip3 /usr/bin/pip 因为执行yum需要Python2的版本，所以我们还有修改yum的配置，执行： 1vi /usr/bin/yum 把第一行#! /usr/bin/python修改为#! /usr/bin/python2 同理 1vi /usr/libexec/urlgrabber-ext-down 文件里面的#! /usr/bin/python也要修改为#! /usr/bin/python2 安装Django项目中需要的python相关包安装python相关包需要用到python中的pip命令 12345678910pip install Djangopip install PyMySQLpip install Scrapypip install beautifulsoup4pip install bs4pip install lxmlpip install numpypip install requestspip install simplejsonpip install urllib3 此时，python所需要的包已经都安装好了。 安装MySQL下载MySQL源安装包 1wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm 安装MySQL源 12yum localinstall mysql57-community-release-el7-8.noarch.rpmyum install mysql-devel 安装MySQL 1yum install mysql-community-server 启动MySQL服务 1systemctl start mysqld 查看MySQL状态 1systemctl status mysqld 开机启动 1systemctl enable mysqld 修改root本地登录密码 123grep 'temporary password' /var/log/mysqld.logmysql -uroot -pset password for 'root'@'localhost'=password('!2Qw32sd'); 注意：mysql5.7默认安装了密码安全检查插件（validate_password），默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于8位。否则会提示ERROR 1819 (HY000): Your password does not satisfy the current policy requirements错误 配置默认编码为utf8 修改/etc/my.cnf配置文件，在[mysqld]下添加编码配置，如下所示： 123[mysqld]character_set_server=utf8init_connect='SET NAMES utf8' 导入django和mysql数据库导入django项目由于我项目放在码云上面，然后CentOS又自带git，我的数据库文件也比较小，所以也放在django项目中了，用git下载下来: 1234sudo su rootmkdir projectcd projectgit clone https://gitee.com/dafeige/django-restframework-demo.git 此时，我的数据库文件路径是：project/django-restframework-demo/tutorial/test_python.sql，由于需要将此sql文件导入到mysql数据中，需要给此文件加权限: 1chmod 777 project/django-restframework-demo/tutorial/test_python.sql 导入sql数据库文件进入数据库 1mysql -u root -p 导入sql文件 123create database test_python;use test_python;source project/django-restframework-demo/tutorial/test_python.sql; 部署django工程进入到工程中 123sudo su rootcd project/django-restframework-demo/tutorialpython manage.py runserver 0.0.0.0:80 &amp; 最后面的”&amp;”，这符号表示在后台运行该进程。这里的IP地址如果用公网IP 会运行不了，而用0.0.0.0则外网和127.0.0.1都能够访问。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Python3</tag>
        <tag>Django</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git标签管理]]></title>
    <url>%2F2019%2F01%2F21%2FGit%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。 创建标签在Git中打标签非常简单，首先，切换到需要打标签的分支上：12345$ git branch* dev master$ git checkout masterSwitched to branch &apos;master&apos; 然后，敲命令git tag &lt;name&gt;就可以打一个新标签：1$ git tag v1.0 可以用命令git tag查看所有标签：12$ git tagv1.0 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？ 方法是找到历史提交的commit id，然后打上就可以了：12345678910111213141516$ git log --pretty=oneline --abbrev-commit12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 1014c805e2 fix bug 101e1e9c68 merge with no-fff52c633 add mergecf810e4 conflict fixed5dc6824 &amp; simple14096d0 AND simpleb17d20e branch testd46f35e remove test.txtb84166e add test.txt519219b git tracks changese43a48b understand how stage works1094adb append GPLe475afc add distributedeaadf4e wrote a readme file 比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令：1$ git tag v0.9 f52c633 命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息； 命令git tag可以查看所有标签。 命令git push origin &lt;tagname&gt;可以推送一个本地标签； 命令git push origin --tags可以推送全部未推送过的本地标签； 命令git tag -d &lt;tagname&gt;可以删除一个本地标签； 命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git分支管理]]></title>
    <url>%2F2019%2F01%2F21%2FGit%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！ 创建于合并分支查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; ##解决冲突当两个分支同时做了修改，这个时候合并分支会出现冲突。 可以查看冲突文件 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容 修改后再提交，用git log --graph --pretty=oneline --abbrev-commit命令查看分支的合并情况。 分支管理策略通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。1git merge --no-ff -m &quot;merge with no-ff&quot; dev --no-ff参数，表示禁用Fast forward。 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 合并后，我们用git log查看分支历史。 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： bug分支如果当前你正在进行开发工作，这个时候需要fix一个bug，那么可以使用git stash命令先把当前的工作现场保存。 然后切换到需要修复bug的分支，创建临时分支。 修复完毕后，将临时分支合并到需要修复的bug分支，完成bug的修复。 用git stash list命令查看保存的工作现场。 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了。 多人协作要查看远程库的信息，用git remote或者，用git remote -v显示更详细的信息 推送分支推送主分支1$ git push origin master 推送其他分支，比如dev，就改成：1$ git push origin dev 抓取分支使用git clone将远程仓库克隆到本地，使用git branch查看分支，会发现只有master分支12$ git branch* master 如果要在dev分支上开发，就必须创建远程origin的dev分支到本地，用这个命令创建本地dev分支：1$ git checkout -b dev origin/dev 如果你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，推送的时候也许会发生冲突。 先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送。 如果git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：12$ git branch --set-upstream-to=origin/dev devBranch &apos;dev&apos; set up to track remote branch &apos;dev&apos; from &apos;origin&apos;. 多人协作的工作模式通常是这样： 首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 rebaserebase操作可以把本地未push的分叉提交历史整理成直线； rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基础]]></title>
    <url>%2F2019%2F01%2F21%2FGit%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Git是什么？Git是目前世界上最先进的分布式版本控制系统（没有之一）。 在Mac上安装Git在Mac上安装Git有两种方法： 第一种：先安装Homebrew，然后通过homebrew来安装Git，详情可以参考homebrew的文档。 第二种：直接安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。 创建版本库什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：1234$ mkdir MyGitPost$ cd MyGitPost$ pwd/Users/username/Documents/MyGitPost 第二步，通过git init命令b把这个m目录变成Git可管理的仓库。12$ git initInitialized empty Git repository in /Users/username/Documents/MyGitPost/.git/ 把文件添加到版本库首先，我们创建一个用于测试的文件1$ touch readme.txt 然后，打开reademe.txt文件进行编辑1$ vi readme.txt 内容如下：1这是一个用于测试Git的文档。 然后通过两步来将文件提交到Git仓库：第一步：用命令git add告诉Git，把文件添加到仓库1$ git add readme.txt 执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。 第二步，用命令git commit告诉Git，把文件提交到仓库：1234$ git commit -m &quot;wrote a readme file&quot;[master (root-commit) 2f26a28] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt -m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。 版本管理现在，我们修改readme.txt的内容：1这是修改的内容 运行git status来看看修改后的结果：123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) git status命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。 使用git diff来查看12345678diff --git a/readme.txt b/readme.txtindex 46d49bf..75de425 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@这是一个用于测试Git的文档。+这是修改的内容(END) 然后就是通过git add和git commit的命令提交修改内容，在执行git commit之前可以使用git status再次查看d当前仓库的状态。 版本回退在我们多次修改文件，每次commit都会生成一个快照，如果你对文件进行了不正当的操作，或者误删了内容，可以从最近的快照中恢复。 使用git log来查看每次commit的快照。123456789101112$ git logcommit 707183727c57ee8fb68199521a9b014e088af091 (HEAD -&gt; master)Author: Sheldon &lt;ty24089@163.com&gt;Date: Sat Jan 19 12:38:28 2019 +0800 修改readme文件内容commit 2f26a2852751767536b17a2f748c2081847c3578Author: Sheldon &lt;ty24089@163.com&gt;Date: Sat Jan 19 12:04:45 2019 +0800 wrote a readme file 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数：123$ git log --pretty=oneline707183727c57ee8fb68199521a9b014e088af091 (HEAD -&gt; master) 修改readme文件内容2f26a2852751767536b17a2f748c2081847c3578 wrote a readme file 使用git reset来回退到上一个版本。12$ git reset --hard HEAD^HEAD is now at 2f26a28 wrote a readme file 如果想恢复的新的内容，使用git reflog查看每一次命令的记录，然后在通过git reset --hard commit_id命令来恢复想要的快照。 工作区和暂存区工作区就是可以看的到的目录，比如在上边创建的MyGitPost文件夹就是工作区。 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 撤销修改如果在修改了文件，但还没有git add，这个时候，你不想要这个文件的修改了，想恢复未修改前的内容，那么可以使用git checkout -- file命令丢弃工作区的修改。这里有两种情况： 一种是文件自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是文件已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 如果在修改了文件，并且提交到了暂存区，那么可以用命令git reset HEAD &lt;file&gt;可以把暂存区的修改撤销掉（unstage），重新放回工作区。 git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 再用git status查看一下，现在暂存区是干净的，工作区有修改。 使用git checkout -- file就可以恢复工作区的修改。 删除文件命令git rm用于删除一个文件。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+next详细配置]]></title>
    <url>%2F2019%2F01%2F21%2Fhexo-next%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[hexo安装好后，默认的主题是landscape，如果不喜欢，我们也可以进行更换。本文主要配置Next(GitHub，官方文档)主题。 Next安装与启用主题安装Next切换到Blog主目录文件夹下 通过git安装 12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 _config.yml(站点配置文件)， 找到 theme 字段，并将其值更改为 next。 验证主题首先启动 Hexo 本地站点，并开启调试模式（即加上 –debug），整个命令是 hexo s --debug。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：1INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 设置主题目前 NexT 支持四种 Scheme，他们是：12345# Schemes# scheme: Muse# scheme: Mist# scheme: Pisces# scheme: Gemini Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Gemini - 双栏 Scheme，比Pisces略大 Scheme 的切换通过更改主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 去除即可。 设置菜单123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive # schedule: /schedule/ || calendar # sitemap: /sitemap.xml || sitemap # commonweal: /404/ || heartbeat 键值 设定值 显示文本 home home: / 主页 archives archives: /archives 归档页 categories categories: /categories 分类页（需要手动创建页面） tags tags: /tags 标签页（需要手动创建页面） about about: /about 关于页面（需要手动创建页面） commonweal commonweal: /404.html 公益 404（需要手动创建页面） 设置侧栏修改 `主题配置文件 中的 sidebar 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。 设置侧栏的位置，修改 sidebar.position 的值，支持的选项有： left - 靠左放置 right - 靠右放置12sidebar: position: left 设置侧栏显示的时机，修改 sidebar.display 的值，支持的选项有： post - 默认行为，在文章页面（拥有目录列表）时显示 always - 在所有页面中都显示 hide - 在所有页面中都隐藏（可以手动展开） remove - 完全移除12sidebar: display: post 设置动态背景主题配置文件中找到canvas_nest，设置成ture就OK啦。12# Canvas-nestcanvas_nest: ture 在右上角或者左上角实现fork me on github在GitHub Ribbons或GitHub Corners选择一款你喜欢的挂饰，拷贝方框内的代码 将刚刚复制的挂饰代码，添加到Blog/themes/next/layout/_layout.swig文件中，添加到&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下方。 设置RSSNexT 中 RSS 有三个设置选项，满足特定的使用场景。 更改 主题配置文件，设定 rss 字段的值： false：禁用 RSS，不在页面上显示 RSS 连接。 留空：使用 Hexo 生成的 Feed 链接。 你可以需要先安装 hexo-generator-feed 插件。 具体的链接地址：适用于已经烧制过 Feed 的情形。 修改文章内链接文本样式修改Blog/themes/next/source/css/_common/components/post/post.styl，在末尾添加CSS样式： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; //原始链接颜色 border-bottom: none; border-bottom: 1px solid #0593d3; //底部分割线颜色 &amp;:hover &#123; color: #fc6423; //鼠标经过颜色 border-bottom: none; border-bottom: 1px solid #fc6423; //底部分割线颜色 &#125;&#125; 修改底部标签样式修改Blog\themes\next\layout\_macro\post.swig中文件，command+f搜索rel=&quot;tag&quot;&gt;#，将#替换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;。 在文章末尾添加“文章结束”标记 在路径Blog\themes\next\layout\_macro文件夹中新建passage-end-tag.swig文件。 在passage-end-tag.swig添加以下内容，直接用文本编辑器打开，粘贴以下内容后保存 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------感谢您的阅读&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 打开Blog\themes\next\layout\_macro\post.swig，在post-body之后，post-footer之前（post-footer之前两个DIV），添加以下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 具体添加位置：12345678910111213141516171819&lt;div&gt;&#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125;&#123;% endif %&#125;&lt;/div&gt;&#123;% if (theme.alipay or theme.wechatpay or theme.bitcoin) and not is_index %&#125; &lt;div&gt; &#123;% include &apos;reward.swig&apos; %&#125; &lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.post_copyright.enable and not is_index %&#125; &lt;div&gt; &#123;% include &apos;post-copyright.swig&apos; with &#123; post: post &#125; %&#125; &lt;/div&gt;&#123;% endif %&#125;&lt;footer class=&quot;post-footer&quot;&gt; 修改主题配置文件_config.yml，在末尾添加： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 显示效果： 修改作者头像并旋转打开\themes\next\source\css\_common\components\sidebar\sidebar-author.styl，在里面添加如下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 主页文章添加阴影效果效果图： 具体实现方法： 打开\themes\next\source\css\_custom\custom.styl,向里面加入：12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 设置网站的图标Favicon在easyicon或者阿里巴巴矢量图标库找一张你喜欢的图标（大：32x32 小：16x16），将下载下来的小图和中图放在Blog/themes/next/source/images，将默认的两张图片替换掉。命名和默认的一样也可以自己定义： 底部隐藏由Hexo强力驱动、主题–NexT.Mist打开Blog/themes/next/layout/_partials/footer.swig，注释掉相应代码。12345678910111213141516171819202122232425262728293031//用下面的符号注释，注释代码用下面括号括起来&lt;!-- --&gt;&lt;!--&lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% if theme.footer.powered %&#125; &lt;div class=&quot;powered-by&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.footer.powered and theme.footer.theme.enable %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125;&#123;% if theme.footer.theme.enable %&#125; &lt;div class=&quot;theme-info&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.theme&apos;) &#125;&#125; &amp;mdash; &#123;# #&#125;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;&#123;# #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;# #&#125;&lt;/a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; theme.version &#125;&#125;&#123;% endif %&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.footer.custom_text %&#125; &lt;div class=&quot;footer-custom&quot;&gt;&#123;# #&#125;&#123;&#123; theme.footer.custom_text &#125;&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;--&gt; 添加侧栏推荐阅读编辑主题配置文件，如下配置即可：12345678# Blog rollslinks_icon: linklinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: Swift 4: https://developer.apple.com/swift/ Objective-C: https://developer.apple.com/documentation/objectivec Hexo博客添加站内搜索 NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia。下面介绍Local Search的安装吧。 切换到根目录 安装 hexo-generator-search1npm install hexo-generator-search --save 安装 hexo-generator-searchdb1npm install hexo-generator-searchdb --save 编辑站点配置文件，添加以下内容：12345search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件，设置Local searchenable为ture123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: ture # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 参考文章 hexo的next主题个性化教程:打造炫酷网站 Hexo-NexT配置超炫网页效果]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人ss-ssr服务器]]></title>
    <url>%2F2017%2F10%2F01%2F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAss-ssr%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[获取SSR客户端 Windows客户端地址 download 备用地址 Mac客户端地址 download 备用地址 Linux客户端一键安装配置 使用脚本 (使用方法见注释) 或者采用图形界面的linux ssr客户端 安卓 SSR客户端 下载地址 备用下载地址 开始搭建 搭建步骤分为三步：1.购买VPS服务器2.一键部署VPS服务器3.一键加速VPS服务器 （谷歌BBR加速，推荐） 第一步：购买VPS服务器VPS服务器需要选择国外的，首选国际知名的vultr，速度不错、稳定且性价比高。 vultr注册地址： http://www.vultr.com/?ref=7048874 （全球15个服务器位置可选，KVM框架） 12345678910价格:2.5美元/月的服务器配置信息：单核 512M内存 20G SSD硬盘 100M带宽 500G流量/月5美元/月的服务器配置信息：单核 1G内存 25G SSD硬盘 100M带宽 1000G流量/月10美元/月的服务器配置信息：单核 2G内存 40G SSD硬盘 100M带宽 2000G流量/月20美元/月的服务器配置信息：2cpu 4G内存 60G SSD硬盘 100M带宽 3000G流量/月40美元/月的服务器配置信息：4cpu 8G内存 100G SSD硬盘 100M带宽 4000G流量/月 vultr实际上是折算成小时来计费的，比如服务器是5美元1个月，那么每小时收费为5/30/24=0.0069美元 会自动从账号中扣费，只要保证账号有钱即可。如果你部署的服务器实测后不理想，你可以把它删掉（destroy），重新换个地区的服务器来部署，很方便。 计费从你开通服务器开始算的，不管你有没有使用，即使服务器处于关机状态仍然会计费，如果你没有开通服务器就不算。比如你今天早上开通了服务器，但你有事情，晚上才部署，那么这段时间是会计费的。同理，如果你早上删掉服务器，第二天才开通新的服务器，那么这段时间是不会计费的。 温馨提醒：同样的服务器位置，不同的宽带类型和地区所搭建的账号的翻墙速度会不同，所以最好亲测一下。 购买vps服务器时，服务器地址优先选择：美国硅谷（Silicon Valley）、美国达拉斯(Dallas)等，近期不推荐用洛杉矶和日本的服务器，因为这两个地区近期能够开到的好ip的可能性很低。推荐选择CentOS 6.X64位的系统（系统版本不要选的太高，不要选centos7！centos7默认的防火墙可能会干扰ssr的正常连接！）。完成购买后，找到系统的密码记下来，部署服务器时需要用到。如图： 默认是centos7系统，点击图中的CentOS几个字，会弹出centos6，然后选中它！vps操作系统不要选cento7，因为选它很可能会影响ssr的正常连接。 第二步：远程连接VPS服务器Mac连接远程服务器: 打开terminal,输入ssh root@ip地址;root为远程服务器的username,ip地址为远程服务器的ip. 联通后,提示输入密码,然后输入服务器的密码. 开始部署ssr代码 Windows连接远程服务器:购买服务器后，需要部署一下。因为你买的是虚拟东西，而且又远在国外，我们需要一个叫Xshell的软件来远程部署。Xshell windows版下载地址： 巴别鸟云盘下载 提取密码：38693 国外云盘下载 百度软件中心 下载xshell软件并安装后，打开软件 选择文件，新建 随便取个名字，然后把你的服务器ip填上 连接国外ip即服务器时，软件会先后提醒你输入用户名和密码，用户名linux系统默认都是root，密码是购买服务器后的cent系统的密码。 如果开好了服务器，发现xshell死活连不上，多半是开的服务器ip被墙了，遇到这种情况，把服务器删掉，重新开个新的服务器即可，可以是同地区的也可以选择其它地区。 连接成功后，会出现如上图所示，之后就可以复制粘贴代码部署了。 分享两个好用的代码，选择其中一个即可。建议两个脚本先大致都看一下功能,然后再选择。 第三步: 部署ssr代码第1种方式:1234567yum -y install wgetwget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod +x shadowsocksR.sh./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log 上面的代码总共有4行（显示5行），复制时要一起复制下来，以下脚本类似。如果要卸载直接输入命令：./shadowsocks-go.sh uninstall 演示开始：复制代码粘贴到vps服务器里，按回车键，进入部署。 按照如下提示，输入想设置的密码，按回车键进入下一步 (密码建议用字母，图中的密码只是作为演示用)按照如下提示，输入想设置的端口（3～4位即可），按回车键进入下一步按照如下提示，选择想设置的加密方式，括号里面是默认的加密方式，想设置默认的话直接按回车键。这里选择数字2（和默认一样）的aes-256-cfb的加密方式按照如下提示，选择项设置的协议插件，默然的是origin（支持SS客户端，不推荐），我们选择SSR客户端的协议插件：3按照如下提示，选择项设置的混淆插件，默然的是plain（支持SS客户端，不推荐），我们选择SSR客户端的混淆插件：6按照如下提示，按任意键进行自动部署 上图表示部署成功。从上往下依次为SSR帐号的IP、端口、密码、协议插件、混淆插件和加密方式。 最后可以重启服务器确保部署生效。重启需要在命令栏里输入reboot ，输入命令后稍微等待一会服务器就会自动重启，一般重启过程需要2～5分钟，重启过程中Xshell会自动断开连接，等VPS重启好后才可以用Xshell软件进行连接。如果部署过程中卡在某个位置超过10分钟，可以用xshell软件断开，然后重新连接你的ip，再复制代码进行部署。 这个脚本的图文演示就结束了，图中的IP仅作演示用，教程发布后会失效。有人想了，我以后有想修改密码或者端口的需求怎么办？这个脚本修改密码和端口不是很方便，需要把最初的部署代码重新输入一遍，即从头到尾部署一遍即可。 下面再分享第二个脚本，这个脚本装一遍即可，方便以后想修改密码、端口什么的，而且功能更多。 第2种方式:CentOS/Debian/Ubuntu ShadowsocksR单/多端口一键管理脚本： 123yum -y install wgetwget -N --no-check-certificate https://softs.fun/Bash/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 备用下载地址： 123yum -y install wgetwget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 复制上面的代码到VPS服务器里，安装脚本后，以后只需要运行这个快捷命令就可以出现下图的界面进行设置，快捷管理命令为：bash ssr.sh 如上图出现管理界面后，输入数字1来安装SSR服务端。如果输入1后不能进入下一步，那么请退出xshell，重新连接vps服务器，然后输入快捷管理命令bash ssr.sh 再尝试。 根据上图提示，依次输入自己想设置的端口和密码 (密码建议用字母，图中的密码只是作为演示用)，回车键用于确认 如上图，选择想设置的加密方式，比如10，按回车键确认 接下来是选择协议插件，如下图： 选择并确认后，会出现上图的界面，提示你是否选择兼容原版，这里的原版指的是SS客户端，可以根据需求进行选择，原则上不推荐使用SS客户端，演示选择n 之后进行混淆插件的设置，如下面 进行混淆插件的设置后，会依次提示你对设备数、单线程限速和端口总限速进行设置，默认值是不进行限制，个人使用的话，选择默认即可，即直接敲回车键。 之后代码就正式自动部署了，到下图所示的位置，提示你下载文件，输入：y 耐心等待一会，出现下面的界面即部署完成： 根据上图就可以看到自己设置的SSR账号信息，包括IP、端口、密码、加密方式、协议插件、混淆插件。如果之后想修改账号信息，直接输入快捷管理命令：bash ssr.sh 进入管理界面，选择相应的数字来进行一键修改。例如： 第2个脚本的演示结束。 第四步：一键加速VPS服务器此加速教程为谷歌BBR加速 ，vultr的服务器可以装谷歌bbr。 按照第二步的步骤，重新连接服务器ip，登录成功后，在命令栏里粘贴以下代码： 【谷歌BBR加速教程】 1234567yum -y install wgetwget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 把上面整个代码复制后粘贴进去，不动的时候按回车，然后耐心等待，最后重启vps服务器即可。 演示开始，如图： 复制并粘贴代码后，按回车键确认 如下图提示，按任意键继续部署 部署到上图这个位置的时候，等待3～6分钟 最后输入y重启服务器或者手动输入代码reboot来确保加速生效。 购买vps服务器后，ip有了，通过部署，端口、密码、加密方式、协议和混淆也有了，最后将这些信息填入SSR客户端就可以翻墙啦。 有了账号后，打开SSR客户端，填上信息，这里以windows版的SSR客户端为例子： 在对应的位置，填上服务器ip、服务器端口、密码、加密方式、协议和混淆，最后将浏览器的代理设置为（http）127.0.0.1 1080即可。账号的端口号就是你自己设置的，而要上网的浏览器的端口号是1080，固定的，谷歌浏览器可以通过 SwitchyOmega 插件来设置。 有问题可以在这个帖子留言，或者自己网上搜索不明白的地方。多实践会更好。第一次部署时会慢一点，熟练了之后，就很快了。 常见问题参考解决方法：1、用了一段时间发现ssr账号用不了了？ 多半是被墙了，即ip失效。首先ping一下自己的ip，看看能不能ping的通，ping不通那么就是ip被墙了，遇到这种情况重新部署一个新的服务器，新的服务器就是新的ip。关于怎么ping ip的方法，可以自行网上搜索，很简单。vultr服务商开通和删除服务器非常方便（新服务器即新ip。大多数vps服务商都没有这样的服务，一般的vps服务商可能会提供更换1次ip的服务，如果你买的是别家的vps，一定要了解是否能够更换ip，假如不能，那么万一你的ip不幸被墙，钱就打水漂了）。 2、刚搭建好的ssr账号，ip能ping通，但是还是用不了？ 首选，排除杀毒软件的干扰，尤其是国产杀毒软件，包括但不限于360安全卫生、360杀毒软件、腾讯管家、金山卫生等。这些东西很容易干扰翻墙上网，如果你的电脑安装了这样的东西，建议至少翻墙时别用。其次，检查下SSR信息是否填写正确。浏览器的代理方式是否是ssr代理，即127.0.0.1 1080端口。如果以上条件都排除，还是用不了，那么可以更换端口、加密方式、协议、混淆，或者更换服务器位置。 3、vps的服务器操作系统不要用的太高，太高可能会因为系统的防火墙问题导致搭建的SSR账号连不上，如果你用的centos系统，建议用centos6，不要用centos7。如果你前面不小心装了centos7系统，那么只能重装系统或者重新部署新的vps服务器。 4、小知识：vultr服务商提供的vps服务器是单向流量计算，有的vps服务商是双向流量计算，单向流量计算对于用户来说更实惠。因为我们是在vps服务器上部署SSR服务端后，再用SSR客户端翻墙，所以SSR服务端就相当于中转，比如我们看一个视频，必然会产生流量，假如消耗流量80M，那么VPS服务器会产生上传80M和下载80M流量，vultr服务商只计算单向的80M流量。如果是双向计算流量，那么会计算为160M流量。 5、如果你想把搭建的账号给多人使用，不用额外设置端口，因为一个账号就可以多人使用。一般10美元的服务器可以同时支持100人在线使用。如果你想额外的设置端口，采用第二个部署脚本，在管理界面输入数字9，就可以设置多端口了。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>ssr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之触摸事件]]></title>
    <url>%2F2016%2F04%2F27%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[本文介绍了iOS中使用频率较高的触摸事件，并阐述了事件产生和传递的过程，以及响应者链的事件传递过程 触摸事件简介 在用户使用app过程中，会产生各种各样的事件 iOS中的事件可以分为3大类型 触摸事件 加速计事件 远程控制事件 响应者对象 在iOS中不是任何对象都能处理事件，只有继承了UIResponder的对象才能接收并处理事件。我们称之为“响应者对象” UIApplication、UIViewController、UIView都继承自UIResponder，因此它们都是响应者对象，都能够接收并处理事件 UIResponder 触摸事件 1234-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;-(void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;-(void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;-(void)touchesCancelled:(NSSet *)touches withEvent (UIEvent *)event; 加速计事件 123-(void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event;-(void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event;-(void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event; 远程控制事件 1-(void)remoteControlReceivedWithEvent:(UIEvent *)event; UIView的触摸事件处理 UIView是UIResponder的子类，可以覆盖下列4个方法处理不同的触摸事件: 一根或者多根手指开始触摸view，系统会自动调用view的下面方法 1-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event 一根或者多根手指在view上移动，系统会自动调用view的下面方法（随着手指的移动，会持续调用该方法） 1-(void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event 一根或者多根手指离开view，系统会自动调用view的下面方法 1-(void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event 触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用view的下面方法 1-(void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event 提示：touches中存放的都是UITouch对象 UITouch对象和作用 当用户用一根手指触摸屏幕时，会创建一个与手指相关联的UITouch对象 一根手指对应一个UITouch对象 UITouch的作用：保存着跟手指相关的信息，比如触摸的位置、时间、阶段 当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置 当手指离开屏幕时，系统会销毁相应的UITouch对象*提示：iPhone开发中，要避免使用双击事件！* UITouch的属性 触摸产生时所处的窗口 1@property(nonatomic,readonly,retain) UIWindow *window; 触摸产生时所处的视图 1@property(nonatomic,readonly,retain) UIView *view; 短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击 1@property(nonatomic,readonly) NSUInteger tapCount; 记录了触摸事件产生或变化时的时间，单位是秒 1@property(nonatomic,readonly) NSTimeInterval timestamp; 当前触摸事件所处的状态 1@property(nonatomic,readonly) UITouchPhase phase; UITouch的方法1-(CGPoint)locationInView:(UIView *)view; 返回值表示触摸在view上的位置 这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)） 调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置 1-(CGPoint)previousLocationInView:(UIView *)view; 该方法记录了前一个触摸点的位置 UIEvent 每产生一个事件，就会产生一个UIEvent对象 UIEvent：称为事件对象，记录事件产生的时刻和类型 常见属性 事件类型 12@property(nonatomic,readonly) UIEventType type;@property(nonatomic,readonly) UIEventSubtype subtype; 事件产生的时间 1@property(nonatomic,readonly) NSTimeInterval timestamp; UIEvent还提供了相应的方法可以获得在某个view上面的触摸对象（UITouch) touches和event参数 一次完整的触摸过程，会经历三个状态 触摸开始 1-(void)touchBegan:(NSSet *)touches withEvent:(UIEvent *)event 触摸移动 1-(void)touchMoved:(NSSet *)touches withEvent:(UIEvent *)event 触摸结束 1-(void)touchEnded:(NSSet *)touches withEvent:(UIEvent *)event 触摸取消 1-(void)touchCancelled:(NSSet *)touches withEvent:(UIEvent *)event 4个触摸事件处理方法中，都有NSSet touches和UIEvent event两个参数 一次完整的触摸过程中，只会产生一个事件对象，4个触摸方法都是同一个event参数 如果两根手指同时触摸一个view，那么view只会调用一次touchesBegan:withEvent:方法，touches参数中装着2个UITouch对象 如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次touchesBegan:withEvent:方法，并且每次调用时的touches参数中只包含一个UITouch对象 根据touches中UITouch的个数可以判断出是单点触摸还是多点触摸 事件产生和传递 发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中 UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow） 主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步 找到合适的视图控件后，就会调用视图控件的touches方法来作具体的事件处理 touchesBegan… touchesMoved… touchedEnded… 如果父控件不能接收触摸事件，那么子控件就不可能接收到触摸事件 UIView不接收触摸事件的三种情况： 不接收用户交互 userInteractionEnabled = NO 隐藏 hidden = YES 透明 alpha = 0.0 ~ 0.01 提示：UIImageView的userInteractionEnabled默认就是NO，因此UIImageView以及它的子控件默认是不能接收触摸事件的 响应者链条 响应者链条：是由多个响应者对象连接起来的链条 作用：能很清楚的看见每个响应者之间的联系，并且可以让一个事件多个对象处理。 响应者对象：能处理事件的对象 响应者链条示意图 事件传递的完整过程 先将事件对象由上往下传递(由父控件传递给子控件)，找到最合适的控件来处理这个事件。 调用最合适控件的touches….方法 如果调用了[super touches….];就会将事件顺着响应者链条往上传递，传递给上一个响应者 接着就会调用上一个响应者的touches….方法 如何判断上一个响应者 如果当前这个view是控制器的view,那么控制器就是上一个响应者 如果当前这个view不是控制器的view,那么父控件就是上一个响应者 响应者链的事件传递过程 如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图 在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理 如果window对象也不处理，则其将事件或消息传递给UIApplication对象 如果UIApplication也不能处理该事件或消息，则将其丢弃 手势识别 为了完成手势识别，必须借助于手势识别器—-UIGestureRecognizer;利用UIGestureRecognizer，能轻松识别用户在某个view上面做的一些常见手势 UIGestureRecognizer是一个抽象类，定义了所有手势的基本行为，使用它的子类才能处理具体的手势 UITapGestureRecognizer(敲击) UIPinchGestureRecognizer(捏合，用于缩放) UIPanGestureRecognizer(拖拽) UISwipeGestureRecognizer(轻扫) UIRotationGestureRecognizer(旋转) UILongPressGestureRecognizer(长按) 每一个手势识别器的用法都差不多，比如UITapGestureRecognizer的使用步骤如下： 创建手势识别器对象 1UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] init]; 设置手势识别器对象的具体属性 1234// 连续敲击2次tap.numberOfTapsRequired = 2;// 需要2根手指一起敲击tap.numberOfTouchesRequired = 2; 添加手势识别器到对应的view上 1[self.iconView addGestureRecognizer:tap]; 监听手势的触发 1[tap addTarget:self action:@selector(tapIconView:)]; 手势识别的状态 12345678910111213141516typedef NS_ENUM(NSInteger, UIGestureRecognizerState) &#123; // 没有触摸事件发生，所有手势识别的默认状态 UIGestureRecognizerStatePossible, // 一个手势已经开始但尚未改变或者完成时 UIGestureRecognizerStateBegan, // 手势状态改变 UIGestureRecognizerStateChanged, // 手势完成 UIGestureRecognizerStateEnded, // 手势取消，恢复至Possible状态 UIGestureRecognizerStateCancelled, // 手势失败，恢复至Possible状态 UIGestureRecognizerStateFailed, // 识别到手势识别 UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded&#125;;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之核心动画]]></title>
    <url>%2F2016%2F04%2F27%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[Core Animation,中文翻译为核心动画,它是一组非常强大的动画处理API,使用它能做出非常绚丽的动画效果,而且往往事半功倍.也就是说,使用少量的代码就可以实现非常强大的功能. Core Animation的动画执行过程都是在后台操作的,不会阻塞主线程 Core Animation是直接作用在CALayer上的,并非UIView 所以在了解Core Animation之前,先要了解什么是CALayer CALayer 在iOS中,你能看得见摸得着的东西基本上都是UIView,比如:按钮,文本标签等等;其实UIView之所以能显示在屏幕上,完全是因为它内部的一个图层 在创建UIView对象时,UIView内部会自动创建一个图层(即CALayer对象),通过UIView的layer属性可以访问这个层 12345678910111213141516171819202122232425@property(nonatomic,readonly,retain) CALayer *layer; ``` - 当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示;UIView本身不具备显示的功能，是它内部的层才有显示功能- CALayer的一些属性```objc//宽度和高度@property CGRect bounds;//位置(默认指中点，具体由anchorPoint决定)@property CGPoint position;//锚点(x,y的范围都是0-1)，决定了position的含义@property CGPoint anchorPoint;//背景颜色(CGColorRef类型)@property CGColorRef backgroundColor;//形变属性@property CATransform3D transform;//边框颜色(CGColorRef类型)@property CGColorRef borderColor;//边框宽度@property CGFloat borderWidth;//圆角半径@property CGColorRef borderColor;//内容(比如设置为图片CGImageRef)@property(retain) id contents; UIView和CALayer的选择 通过CALayer，就能做出跟UIImageView一样的界面效果既然CALayer和UIView都能实现相同的显示效果，那究竟该选择谁好呢？其实，对比CALayer，UIView多了一个事件处理的功能。也就是说，CALayer不能处理用户的触摸事件，而UIView可以.所以，如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以.当然，CALayer的性能会高一些，因为它少了事件处理的功能，更加轻量级. position和anchorPoint 1@property CGPoint position; 用来设置CALayer在父层中的位置 以父层的左上角为原点(0, 0) 1@property CGPoint anchorPoint; 称为“定位点”、“锚点” 决定着CALayer身上的哪个点会在position属性所指的位置 以自己的左上角为原点(0, 0) 它的x、y取值范围都是0~1，默认值为（0.5, 0.5） 隐式动画 每一个UIView内部都默认关联着一个CALayer，我们可用称这个Layer为Root Layer（根层） 所有的非Root Layer，也就是手动创建的CALayer对象，都存在着隐式动画 什么是隐式动画？ 当对非Root Layer的部分属性进行修改时，默认会自动产生一些动画效果 而这些属性称为Animatable Properties(可动画属性) 列举几个常见的Animatable Properties： bounds：用于设置CALayer的宽度和高度。修改这个属性会产生缩放动画 backgroundColor：用于设置CALayer的背景色。修改这个属性会产生背景色的渐变动画 position：用于设置CALayer的位置。修改这个属性会产生平移动画 可以通过动画事务(CATransaction)关闭默认的隐式动画效果 1234[CATransaction begin];[CATransaction setDisableActions:YES];self.myview.layer.position = CGPointMake(10, 10);[CATransaction commit]; Core Animation 核心动画中所有类都遵守CAMediaTiming CAAnaimation是个抽象类，不具备动画效果，必须用它的子类才有动画效果 CAAnimationGroup和CATransition才有动画效果 CAAnimationGroup是个动画组，可以同时进行缩放，旋转。 CATransition是转场动画，界面之间跳转都可以用转场动画。 CAPropertyAnimation也是个抽象类，本身不具备动画效果，只有子类才有 CABasicAnimation和CAKeyframeAnimation CABasicAnimation基本动画，做一些简单效果 CAKeyframeAnimation帧动画，做一些连续的流畅的动画 开发步骤 如果不是xcode5之后的版本，使用它需要先添QuartzCore.framework和引入对应的框架 首先得有CALayer 初始化一个CAAnimation对象，并设置一些动画相关属性 通过调用CALayer的addAnimation:forKey:方法，增加CAAnimation对象到CALayer中，这样就能开始执行动画了 通过调用CALayer的removeAnimationForKey:方法可以停止CALayer中的动画 CAAnimation 简介 是所有动画对象的父类，负责控制动画的持续时间和速度，是个抽象类，不能直接使用，应该使用它具体的子类 属性说明：(红色代表来自CAMediaTiming协议的属性) duration：动画的持续时间 repeatCount：重复次数，无限循环可以设置HUGE_VALF或者MAXFLOAT repeatDuration：重复时间 removedOnCompletion：默认为YES，代表动画执行完毕后就从图层上移除，图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为NO，不过还要设置fillMode为kCAFillModeForwards fillMode：决定当前对象在非active时间段的行为。比如动画开始之前或者动画结束之后 beginTime：可以用来设置动画延迟执行时间，若想延迟2s，就设置为CACurrentMediaTime()+2，CACurrentMediaTime()为图层的当前时间 timingFunction：速度控制函数，控制动画运行的节奏 delegate：动画代理 12345678910#pragma mark 暂停CALayer的动画-(void)pauseLayer:(CALayer*)layer&#123; CFTimeInterval pausedTime = [layer convertTime:CACurrentMediaTime() fromLayer:nil]; // 让CALayer的时间停止走动 layer.speed = 0.0; // 让CALayer的时间停留在pausedTime这个时刻 layer.timeOffset = pausedTime;&#125; 12345678910111213141516#pragma mark 恢复CALayer的动画-(void)resumeLayer:(CALayer*)layer&#123; CFTimeInterval pausedTime = layer.timeOffset; // 1. 让CALayer的时间继续行走 layer.speed = 1.0; // 2. 取消上次记录的停留时刻 layer.timeOffset = 0.0; // 3. 取消上次设置的时间 layer.beginTime = 0.0; // 4. 计算暂停的时间(这里也可以用CACurrentMediaTime()-pausedTime) CFTimeInterval timeSincePause = [layer convertTime:CACurrentMediaTime() fromLayer:nil] - pausedTime; // 5. 设置相对于父坐标系的开始时间(往后退timeSincePause) layer.beginTime = timeSincePause;&#125; 动画填充模式 fillMode属性值（要想fillMode有效，最好设置removedOnCompletion = NO） kCAFillModeRemoved 这个是默认值，也就是说当动画开始前和动画结束后，动画对layer都没有影响，动画结束后，layer会恢复到之前的状态 kCAFillModeForwards 当动画结束后，layer会一直保持着动画最后的状态 kCAFillModeBackwards 在动画开始前，只需要将动画加入了一个layer，layer便立即进入动画的初始状态并等待动画开始。 kCAFillModeBoth 这个其实就是上面两个的合成.动画加入后开始之前，layer便处于动画初始状态，动画结束后layer保持动画最后的状态 速度控制函数 速度控制函数(CAMediaTimingFunction) kCAMediaTimingFunctionLinear（线性）：匀速，给你一个相对静态的感觉 kCAMediaTimingFunctionEaseIn（渐进）：动画缓慢进入，然后加速离开 kCAMediaTimingFunctionEaseOut（渐出）：动画全速进入，然后减速的到达目的地 kCAMediaTimingFunctionEaseInEaseOut（渐进渐出）：动画缓慢的进入，中间加速，然后减速的到达目的地。这个是默认的动画行为。 动画代理方法 1234567891011121314@interface NSObject (CAAnimationDelegate)/* Called when the animation begins its active duration. */- (void)animationDidStart:(CAAnimation *)anim;/* Called when the animation either completes its active duration or * is removed from the object it is attached to (i.e. the layer). 'flag' * is true if the animation reached the end of its active duration * without being removed. */- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag;@end 1. CAPropertyAnimation 是CAAnimation的子类，也是个抽象类，要想创建动画对象，应该使用它的两个子类： CABasicAnimation CAKeyframeAnimation 属性说明： keyPath：通过指定CALayer的一个属性名称为keyPath（NSString类型），并且对CALayer的这个属性的值进行修改，达到相应的动画效果。比如，指定@“position”为keyPath，就修改CALayer的position属性的值，以达到平移的动画效果 CABasicAnimation 基本动画,是CAPropertyAnimation的子类 属性说明: fromValue：keyPath相应属性的初始值 toValue：keyPath相应属性的结束值 动画过程说明： 随着动画的进行，在长度为duration的持续时间内，keyPath相应属性的值从fromValue渐渐地变为toValue keyPath内容是CALayer的可动画Animatable属性 如果fillMode=kCAFillModeForwards同时removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。 关键帧动画 关键帧动画，也是CAPropertyAnimation的子类，与CABasicAnimation的区别是： CABasicAnimation只能从一个数值（fromValue）变到另一个数值（toValue），而CAKeyframeAnimation会使用一个NSArray保存这些数值 属性说明： values：上述的NSArray对象。里面的元素称为“关键帧”(keyframe)。动画对象会在指定的时间（duration）内，依次显示values数组中的每一个关键帧 path：可以设置一个CGPathRef、CGMutablePathRef，让图层按照路径轨迹移动。path只对CALayer的anchorPoint和position起作用。如果设置了path，那么values将被忽略 keyTimes：可以为对应的关键帧指定对应的时间点，其取值范围为0到1.0，keyTimes中的每一个时间值都对应values中的每一帧。如果没有设置keyTimes，各个关键帧的时间是平分的 CABasicAnimation可看做是只有2个关键帧的CAKeyframeAnimation 2. CAAnimationGroup 动画组，是CAAnimation的子类，可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行 属性说明： animations：用来保存一组动画对象的NSArray 默认情况下，一组动画对象是同时运行的，也可以通过设置动画对象的beginTime属性来更改动画的开始时间 3. CATransition CATransition是CAAnimation的子类，用于做转场动画，能够为层提供移出屏幕和移入屏幕的动画效果。iOS比Mac OS X的转场动画效果少一点 UINavigationController就是通过CATransition实现了将控制器的视图推入屏幕的动画效果 动画属性: type：动画过渡类型 subtype：动画过渡方向 startProgress：动画起点(在整体动画的百分比) endProgress：动画终点(在整体动画的百分比) 转场动画过渡效果 类型字符串 效果说明 关键字 方向 fade 交叉淡化过渡 YES push 新视图把旧视图推出去 YES moveIn 新视图移到旧视图上面 YES reveal 将旧视图移开,显示下面的新视图 YES cube 立方体翻滚效果 oglFlip 上下左右翻转效果 suckEffect 收缩效果，如一块布被抽走 NO rippleEffect 水滴效果 NO pageCurl 向上翻页效果 pageUnCurl 向下翻页效果 facameraIrisHollowOpende 相机镜头打开效果 NO cameraIrisHollowClose 相机镜头关闭效果 NO 使用UIView动画函数实现转场动画——单视图 1+ (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion; 参数说明： duration：动画的持续时间 view：需要进行转场动画的视图 options：转场动画的类型 animations：将改变视图属性的代码放在这个block中 completion：动画结束后，会自动调用这个block 使用UIView动画函数实现转场动画——双视图 1+ (void)transitionFromView:(UIView *)fromView toView:(UIView *)toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^)(BOOL finished))completion; 参数说明： duration：动画的持续时间 options：转场动画的类型 animations：将改变视图属性的代码放在这个block中 completion：动画结束后，会自动调用这个block]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之混合开发简单介绍]]></title>
    <url>%2F2016%2F04%2F18%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[2014年,历时8年的HTML标准制定完成.利用HTML5编写的UI界面能运行在所有拥有浏览器的平台之上,且开发迅速而简单.这样,混合开发使得iOS开发变得更简单,更快捷 1. Web开发新时代 Web1.0 主流技术:HTML+CSS Web2.0 主流技术:Ajax(JavaScript/DOM/异步数据请求) Web3.0 主流技术:HTML5+CSS3 HTML5亮点: Canvas\HTML5音视频\Web存储 Geolocation \Workers多线程处理 CSS3亮点: 设计动画\2D变形\N多新特性 网页的组成 一个有具体功能的完整的网页，一般由3部分组成 HTML网页的具体内容和结构 CSS网页的样式（美化网页最重要的一块） JavaScript(掌握)网页的交互效果，比如对用户鼠标事件做出响应 HTML\CSS\JavaScript学习资料：http://www.w3school.com.cn/ 2. HTML 什么是HTML HTML的全称是HyperText Markup Language，超文本标记语言 其实它就是文本，由浏览器负责将它解析成具体的网页内容 HTML的组成 跟XML类似，HTML由N个标签（节点、元素、标记）组成 HTML语法非常松散，目前的最新版是5.0，也就是HTML 5 常见的HTML标签 标题：h1、h2、h3、h4、h5…. 段落：p 换行：br 容器：div、span（用来容纳其他标签） 表格：table、tr、td 列表：ul、ol、li 图片：img 表单：input 链接：a HTML标签类型HTML有N多标签，根据显示的类型，主要可以分为3大类 块级标签独占一行的标签能随时设置宽度和高度（比如div、p、h1、h2、ul、li） 行内标签（内联标签）多个行内标签能同时显示在一行宽度和高度取决于内容的尺寸（比如span、a、label） 行内-块级标签（内联-块级标签）多个行内-块级标签可以显示在同一行能随时设置宽度和高度（比如input、button） CSS中有个display属性，能修改标签的显示类型 none：隐藏标签 block：让标签变为块级标签 inline：让标签变为行内标签 inline-block：让标签变为行内-块级标签（内联-块级标签） HTML5新增标签 HTML5新增了27个标签元素,废弃了16个标签元素,主要包括结构性标签、级块性标签、行内语义性标签、交互性标签 结构性标签负责Web上下文结构的定义，确保HTML文档，包括： - article 文章主体内容(一篇博客、一篇论坛帖子、一段用户评论、插件) - header 标记头部区域内容 - footer 标记脚部区域内容 - section 区域章节表述 - nav 菜单导航,链接导航 块级性标签完成Web页面区域的划分，确保内容的有效分隔，包括： - aside 注记,贴士,侧栏,摘要,插入的引用作为补充主体的内容 - figure 对多个元素组合并展示的元素,常与figcaption联合使用 - code 表示一段代码块 - dialog 人与人之间对话,包含dt和dd两个组合元素（dt用于表示说话者、dd用于表示说话者的内容） 行内语义性标签完成Web页面具体内容的引用和表述，丰富展示内容，包括： - meter 特定范围内的数值，如工资、数量、百分比 - time 时间值 - progress 进度条，可用max、min、step进行控制，完成对进度的表示和监听 - video 视频元素，用于视频播放，支持缓冲预载和多种视频媒体格式 - audio 音频元素，用于音频播放，支持缓冲预载和多种音频媒体格式 交互性标签功能性内容的表达，有一定的内容和数据的关联，是各种事件的基础，包括： - details 表示一段具体的内容，默认不显示，通过某种方式（单击）与legend交互才会显示 - datagrid 控制客户端数据与显示，可用于动态脚本及时更新 - menu 用于交互菜单 - command 用来处理命令按钮 3. CSS 什么是CSS CSS的全称是Cascading Style Sheets，层叠样式表 它用来控制HTML标签的样式，在美化网页中起到非常重要的作用 CSS的编写格式是键值对形式的，比如: 123456789color: red;background-color: blue;font-size: 20px;``` - 冒号:左边的是属性名，冒号:右边的属性值&gt;CSS的3种书写形式- 行内样式：（内联样式）直接在标签的style属性中书写 1- 页内样式：在本网页的style标签中书写 body { color: red; } 1- 外部样式：在单独的CSS文件中书写，然后在网页中用link标签引用 123456789&gt;CSS的两大重点1. 属性 通过属性的复杂叠加才能做出漂亮的网页 - CSS有N多属性，根据继承性，主要可以分为2大类 - 可继承属性父标签的属性值会传递给子标签一般是文字控制属性 所有标签可继承visibility、cursor内联标签可继承letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction 块级标签可继承text-indent、text-align列表标签可继承list-style、list-style-type、list-style-position、list-style-image1234 - 不可继承属性父标签的属性值不能传递给子标签一般是区块控制属性 display、margin、border、padding、backgroundheight、min-height、max-height、width、min-width、max-widthoverflow、position、left、right、top、bottom、z-indexfloat、cleartable-layout、vertical-alignpage-break-after、page-bread-beforeunicode-bidi1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 2. 选择器 通过选择器找到对应的标签设置样式*(具体选择器内容和教程请参考:http://www.w3school.com.cn/css/index.asp)*&gt; CSS布局- 默认情况下，所有的网页标签都在标准流布局中,从上到下，从左到右- 脱离标准流的方法有 - float属性 - float属性的常用取值有: `left`：脱离标准流，浮动在父标签的最左边`right`：脱离标准流，浮动在父标签的最右边 - position属性 ![position属性](http://upload-images.jianshu.io/upload_images/1879463-98d3215b81c3df23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&gt;CSS3新增特性- **RGBA透明度** RGB(红色R+绿色G+蓝色B),RGBA则在其基础上增加了Alpha通道，可用于设置透明值- **块阴影与圆角阴影** box-shadow text-shadow- **圆角** border-radius- **边框图片** border-image- **形变** transform: none | &lt;transform-function&gt;[&lt;transform-fuction&gt;]### 4. 盒子模型![盒子模型](http://upload-images.jianshu.io/upload_images/1879463-dcd26e170da66975.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)- 网页上的每一个标签都是一个盒子- 每个盒子都有四个属性 1. 内容（content）![内容属性](http://upload-images.jianshu.io/upload_images/1879463-fd9b30c8df171c7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 2. 填充（padding，内边距）![填充属性](http://upload-images.jianshu.io/upload_images/1879463-5689bf59b9e0f5fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 3. 边框（border）：盒子本身 4. 边界（margin，外边距）![边界属性](http://upload-images.jianshu.io/upload_images/1879463-2803e390750974e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![标准盒子模型](http://upload-images.jianshu.io/upload_images/1879463-7d4bf71b5a129753.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![IE盒子模型](http://upload-images.jianshu.io/upload_images/1879463-0ad03d90f842a6aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)### 4. JavaScript&gt;什么是JavaScript- JavaScript是一门广泛用于浏览器客户端的脚本语言，由Netspace公司设计，当时跟Sun公司合作，所以名字起得像Java。业内一般简称JS&gt;JS的常见用途- HTML DOM操作（节点操作，比如添加、修改、删除节点）- 给HTML网页增加动态功能，比如动画- 事件处理：比如监听鼠标点击、鼠标滑动、键盘输入&gt;JavaScript的书写方式- JS常见的书写方式有2种 - 页内JS：在当前网页的script标签中编写 1- 外部JS 1234&gt;Canvas- HTML &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; 1- JS var canvas = document.getElementById(‘canvas’); var context = canvas.getContext(‘2d’);12345 - `context`是一个绘图的上下文环境 - `2d`是二维图形- Canvas绘制直线 - 起点 context.moveTo(100,100);123 - 终点``` context.lineTo(400, 400); 绘制 1 context.stroke(); 设置线条颜色和宽度 12 context.strokeStyle = &apos;red&apos;; context.lineWidth = 5; 设置填充色 1 context.fillStyle = &apos;blue&apos;; Canvas绘制弧线 12345 context.arc( centerX, centerY, radius, startingAngle, endingAngle, anticlockwise=false ) centerX, centerY: 圆心的坐标 radius: 半径 startingAngle, endingAngle: 开始角度,结束角度 anticlockwise: false顺时针 true逆时针]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之数据存储]]></title>
    <url>%2F2016%2F04%2F12%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[作为移动端开发工程师，所需要的数据几乎全部都是通过网络获取，而且网络请求都有时耗；在网络好的情况下这种时耗虽然不足考虑，但是一旦网络环境不好，会很影响产品体验。网络环境无法控制，但是对于一些数据不经常变动的网络请求或没必要实时更新的数据，我们可以选择将网络数据缓存本地，适时更新。 iOS应用数据存储的常用方式 XML属性列表(plist)归档 Preference(偏好设置) NSKeyedArchiver归档(NSCoding) SQLite 3 Core Data 应用沙盒每个iOS应用都有自己的应用沙盒(应用沙盒就是文件系统目录),与其他文件系统隔离,应用必须待在自己的沙盒里,其他应用不能访问沙盒 应用沙盒的文件系统目录,如下图所示(假设应用的名称叫Layer) 应用沙盒结构分析应用程序包: (上图中的Layer)包含了所有的资源文件和可执行文件Documents: 保存应用运行时生成的需要持久化的数据,itunes同步设备时会备份该目录,例如:游戏应用可以将游戏存档保存在该目录tmp: 保存应用运行时所需的临时数据, 使用完毕后再见相应的文件从该目录删除.应用没有运行时,系统也可能会清除该目录下的文件.itunes同步设备的时候不会备份该文件夹Library/Caches: 保存应用运行时生成的需要持久化的数据,iTunes同步设备的时候不会备份该目录.一般存储体积大,不需要备份的非重要数据Library/Preferences: 保存应用的所有偏好设置,iOS的settings(设置)应用会在该目录中查找应用的设置信息.iTunes同步设备时会备份该目录 应用沙盒目录的常见获取方式沙盒根目录1NSString * home = NSHomeDirectory(); Documents(2种方式) 利用沙盒根目录拼接”Documents”字符串 12 NSString * home = NSHomeDirectory(); NSString * documents = [home stringByAppendingPathComponent:@"Documents"]; 不建议采用,因为新版本的操作系统可能会修改目录名 利用NSSearchPathForDirectoriesInDomains函数 12345//NSUserDomainMask代表从用户文件夹下找//YES,代表展开路径中的波浪字符"~"NSArray * arr = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, NO);//在iOS中,只有一个目录跟传入的参数匹配,所以这个集合里面只有一个元素NSString * documents = [arr objectAtIndex:0]; tmp1NSString * tmp = NSTemporaryDirectory(); Library/Caches(跟Documents相似的2种方法) 利用沙盒根目录拼接”Caches”字符串 利用NSSearchPathForDirectoriesInDomains函数 (将函数的第一个参数改为NSCachesDirectory即可) Library/Preferences通过NSUserDefaults类存取该目录下的设置信息 属性列表属性列表是一种XML格式的文件, 拓展名为plist 如果对象是NSString\NSDictionary\NSArray\NSData\NSNumber等类型, 就可以使用writeToFile:atomically:方法直接将对象写到属性列表文件中 属性列表 - 归档NSDictionary 将一个NSDictionary对象归档到一个plist属性列表中 1234567//将数据封装成字典NSMutableDictionary * dic = [NSMutableDictionary dictionary];[dic setObject:@"小米" forKey:@"name"];[dic setObject:@"11111111111" forKey:@"phone"];[dic setObject:@"6" forKey:@"size"];//将字典持久化到Documents/phone.plist文件中[dic writeToFile:path atomically:YES]; NSDictionary的存储和读取过程 偏好设置很多iOS应用都支持偏好设置,比如保存用户名\密码\字体大小等设置, iOS提供了一套标准的解决方案来为应用加入偏好设置功能 每个应用都有个NSUserDefaults实例，通过它来存取偏好设置 比如，保存用户名、字体大小、是否自动登录 1234NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];[defaults setObject:@"flame" forKey:@"username"];[defaults setFloat:18.0f forKey:@"text_size"];[defaults setBool:YES forKey:@"auto_login"]; 读取上次保存的设置 1234NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];NSString *username = [defaults stringForKey:@"username"];float textSize = [defaults floatForKey:@"text_size"];BOOL autoLogin = [defaults boolForKey:@"auto_login"]; 注意：UserDefaults设置数据时，不是立即写入，而是根据时间戳定时地把缓存中的数据写入本地磁盘。所以调用了set方法之后数据有可能还没有写入磁盘应用程序就终止了。出现以上问题，可以通过调用synchornize方法强制写入 1[defaults synchornize]; NSKeyedArchiver如果对象是NSString、NSDictionary、NSArray、NSData、NSNumber等类型，可以直接用NSKeyedArchiver进行归档和恢复 不是所有的对象都可以直接用这种方法进行归档，只有遵守了NSCoding协议的对象才可以 NSCoding协议有2个方法： encodeWithCoder 每次归档对象时，都会调用这个方法。一般在这个方法里面指定如何归档对象中的每个实例变量，可以使用encodeObject:forKey:方法归档实例变量 initWithCoder 每次从文件中恢复(解码)对象时，都会调用这个方法。一般在这个方法里面指定如何解码文件中的数据为对象的实例变量，可以使用decodeObject:forKey方法解码实例变量 归档一个NSArray对象到Documents/array.archive 12NSArray *array = [NSArray arrayWithObjects:@”a”,@”b”,nil];[NSKeyedArchiver archiveRootObject:array toFile:path]; 恢复(解码)NSArray对象 1NSArray *array = [NSKeyedUnarchiver unarchiveObjectWithFile:path]; 归档对象NSKeyedArchiver-归档Person对象（Person.h） 123456789101112131415161718192021222324252627@interface Person : NSObject&lt;NSCoding&gt;@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) int age;@property (nonatomic, assign) float height;@end``` NSKeyedArchiver-归档Person对象（Person.m）```objc@implementation Person-(void)encodeWithCoder:(NSCoder *)encoder &#123; [encoder encodeObject:self.name forKey:@"name"]; [encoder encodeInt:self.age forKey:@"age"]; [encoder encodeFloat:self.height forKey:@"height"];&#125;-(id)initWithCoder:(NSCoder *)decoder &#123; self.name = [decoder decodeObjectForKey:@"name"]; self.age = [decoder decodeIntForKey:@"age"]; self.height = [decoder decodeFloatForKey:@"height"]; return self;&#125;-(void)dealloc &#123; [super dealloc]; [_name release];&#125;@end NSKeyedArchiver-归档Person对象（编码和解码） 归档(编码) 12345Person *person = [[[Person alloc] init] autorelease];person.name = @"TY";person.age = 27;person.height = 1.83f;[NSKeyedArchiver archiveRootObject:person toFile:path]; 恢复(解码) 1Person *person = [NSKeyedUnarchiver unarchiveObjectWithFile:path]; NSKeyedArchiver-归档对象的注意 如果父类也遵守了NSCoding协议，请注意： 应该在encodeWithCoder:方法中加上一句 1[super encodeWithCode:encode]; 确保继承的实例变量也能被编码，即也能被归档 应该在initWithCoder:方法中加上一句 1self = [super initWithCoder:decoder]; 确保继承的实例变量也能被解码，即也能被恢复 NSData使用archiveRootObject:toFile:方法可以将一个对象直接写入到一个文件中，但有时候可能想将多个对象写入到同一个文件中，那么就要使用NSData来进行归档对象NSData可以为一些数据提供临时存储空间，以便随后写入文件，或者存放从磁盘读取的文件内容。可以使用[NSMutableData data]创建可变数据空间 NSData-归档2个Person对象到同一文件中 归档（编码） 1234567891011// 新建一块可变数据区NSMutableData *data = [NSMutableData data];// 将数据区连接到一个NSKeyedArchiver对象NSKeyedArchiver *archiver = [[[NSKeyedArchiver alloc] initForWritingWithMutableData:data] autorelease];// 开始存档对象，存档的数据都会存储到NSMutableData中[archiver encodeObject:person1 forKey:@"person1"];[archiver encodeObject:person2 forKey:@"person2"];// 存档完毕(一定要调用这个方法)[archiver finishEncoding];// 将存档的数据写入文件[data writeToFile:path atomically:YES]; 恢复（解码） 12345678// 从文件中读取数据NSData *data = [NSData dataWithContentsOfFile:path];// 根据数据，解析成一个NSKeyedUnarchiver对象NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];Person *person1 = [unarchiver decodeObjectForKey:@"person1"];Person *person2 = [unarchiver decodeObjectForKey:@"person2"];// 恢复完毕[unarchiver finishDecoding]; 利用归档实现深复制 比如对一个Person对象进行深复制 1234567// 临时存储person1的数据NSData *data = [NSKeyedArchiver archivedDataWithRootObject:person1];// 解析data，生成一个新的Person对象Student *person2 = [NSKeyedUnarchiver unarchiveObjectWithData:data];// 分别打印内存地址NSLog(@"person1:0x%x", person1); // person1:0x7177a60NSLog(@"person2:0x%x", person2); // person2:0x7177cf0 SQLite3SQLite3是一款开源的嵌入式关系型数据库，可移植性好、易使用、内存开销小SQLite3是无类型的，意味着你可以保存任何类型的数据到任意表的任意字段中。比如下列的创表语句是合法的： create table t_person(name, age);为了保证可读性，建议还是把字段类型加上：create table t_person(name text, age integer); SQLite3常用的5种数据类型：text、integer、float、boolean、blob 在iOS中使用SQLite3，首先要添加库文件libsqlite3.dylib和导入主头文件 1#import &lt;sqlite3.h&gt; 创建、打开、关闭数据库 创建或打开数据库 123// path为：~/Documents/person.dbsqlite3 *db;int result = sqlite3_open([path UTF8String], &amp;db); 代码解析:sqlite3_open()将根据文件路径打开数据库，如果不存在，则会创建一个新的数据库。如果result等于常量SQLITE_OK，则表示成功打开数据库 sqlite3 *db：一个打开的数据库实例 数据库文件的路径必须以C字符串(而非NSString)传入 关闭数据库： 1sqlite3_close(db); 执行不返回数据的SQL语句 执行创表语句 123char *errorMsg; // 用来存储错误信息char *sql = "create table if not exists t_person(id integer primary key autoincrement, name text, age integer);";int result = sqlite3_exec(db, sql, NULL, NULL, &amp;errorMsg); 代码解析：sqlite3_exec()可以执行任何SQL语句，比如创表、更新、插入和删除操作。但是一般不用它执行查询语句，因为它不会返回查询到的数据 sqlite3_exec()还可以执行的语句： 开启事务：begin transaction; 回滚事务：rollback; 提交事务：commit; 带占位符插入数据 12345678910char *sql = "insert into t_person(name, age) values(?, ?);";sqlite3_stmt *stmt;if (sqlite3_prepare_v2(db, sql, -1, &amp;stmt, NULL) == SQLITE_OK) &#123; sqlite3_bind_text(stmt, 1, "母鸡", -1, NULL); sqlite3_bind_int(stmt, 2, 27);&#125;if (sqlite3_step(stmt) != SQLITE_DONE) &#123; NSLog(@"插入数据错误");&#125;sqlite3_finalize(stmt); 代码解析：sqlite3_prepare_v2()返回值等于SQLITE_OK，说明SQL语句已经准备成功，没有语法问题 sqlite3_bind_text()：大部分绑定函数都只有3个参数 第1个参数是sqlite3_stmt *类型 第2个参数指占位符的位置，第一个占位符的位置是1，不是0 第3个参数指占位符要绑定的值 第4个参数指在第3个参数中所传递数据的长度，对于C字符串，可以传递-1代替字符串的长度 第5个参数是一个可选的函数回调，一般用于在语句执行后完成内存清理工作 sqlite_step()：执行SQL语句，返回SQLITE_DONE代表成功执行完毕 sqlite_finalize()：销毁sqlite3_stmt *对象 查询数据 123456789101112char *sql = "select id,name,age from t_person;";sqlite3_stmt *stmt;if (sqlite3_prepare_v2(db, sql, -1, &amp;stmt, NULL) == SQLITE_OK) &#123; while (sqlite3_step(stmt) == SQLITE_ROW) &#123; int _id = sqlite3_column_int(stmt, 0); char *_name = (char *)sqlite3_column_text(stmt, 1); NSString *name = [NSString stringWithUTF8String:_name]; int _age = sqlite3_column_int(stmt, 2); NSLog(@"id=%i, name=%@, age=%i", _id, name, _age); &#125;&#125;sqlite3_finalize(stmt); 代码解析: sqlite3_step()返回SQLITE_ROW代表遍历到一条新记录 sqlite3column*()用于获取每个字段对应的值，第2个参数是字段的索引，从0开始]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS之文件的压缩和解压缩]]></title>
    <url>%2F2016%2F04%2F12%2FiOS%E4%B9%8B%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9%2F</url>
    <content type="text"><![CDATA[使用ZipArchive来压缩和解压缩文件需要添加依赖库（libz）,使用需要包含Main文件，如果使用cocoaPoads来安装框架，那么会自动的配置框架的使用环境 压缩文件的第一种方式123456//压缩文件的第一种方式/*第一个参数：压缩文件要保存的位置第二个参数：要压缩哪几个文件*/[Main createZipFileAtPath:fullpath withFilesAtPaths:arrayM]; 压缩文件的第二种方式123456//压缩文件的第二种方式/*第一个参数：文件压缩到哪个地方第二个参数：要压缩文件的全路径*/[Main createZipFileAtPath:fullpath withContentsOfDirectory:zipFile]; 如何对压缩文件进行解压123456//如何对压缩文件进行解压/*第一个参数：要解压的文件第二个参数：要解压到什么地方*/[Main unzipFileAtPath:unZipFile toDestination:fullpath];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发--AFN框架基本使用]]></title>
    <url>%2F2016%2F04%2F12%2FiOS%E5%BC%80%E5%8F%91-AFN%E6%A1%86%E6%9E%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[AFNetworking is a delightful networking library for iOS, macOS, watchOS, and tvOS. It’s built on top of the Foundation URL Loading System, extending the powerful high-level networking abstractions built into Cocoa. It has a modular architecture with well-designed, feature-rich APIs that are a joy to use. AFN内部结构NSURLConnection AFURLConnectionOperation AFHTTPRequestOperation AFHTTPRequestOperationManager(封装了常用的 HTTP 方法) 属性 baseURL :AFN建议开发者针对 AFHTTPRequestOperationManager 自定义个一个单例子类，设置 baseURL, 所有的网络访问，都只使用相对路径即可 requestSerializer :请求数据格式/默认是二进制的 HTTP responseSerializer :响应的数据格式/默认是 JSON 格式 operationQueue reachabilityManager :网络连接管理器 方法 manager :方便创建管理器的类方法 HTTPRequestOperationWithRequest :在访问服务器时，如果要告诉服务器一些附加信息，都需要在 Request 中设置 GET POST NSURLSessionAFURLSessionManagerAFHTTPSessionManager(封装了常用的 HTTP 方法) GET POST UIKit + AFNetworking 分类 NSProgress :利用KVO 半自动的序列化&amp;反序列化的功能 AFURLRequestSerialization :请求的数据格式/默认是二进制的 AFURLResponseSerialization :响应的数据格式/默认是JSON格式 附加功能 安全策略 HTTPS AFSecurityPolicy 网络检测 对苹果的网络连接检测做了一个封装 AFNetworkReachabilityManager AFN的基本使用发送GET请求的两种方式（POST同）1234567891011121314151617181920212223242526272829303132333435363738-(void)get1&#123; //1.创建AFHTTPRequestOperationManager管理者 //AFHTTPRequestOperationManager内部是基于NSURLConnection实现的 AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; //2.发送请求 /* http://120.25.226.186:32812/login?username=ee&amp;pwd=ee&amp;type=JSON 第一个参数：NSString类型的请求路径，AFN内部会自动将该路径包装为一个url并创建请求对象 第二个参数：请求参数，以字典的方式传递，AFN内部会判断当前是POST请求还是GET请求，以选择直接拼接还是转换为NSData放到请求体中传递 第三个参数：请求成功之后回调Block 第四个参数：请求失败回调Block */ NSDictionary *param = @&#123; @"username":@"520it", @"pwd":@"520it" &#125;; //注意：字符串中不能包含空格 [manager GET:@"url字符串" parameters:param success:^(AFHTTPRequestOperation * _Nonnull operation, id _Nonnull responseObject) &#123; NSLog(@"请求成功---%@",responseObject); &#125; failure:^(AFHTTPRequestOperation * _Nonnull operation, NSError * _Nonnull error) &#123; NSLog(@"失败---%@",error); &#125;];&#125;-(void)get2&#123; //1.创建AFHTTPSessionManager管理者 //AFHTTPSessionManager内部是基于NSURLSession实现的 AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; //2.发送请求 NSDictionary *param = @&#123; @"username":@"520it", @"pwd":@"520it" &#125;; //注意：responseObject:请求成功返回的响应结果（AFN内部已经把响应体转换为OC对象，通常是字典或数组） [manager GET:@"url字符串" parameters:param success:^(NSURLSessionDataTask * _Nonnull task, id _Nonnull responseObject) &#123; NSLog(@"请求成功---%@",[responseObject class]); &#125; failure:^(NSURLSessionDataTask * _Nonnull task, NSError * _Nonnull error) &#123; NSLog(@"失败---%@",error); &#125;];&#125; 使用AFN下载文件1234567891011121314151617181920212223242526272829303132333435363738-(void)download&#123; //1.创建一个管理者 AFHTTPSessionManager *manage = [AFHTTPSessionManager manager]; //2.下载文件 /* 第一个参数：请求对象 第二个参数：下载进度 第三个参数：block回调，需要返回一个url地址，用来告诉AFN下载文件的目标地址 targetPath：AFN内部下载文件存储的地址，tmp文件夹下 response：请求的响应头 返回值：文件应该剪切到什么地方 第四个参数：block回调，当文件下载完成之后调用 response：响应头 filePath：文件存储在沙盒的地址 == 第三个参数中block的返回值 error：错误信息 */ //2.1 创建请求对象 NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:@"url字符串"]]; //2.2 创建下载进度，并监听 NSProgress *progress = nil; NSURLSessionDownloadTask *downloadTask = [manage downloadTaskWithRequest:request progress:&amp;progress destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) &#123; NSString *caches = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]; //拼接文件全路径 NSString *fullpath = [caches stringByAppendingPathComponent:response.suggestedFilename]; NSURL *filePathUrl = [NSURL fileURLWithPath:fullpath]; return filePathUrl; &#125; completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nonnull filePath, NSError * _Nonnull error) &#123; NSLog(@"文件下载完毕---%@",filePath); &#125;]; //2.3 使用KVO监听下载进度 [progress addObserver:self forKeyPath:@"completedUnitCount" options:NSKeyValueObservingOptionNew context:nil]; //3.启动任务 [downloadTask resume];&#125;//获取并计算当前文件的下载进度-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(NSProgress *)progress change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context&#123; NSLog(@"%zd--%zd--%f",progress.completedUnitCount,progress.totalUnitCount,1.0 * progress.completedUnitCount/progress.totalUnitCount);&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS网络编程--文件上传]]></title>
    <url>%2F2016%2F04%2F12%2FiOS%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[NSURLConnection实现文件上传 文件上传步骤1.确定请求路径2.根据URL创建一个可变的请求对象3.设置请求对象，修改请求方式为POST4.设置请求头，告诉服务器我们将要上传文件（Content-Type）5.设置请求体（在请求体中按照既定的格式拼接要上传的文件参数和非文件参数等数据） 拼接文件参数 拼接非文件参数 添加结尾标记 6.使用NSURLConnection sendAsync发送异步请求上传文件7.解析服务器返回的数据 文件上传设置请求体的数据格式 123456789101112131415//请求体拼接格式 //分隔符：----WebKitFormBoundaryhBDKBUWBHnAgvz9c //01.文件参数拼接格式 --分隔符 Content-Disposition:参数 Content-Type:参数 空行 文件参数 //02.非文件拼接参数 --分隔符 Content-Disposition:参数 空行 非文件的二进制数据 //03.结尾标识 --分隔符-- 文件上传相关代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859-(void)upload &#123; //1.确定请求路径 NSURL *url = [NSURL URLWithString:@&quot;URL字符串&quot;]; //2.创建一个可变的请求对象 NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; //3.设置请求方式为POST request.HTTPMethod = @&quot;POST&quot;; //4.设置请求头 NSString *filed = [NSString stringWithFormat:@&quot;multipart/form-data; boundary=%@&quot;,Kboundary]; [request setValue:filed forHTTPHeaderField:@&quot;Content-Type&quot;]; //5.设置请求体 NSMutableData *data = [NSMutableData data]; //5.1 文件参数 /* --分隔符 Content-Disposition:参数 Content-Type:参数 空行 文件参数 */ [data appendData:[[NSString stringWithFormat:@&quot;--%@&quot;,Kboundary] dataUsingEncoding:NSUTF8StringEncoding]]; [data appendData:KnewLine]; [data appendData:[@&quot;Content-Disposition: form-data; name=\&quot;file\&quot;; filename=\&quot;test.png\&quot;&quot; dataUsingEncoding:NSUTF8StringEncoding]];[data appendData:KnewLine]; [data appendData:[@&quot;Content-Type: image/png&quot; dataUsingEncoding:NSUTF8StringEncoding]];[data appendData:KnewLine]; [data appendData:KnewLine]; [data appendData:KnewLine]; UIImage *image = [UIImage imageNamed:@&quot;test&quot;]; NSData *imageData = UIImagePNGRepresentation(image); [data appendData:imageData]; [data appendData:KnewLine]; //5.2 非文件参数 /* --分隔符 Content-Disposition:参数 空行 非文件参数的二进制数据 */ [data appendData:[[NSString stringWithFormat:@&quot;--%@&quot;,Kboundary] dataUsingEncoding:NSUTF8StringEncoding]]; [data appendData:KnewLine]; [data appendData:[@&quot;Content-Disposition: form-data;name=\&quot;username\&quot;&quot; dataUsingEncoding:NSUTF8StringEncoding]];[data appendData:KnewLine]; [data appendData:KnewLine]; [data appendData:KnewLine]; NSData *nameData = [@&quot;wendingding&quot; dataUsingEncoding:NSUTF8StringEncoding]; [data appendData:nameData]; [data appendData:KnewLine];//5.3 结尾标识 //--分隔符-- [data appendData:[[NSString stringWithFormat:@&quot;--%@--&quot;,Kboundary] dataUsingEncoding:NSUTF8StringEncoding]]; [data appendData:KnewLine]; request.HTTPBody = data; //6.发送请求 [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * __nullable response, NSData * __nullable data, NSError * __nullable connectionError) &#123; //7.解析服务器返回的数据 NSLog(@&quot;%@&quot;,[NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]); &#125;]; &#125; 如何获得文件的MIMEType类型 直接对该对象发送一个异步网络请求，在响应头中通过response.MIMEType拿到文件的MIMEType类型 123456789101112131415//如果想要及时拿到该数据，那么可以发送一个同步请求-(NSString *)getMIMEType&#123; NSString *filePath = @&quot;文件所在路径&quot;;NSURLResponse *response = nil; [NSURLConnection sendSynchronousRequest:[NSURLRequest requestWithURL:[NSURL fileURLWithPath:filePath]] returningResponse:&amp;response error:nil]; return response.MIMEType;&#125;//对该文件发送一个异步请求，拿到文件的MIMEType-(void)MIMEType&#123; // NSString *file = @&quot;文件所在路径&quot;; [NSURLConnection sendAsynchronousRequest:[NSURLRequest requestWithURL:[NSURL fileURLWithPath:@&quot;/Users/文顶顶/Desktop/test.png&quot;]] queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * __nullable response, NSData * __nullable data, NSError * __nullable connectionError) &#123; // response.MIMEType NSLog(@&quot;%@&quot;,response.MIMEType); &#125;];&#125; 通过UTTypeCopyPreferredTagWithClass方法 123456789101112//注意：需要依赖于框架MobileCoreServices-(NSString *)mimeTypeForFileAtPath:(NSString *)path&#123; if (![[[NSFileManager alloc] init] fileExistsAtPath:path]) &#123; return nil; &#125; CFStringRef UTI = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, (__bridge CFStringRef)[path pathExtension], NULL); CFStringRef MIMEType = UTTypeCopyPreferredTagWithClass (UTI, kUTTagClassMIMEType); CFRelease(UTI); if (!MIMEType) &#123; return @&quot;application/octet-stream&quot;; &#125; return (__bridge NSString *)(MIMEType);&#125; NSURLSession实现文件上传 实现文件上传的方法 123456789 /*第一个参数：请求对象第二个参数：请求体（要上传的文件数据）block回调：NSData:响应体NSURLResponse：响应头NSError：请求的错误信息*/NSURLSessionUploadTask *uploadTask = [session uploadTaskWithRequest:request fromData:data completionHandler:^(NSData * __nullable data, NSURLResponse * __nullable response, NSError * __nullable error) 设置代理，在代理方法中监听文件上传进度 1234567891011/*调用该方法上传文件数据如果文件数据很大，那么该方法会被调用多次参数说明： totalBytesSent：已经上传的文件数据的大小 totalBytesExpectedToSend：文件的总大小*/-(void)URLSession:(nonnull NSURLSession *)session task:(nonnull NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend&#123; NSLog(@&quot;%.2f&quot;,1.0 * totalBytesSent/totalBytesExpectedToSend);&#125; 关于NSURLSessionConfiguration相关 作用：可以统一配置NSURLSession,如请求超时等 创建的方式和使用123456789101112131415161718//创建配置的三种方式+(NSURLSessionConfiguration *)defaultSessionConfiguration;+(NSURLSessionConfiguration *)ephemeralSessionConfiguration;+(NSURLSessionConfiguration *)backgroundSessionConfigurationWithIdentifier:(NSString *)identifier NS_AVAILABLE(10_10, 8_0);//统一配置NSURLSession-(NSURLSession *)session&#123; if (_session == nil) &#123; //创建NSURLSessionConfiguration NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration]; //设置请求超时为10秒钟 config.timeoutIntervalForRequest = 10; //在蜂窝网络情况下是否继续请求（上传或下载） config.allowsCellularAccess = NO; _session = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:[NSOperationQueue mainQueue]]; &#125; return _session;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS网络编程--文件下载]]></title>
    <url>%2F2016%2F04%2F12%2FiOS%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[使用NSURLConnection实现下载 1. 小文件下载 第一种方式（NSData） 12345678910//使用NSDta直接加载网络上的url资源（不考虑线程） -(void)dataDownload &#123; //1.确定资源路径 NSURL *url = [NSURL URLWithString:@&quot;http://tupian.qqjay.com/u/2013/1127/19_222949_14.jpg&quot;]; //2.根据URL加载对应的资源 NSData *data = [NSData dataWithContentsOfURL:url]; //3.转换并显示数据 UIImage *image = [UIImage imageWithData:data]; self.imageView.image = image; &#125; 第二种方式（NSURLConnection-sendAsync） 12345678910111213//使用NSURLConnection发送异步请求下载文件资源 -(void)connectDownload &#123; //1.确定请求路径 NSURL *url = [NSURL URLWithString:@&quot;http://tupian.qqjay.com/u/2013/1127/19_222949_14.jpg&quot;]; //2.创建请求对象 NSURLRequest *request = [NSURLRequest requestWithURL:url]; //3.使用NSURLConnection发送一个异步请求 [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) &#123; //4.拿到并处理数据 UIImage *image = [UIImage imageWithData:data]; self.imageView.image = image; &#125;]; &#125; 第三种方式（NSURLConnection-delegate） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//使用NSURLConnection设置代理发送异步请求的方式下载文件 -(void)connectionDelegateDownload &#123; //1.确定请求路径 NSURL *url = [NSURL URLWithString:@&quot;下载文件的URL地址&quot;]; //2.创建请求对象 NSURLRequest *request = [NSURLRequest requestWithURL:url]; //3.使用NSURLConnection设置代理并发送异步请求 [NSURLConnection connectionWithRequest:request delegate:self]; &#125;pragma mark--NSURLConnectionDataDelegate//当接收到服务器响应的时候调用，该方法只会调用一次-(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response&#123; //创建一个容器，用来接收服务器返回的数据 self.fileData = [NSMutableData data]; //获得当前要下载文件的总大小（通过响应头得到） NSHTTPURLResponse *res = (NSHTTPURLResponse *)response; self.totalLength = res.expectedContentLength; NSLog(@&quot;%zd&quot;,self.totalLength); //拿到服务器端推荐的文件名称 self.fileName = res.suggestedFilename;&#125;//当接收到服务器返回的数据时会调用//该方法可能会被调用多次-(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data&#123;// NSLog(@&quot;%s&quot;,__func__); //拼接每次下载的数据 [self.fileData appendData:data]; //计算当前下载进度并刷新UI显示 self.currentLength = self.fileData.length; NSLog(@&quot;%f&quot;,1.0* self.currentLength/self.totalLength); self.progressView.progress = 1.0* self.currentLength/self.totalLength;&#125;//当网络请求结束之后调用-(void)connectionDidFinishLoading:(NSURLConnection *)connection&#123; //文件下载完毕把接受到的文件数据写入到沙盒中保存 //1.确定要保存文件的全路径 //caches文件夹路径 NSString *caches = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]; NSString *fullPath = [caches stringByAppendingPathComponent:self.fileName]; //2.写数据到文件中 [self.fileData writeToFile:fullPath atomically:YES]; NSLog(@&quot;%@&quot;,fullPath);&#125;//当请求失败的时候调用该方法-(void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error&#123; NSLog(@&quot;%s&quot;,__func__);&#125; 2. 大文件下载 实现思路边接收数据边写文件以解决内存越来越大的问题 核心代码123456789101112131415161718192021222324252627282930//当接收到服务器响应的时候调用，该方法只会调用一次 -(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response &#123; //0.获得当前要下载文件的总大小（通过响应头得到） NSHTTPURLResponse *res = (NSHTTPURLResponse *)response; self.totalLength = res.expectedContentLength; NSLog(@&quot;%zd&quot;,self.totalLength); //创建一个新的文件，用来当接收到服务器返回数据的时候往该文件中写入数据 //1.获取文件管理者 NSFileManager *manager = [NSFileManager defaultManager]; //2.拼接文件的全路径 //caches文件夹路径 NSString *caches = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]; NSString *fullPath = [caches stringByAppendingPathComponent:res.suggestedFilename]; self.fullPath = fullPath; //3.创建一个空的文件 [manager createFileAtPath:fullPath contents:nil attributes:nil]; &#125; //当接收到服务器返回的数据时会调用 //该方法可能会被调用多次 -(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123; //1.创建一个用来向文件中写数据的文件句柄 //注意当下载完成之后，该文件句柄需要关闭，调用closeFile方法 NSFileHandle *handle = [NSFileHandle fileHandleForWritingAtPath:self.fullPath]; //2.设置写数据的位置(追加) [handle seekToEndOfFile]; //3.写数据 [handle writeData:data]; //4.计算当前文件的下载进度 self.currentLength += data.length; NSLog(@&quot;%f&quot;,1.0* self.currentLength/self.totalLength); self.progressView.progress = 1.0* self.currentLength/self.totalLength;&#125; 3. 大文件断点续传 实现思路在下载文件的时候不再是整块的从头开始下载，而是看当前文件已经下载到哪个地方，然后从该地方接着往后面下载。可以通过在请求对象中设置请求头实现。 解决方案（设置请求头） 123456789101112//2.创建请求对象 NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; //2.1 设置下载文件的某一部分 // 只要设置HTTP请求头的Range属性, 就可以实现从指定位置开始下载 /* 表示头500个字节：Range: bytes=0-499 表示第二个500字节：Range: bytes=500-999 表示最后500个字节：Range: bytes=-500 表示500字节以后的范围：Range: bytes=500- */ NSString *range = [NSString stringWithFormat:@&quot;bytes=%zd-&quot;,self.currentLength]; [request setValue:range forHTTPHeaderField:@&quot;Range&quot;]; 注意点（下载进度并判断是否需要重新创建文件） 12345678//获得当前要下载文件的总大小（通过响应头得到） NSHTTPURLResponse *res = (NSHTTPURLResponse *)response; //注意点：res.expectedContentLength获得是本次请求要下载的文件的大小（并非是完整的文件的大小） //因此：文件的总大小 == 本次要下载的文件大小+已经下载的文件的大小 self.totalLength = res.expectedContentLength + self.currentLength; NSLog(@&quot;----------------------------%zd&quot;,self.totalLength); //0 判断当前是否已经下载过，如果当前文件已经存在，那么直接返回 if (self.currentLength &gt;0) &#123; return; &#125; 输出流 使用输出流也可以实现和NSFileHandle相同的功能 如何使用 123456789101112131415161718192021//1.创建一个数据输出流/*第一个参数：二进制的流数据要写入到哪里第二个参数：采用什么样的方式写入流数据，如果YES则表示追加，如果是NO则表示覆盖*/NSOutputStream *stream = [NSOutputStream outputStreamToFileAtPath:fullPath append:YES];//只要调用了该方法就会往文件中写数据//如果文件不存在，那么会自动的创建一个[stream open];self.stream = stream;//2.当接收到数据的时候写数据//使用输出流写数据/*第一个参数：要写入的二进制数据第二个参数：要写入的数据的大小*/[self.stream write:data.bytes maxLength:data.length];//3.当文件下载完毕的时候关闭输出流//关闭输出流[self.stream close];self.stream = nil; 使用多线程下载文件的思路 01 开启多条线程，每条线程都只下载文件的一部分（通过设置请求头中的Range来实现） 02 创建一个和需要下载文件大小一致的文件，判断当前是那个线程，根据当前的线程来判断下载的数据应该写入到文件中的哪个位置。（假设开5条线程来下载10M的文件，那么线程1下载0-2M，线程2下载2-4M一次类推，当接收到服务器返回的数据之后应该先判断当前线程是哪个线程，假如当前线程是线程2，那么在写数据的时候就从文件的2M位置开始写入） 03 代码相关：使用NSFileHandle这个类的seekToFileOfSet方法，来向文件中特定的位置写入数据。 04 技术相关a.每个线程通过设置请求头下载文件中的某一个部分b.通过NSFileHandle向文件中的指定位置写数据 使用NSURLSession实现下载 1. NSURLSession下载文件-代理 创建NSURLSession对象，设置代理（默认配置） 1234567//1.创建NSURLSession,并设置代理 /* 第一个参数：session对象的全局配置设置，一般使用默认配置就可以 第二个参数：谁成为session对象的代理 第三个参数：代理方法在哪个队列中执行（在哪个线程中调用）,如果是主队列那么在主线程中执行，如果是非主队列，那么在子线程中执行 */ NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]]; 根据Session对象创建一个NSURLSessionDataTask任务（post和get选择） 1234//创建taskNSURL *url = [NSURL URLWithString:@&quot;http://tupian.qqjay.com/u/2013/1127/19_222949_14.jpg&quot;];//注意：如果要发送POST请求，那么请使用dataTaskWithRequest,设置一些请求头信息NSURLSessionDataTask *dataTask = [session dataTaskWithURL:url]; 执行任务（其它方法，如暂停、取消等） 12345//启动task//[dataTask resume];//其它方法，如取消任务，暂停任务等//[dataTask cancel];//[dataTask suspend]; 遵守代理协议，实现代理方法（3个相关的代理方法） 12345678910111213141516/* 1.当接收到服务器响应的时候调用 session：发送请求的session对象 dataTask：根据NSURLSession创建的task任务 response:服务器响应信息（响应头） completionHandler：通过该block回调，告诉服务器端是否接收返回的数据 */-(void)URLSession:(nonnull NSURLSession *)session dataTask:(nonnull NSURLSessionDataTask *)dataTask didReceiveResponse:(nonnull NSURLResponse *)response completionHandler:(nonnull void (^)(NSURLSessionResponseDisposition))completionHandler/*2.当接收到服务器返回的数据时调用 该方法可能会被调用多次 */-(void)URLSession:(nonnull NSURLSession *)session dataTask:(nonnull NSURLSessionDataTask *)dataTask didReceiveData:(nonnull NSData *)data/* 3.当请求完成之后调用该方法 不论是请求成功还是请求失败都调用该方法，如果请求失败，那么error对象有值，否则那么error对象为空 */-(void)URLSession:(nonnull NSURLSession *)session task:(nonnull NSURLSessionTask *)task didCompleteWithError:(nullable NSError *)error 当接收到服务器响应的时候，告诉服务器接收数据（调用block） 123456789//默认情况下，当接收到服务器响应之后，服务器认为客户端不需要接收数据，所以后面的代理方法不会调用 //如果需要继续接收服务器返回的数据，那么需要调用block,并传入对应的策略 /* NSURLSessionResponseCancel = 0, 取消任务 NSURLSessionResponseAllow = 1, 接收任务 NSURLSessionResponseBecomeDownload = 2, 转变成下载 NSURLSessionResponseBecomeStream NS_ENUM_AVAILABLE(10_11, 9_0) = 3, 转变成流 */ completionHandler(NSURLSessionResponseAllow); ###2. NSURLSessionDownloadTask实现大文件下载 使用NSURLSession和NSURLSessionDownload可以很方便的实现文件下载操作 123456789/* 第一个参数：要下载文件的url路径 第二个参数：当接收完服务器返回的数据之后调用该block location:下载的文件的保存地址（默认是存储在沙盒中tmp文件夹下面，随时会被删除） response：服务器响应信息，响应头 error：该请求的错误信息 */ //说明：downloadTaskWithURL方法已经实现了在下载文件数据的过程中边下载文件数据，边写入到沙盒文件的操作 NSURLSessionDownloadTask *downloadTask = [session downloadTaskWithURL:url completionHandler:^(NSURL * __nullable location, NSURLResponse * __nullable response, NSError * __nullable error) downloadTaskWithURL内部默认已经实现了变下载边写入操作，所以不用开发人员担心内存问题 文件下载后默认保存在tmp文件目录，需要开发人员手动的剪切到合适的沙盒目录 缺点：没有办法监控下载进度 ###3. 使用NSURLSessionDownloadTask实现大文件下载-监听下载进度 创建NSURLSession并设置代理，通过NSURLSessionDownloadTask并以代理的方式来完成大文件的下载 1234567//1.创建NSULRSession,设置代理self.session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];//2.创建taskNSURL *url = [NSURL URLWithString:@&quot;URL字符串&quot;];self.downloadTask = [self.session downloadTaskWithURL:url];//3.执行task[self.downloadTask resume]; 常用代理方法的说明 1234567891011121314151617181920212223/* 1.当接收到下载数据的时候调用,可以在该方法中监听文件下载的进度 该方法会被调用多次 totalBytesWritten:已经写入到文件中的数据大小 totalBytesExpectedToWrite:目前文件的总大小 bytesWritten:本次下载的文件数据大小 */-(void)URLSession:(nonnull NSURLSession *)session downloadTask:(nonnull NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite/* 2.恢复下载的时候调用该方法 fileOffset:恢复之后，要从文件的什么地方开发下载 expectedTotalBytes：该文件数据的总大小 */-(void)URLSession:(nonnull NSURLSession *)session downloadTask:(nonnull NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes/* 3.下载完成之后调用该方法 */-(void)URLSession:(nonnull NSURLSession *)session downloadTask:(nonnull NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(nonnull NSURL *)location/* 4.请求完成之后调用 如果请求失败，那么error有值 */-(void)URLSession:(nonnull NSURLSession *)session task:(nonnull NSURLSessionTask *)task didCompleteWithError:(nullable NSError *)error 实现断点下载相关代码 123456789//如果任务，取消了那么以后就不能恢复了// [self.downloadTask cancel];//如果采取这种方式来取消任务，那么该方法会通过resumeData保存当前文件的下载信息//只要有了这份信息，以后就可以通过这些信息来恢复下载[self.downloadTask cancelByProducingResumeData:^(NSData * __nullable resumeData) &#123; self.resumeData = resumeData;&#125;];//继续下载//首先通过之前保存的resumeData信息，创建一个下载任务self.downloadTask = [self.session downloadTaskWithResumeData:self.resumeData]; [self.downloadTask resume]; 计算当前下载进度 12//获取文件下载进度self.progress.progress = 1.0 * totalBytesWritten/totalBytesExpectedToWrite; 局限性 如果用户点击暂停之后退出程序，那么需要把恢复下载的数据写一份到沙盒，代码复杂度更高 如果用户在下载中途未保存恢复下载数据即退出程序，则不具备可操作性 ###4. 使用NSURLSessionDataTask实现大文件离线断点下载（完整） 关于NSOutputStream的使用 123456789//1. 创建一个输入流,数据追加到文件的屁股上//把数据写入到指定的文件地址，如果当前文件不存在，则会自动创建NSOutputStream *stream = [[NSOutputStream alloc]initWithURL:[NSURL fileURLWithPath:[self fullPath]] append:YES];//2. 打开流[stream open];//3. 写入流数据[stream write:data.bytes maxLength:data.length];//4.当不需要的时候应该关闭流[stream close]; 关于网络请求请求头的设置（可以设置请求下载文件的某一部分） 123456789101112//1. 设置请求对象//1.1 创建请求路径NSURL *url = [NSURL URLWithString:@&quot;URL字符串&quot;];//1.2 创建可变请求对象NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];//1.3 拿到当前文件的残留数据大小self.currentContentLength = [self FileSize];//1.4 告诉服务器从哪个地方开始下载文件数据NSString *range = [NSString stringWithFormat:@&quot;bytes=%zd-&quot;,self.currentContentLength];NSLog(@&quot;%@&quot;,range);//1.5 设置请求头[request setValue:range forHTTPHeaderField:@&quot;Range&quot;]; NSURLSession对象的释放 1234567-(void)dealloc&#123; //在最后的时候应该把session释放，以免造成内存泄露 // NSURLSession设置过代理后，需要在最后（比如控制器销毁的时候）调用session的invalidateAndCancel或者resetWithCompletionHandler，才不会有内存泄露 // [self.session invalidateAndCancel]; [self.session resetWithCompletionHandler:^&#123; NSLog(@&quot;释放---&quot;); &#125;];&#125; 优化部分 关于文件下载进度的实时更新 方法的独立与抽取]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS网络编程--基础使用]]></title>
    <url>%2F2016%2F04%2F12%2FiOS%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[iOS中发送http请求的方案 苹果原生 NSURLConnection 03年推出的古老技术 NSURLSession 13年推出iOS7之后，以取代NSURLConnection CFNetwork 底层技术、C语言的 第三方框架 ASIHttpRequest AFNetworking MKNetworkKit NSURLConnection使用 NSURLConnection同步get请求 步骤 设置请求路径 创建请求对象（默认是GET请求，且已经默认包含了请求头） 使用NSURLConnection sendsync方法发送网络请求 接收到服务器的响应后，解析响应体 代码12345678910111213141516//1.确定请求路径 NSURL *url = [NSURL URLWithString:@&quot;URLString(发送请求的地址路径)&quot;]; //2.创建一个请求对象NSURLRequest *request = [NSURLRequest requestWithURL:url];//3.把请求发送给服务器//sendSynchronousRequest 阻塞式的方法，会卡住线程NSHTTPURLResponse *response = nil;NSError *error = nil;/* 第一个参数：请求对象 第二个参数：响应头信息，当该方法执行完毕之后，该参数被赋值 第三个参数：错误信息，如果请求失败，则error有值 */ //该方法是阻塞式的，会卡住线程NSData *data = [NSURLConnection sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error];//4.解析服务器返回的数据NSString *str = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]; NSURLConnection异步请求（get-sendAsync）该方法不会卡住线程，网络请求任务是异步执行的 1234567891011121314151617//1.确定请求路径 NSURL *url = [NSURL URLWithString:@&quot;URLString(发送请求的地址路径)&quot;]; //2.创建一个请求对象 NSURLRequest *request = [NSURLRequest requestWithURL:url]; //3.把请求发送给服务器,发送一个异步请求 /* 第一个参数：请求对象 第二个参数：回调方法在哪个线程中执行，如果是主队列则block在主线程中执行，非主队列则在子线程中执行 第三个参数：completionHandlerBlock块：接受到响应的时候执行该block中的代码 response：响应头信息 data：响应体 connectionError：错误信息，如果请求失败，那么该参数有值 */ [NSURLConnection sendAsynchronousRequest:request queue:[[NSOperationQueue alloc]init] completionHandler:^(NSURLResponse * __nullable response, NSData * __nullable data, NSError * __nullable connectionError) &#123; //4.解析服务器返回的数据 NSString *str = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]; //转换并打印响应头信息 NSHTTPURLResponse *r = (NSHTTPURLResponse *)response; NSLog(@&quot;--%zd---%@--&quot;,r.statusCode,r.allHeaderFields); &#125;]; NSURLConnection异步请求（get-代理） 步骤 确定请求路径 创建请求对象 创建NSURLConnection对象并设置代理 遵守NSURLConnectionDataDelegate协议，并实现相应的代理方法 在代理方法中监听网络请求的响应 设置代理的几种方式 123456789101112131415161718/* 设置代理的第一种方式：自动发送网络请求 [[NSURLConnection alloc]initWithRequest:request delegate:self]; *//* 设置代理的第二种方式： 第一个参数：请求对象 第二个参数：谁成为NSURLConnetion对象的代理第三个参数：是否马上发送网络请求，如果该值为YES则立刻发送，如果为NO则不会发送网路请求 NSURLConnection *conn = [[NSURLConnection alloc]initWithRequest:request delegate:self startImmediately:NO]; //调用该方法控制网络请求的发送 //注意该方法内部会自动的把connect添加到当前线程的RunLoop中在默认模式下执行[conn start]; *///设置代理的第三种方式：使用类方法设置代理，会自动发送网络请求NSURLConnection *conn = [NSURLConnection connectionWithRequest:request delegate:self];//取消网络请求//[conn cancel]; 相关代理方法 123456789101112131415161718192021/* 1.当接收到服务器响应的时候调用 第一个参数connection：监听的是哪个NSURLConnection对象 第二个参数response：接收到的服务器返回的响应头信息 */ -(void)connection:(nonnull NSURLConnection *)connection didReceiveResponse:(nonnull NSURLResponse *)response /* 2.当接收到数据的时候调用，该方法会被调用多次 第一个参数connection：监听的是哪个NSURLConnection对象 第二个参数data：本次接收到的服务端返回的二进制数据（可能是片段） */ -(void)connection:(nonnull NSURLConnection *)connection didReceiveData:(nonnull NSData *)data /* 3.当服务端返回的数据接收完毕之后会调用 通常在该方法中解析服务器返回的数据 */ -(void)connectionDidFinishLoading:(nonnull NSURLConnection *)connection /*4.当请求错误的时候调用（比如请求超时） 第一个参数connection：NSURLConnection对象 第二个参数：网络请求的错误信息，如果请求失败，则error有值 */ -(void)connection:(nonnull NSURLConnection *)connection didFailWithError:(nonnull NSError *)error 如何控制代理方法在哪个线程调用* 123//说明：默认情况下，代理方法会在主线程中进行调用（为了方便开发者拿到数据后处理一些刷新UI的操作不需要考虑到线程间通信） //设置代理方法的执行队列 [connect setDelegateQueue:[[NSOperationQueue alloc]init]]; 开子线程发送网络请求的注意点，适用于自动发送网络请求模式 12345678910111213141516171819202122//使用GCD开启一个子线程来发送网络请求 dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; //使用非自动发送网络请求模式,发送请求OK /* //创建NSURLConnection对象，设置代理，暂不发送 NSURLConnection *connect = [[NSURLConnection alloc]initWithRequest:request delegate:self startImmediately:NO]; //设置代理方法的执行队列 [connect setDelegateQueue:[[NSOperationQueue alloc]init]]; //调用start发送网络请求 [connect start]; */ //使用自动发送网络请求模式，发送请求失败（需要改造代码） //WHY? /*01 网络请求发送和数据接收是否成功，和一些因素相关，比如客户端的网速、服务器端的查询速度等等。 02 而在子线程中创建的NSURLConnection对象是一个临时变量，当请求发送完成之后就被释放了，所以这个时候它的代理方法不会调用用。 03 为什么使用非自动发送网络请求模式是OK的。 因为在该模式中，调用了start来开始发送网络请求，该方法内部会自动将当前的connect作为一个Source添加到当前线程所在的Runloop中,如果当前线程是子线程（即当前线程的runloop并未创建），那么该方法内部会默认先创建当前线程的Runloop,设置在runloop的默认模式下运行。 此时runloop会对这个Connect对象进行强引用，保证了代理方法被调用的前提 */ NSURLConnection *connect = [[NSURLConnection alloc]initWithRequest:request delegate:self]; [connect setDelegateQueue:[[NSOperationQueue alloc]init]]; //创建当前线程的runloop，并开启runloop [[NSRunLoop currentRunLoop] run]; &#125;); 其他知识 1234501 关于消息弹窗第三方框架的使用 SVProgressHUD 02 字符串截取相关方法 -(NSRange)rangeOfString:(NSString *)searchString; -(NSString *)substringWithRange:(NSRange)range; NSURLConnection发送POST请求 发送POST请求步骤 确定URL路径 创建请求对象（可变对象） 修改请求对象的方法为POST，设置请求体（Data） 发送一个异步请求 补充：设置请求超时，处理错误信息，设置请求头（如获取客户端的版本等等,请求头是可设置可不设置的） 代码12345678910111213141516171819202122//1.确定请求路径 NSURL *url = [NSURL URLWithString:@&quot;请求路径字符串&quot;];//2.创建请求对象NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];//2.1更改请求方法request.HTTPMethod = @&quot;POST&quot;;//2.2设置请求体request.HTTPBody = [@&quot;username=111&amp;pwd=222&quot; dataUsingEncoding:NSUTF8StringEncoding];//2.3请求超时request.timeoutInterval = 5;//2.4设置请求头[request setValue:@&quot;ios 9.0&quot; forHTTPHeaderField:@&quot;User-Agent&quot;];//3.发送请求[NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * __nullable response, NSData * __nullable data, NSError * __nullable connectionError) &#123; //4.解析服务器返回的数据 if (connectionError) &#123; NSLog(@&quot;--请求失败-&quot;); &#125;else &#123; NSLog(@&quot;%@&quot;,[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]); &#125;&#125;]; NSURLSession使用 使用步骤 使用NSURLSession创建task，然后执行task 关于task NSURLSessionTask是一个抽象类，本身不能使用，只能使用它的子类 NSURLSessionDataTask\NSURLSessionUploadTask\NSURLSessionDownloadTask 发送get请求 1234567891011121314151617181920212223//1.创建NSURLSession对象（可以获取单例对象） NSURLSession *session = [NSURLSession sharedSession]; //2.根据NSURLSession对象创建一个Task NSURL *url = [NSURL URLWithString:@&quot;URL字符串&quot;]; NSURLRequest *request = [NSURLRequest requestWithURL:url]; //方法参数说明 /* 注意：该block是在子线程中调用的，如果拿到数据之后要做一些UI刷新操作，那么需要回到主线程刷新 第一个参数：需要发送的请求对象 block:当请求结束拿到服务器响应的数据时调用block block-NSData:该请求的响应体 block-NSURLResponse:存放本次请求的响应信息，响应头，真实类型为NSHTTPURLResponse block-NSErroe:请求错误信息 */ NSURLSessionDataTask * dataTask = [session dataTaskWithRequest:request completionHandler:^(NSData * __nullable data, NSURLResponse * __nullable response, NSError * __nullable error) &#123; //拿到响应头信息 NSHTTPURLResponse *res = (NSHTTPURLResponse *)response; //4.解析拿到的响应数据 NSLog(@&quot;%@\n%@&quot;,[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding],res.allHeaderFields); &#125;]; //3.执行Task //注意：刚创建出来的task默认是挂起状态的，需要调用该方法来启动任务（执行任务） [dataTask resume]; 发送get请求的第二种方式 12345678910//注意：该方法内部默认会把URL对象包装成一个NSURLRequest对象（默认是GET请求） //方法参数说明 /* //第一个参数：发送请求的URL地址 //block:当请求结束拿到服务器响应的数据时调用block //block-NSData:该请求的响应体 //block-NSURLResponse:存放本次请求的响应信息，响应头，真实类型为NSHTTPURLResponse //block-NSErroe:请求错误信息 */ -(nullable NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSData * __nullable data, NSURLResponse * __nullable response, NSError * __nullable error))completionHandler; 发送post请求 12345678910111213141516//1.创建NSURLSession对象（可以获取单例对象） NSURLSession *session = [NSURLSession sharedSession]; //2.根据NSURLSession对象创建一个Task NSURL *url = [NSURL URLWithString:@&quot;URL字符串&quot;]; //创建一个请求对象，并这是请求方法为POST，把参数放在请求体中传递 NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; request.HTTPMethod = @&quot;POST&quot;; request.HTTPBody = [@&quot;username=111&amp;pwd=222&amp;type=JSON&quot; dataUsingEncoding:NSUTF8StringEncoding]; NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request completionHandler:^(NSData * __nullable data, NSURLResponse * __nullable response, NSError * __nullable error) &#123; //拿到响应头信息 NSHTTPURLResponse *res = (NSHTTPURLResponse *)response; //解析拿到的响应数据 NSLog(@&quot;%@\n%@&quot;,[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding],res.allHeaderFields); &#125;]; //3.执行Task //注意：刚创建出来的task默认是挂起状态的，需要调用该方法来启动任务（执行任务） [dataTask resume];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS之数据解析]]></title>
    <url>%2F2016%2F04%2F12%2FiOS%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[iOS开发中，几乎只要是与网络相关的应用，都离不开对网络数据的解析与应用。一般来讲，我们会从网络获取XML或者Json格式的数据，这些数据有着特定的数据结构，必须对其进行解析，得到我们可以处理的数据。所谓“解析”，就是从事先规定好的格式串中提取数据。解析的前提是数据的提供方与获取方提前约定好格式，数据提供方按照格式提供数据，数据获取方按照格式获取数据。 JSON解析JSON是一种轻量级的数据格式，一般用于数据交互。服务器返回给客户端的数据，一般都是JSON格式或者XML格式（文件下载除外） 相关说明 JSON的格式很像OC中的字典和数组 标准JSON格式key必须是双引号 JSON解析方案 第三方框架 JSONKit\SBJSON\TouchJSON 苹果原生（NSJSONSerialization） JSON解析相关代码json数据-&gt;OC对象1234567891011121314151617181920//把json数据转换为OC对象 -(void)jsonToOC &#123; //1. 确定url路径 NSURL *url = [NSURL URLWithString:@"URL字符串"]; //2.创建一个请求对象 NSURLRequest *request = [NSURLRequest requestWithURL:url]; //3.使用NSURLConnection发送一个异步请求 [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) &#123; //4.当接收到服务器响应的数据后，解析数据(JSON---&gt;OC) /* 第一个参数：要解析的JSON数据，是NSData类型也就是二进制数据 第二个参数: 解析JSON的可选配置参数 NSJSONReadingMutableContainers 解析出来的字典和数组是可变的 NSJSONReadingMutableLeaves 解析出来的对象中的字符串是可变的 iOS7以后有问题 NSJSONReadingAllowFragments 被解析的JSON数据如果既不是字典也不是数组, 那么就必须使用这个 */ NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]; NSLog(@"%@",dict); &#125;];&#125; OC对象-&gt;JSON对象1234567891011121314151617181920212223242526//1.要转换成JSON数据的OC对象*这里是一个字典NSDictionary *dictM = @&#123;@"name":@"flame", @"age":@20, @"height":@1.80 &#125;;//2.OC-&gt;JSON/* 注意：可以通过+ (BOOL)isValidJSONObject:(id)obj;方法判断当前OC对象能否转换为JSON数据 具体限制： 1.obj 是NSArray 或 NSDictionay 以及他们派生出来的子类 2.obj 包含的所有对象是NSString,NSNumber,NSArray,NSDictionary 或NSNull 3.字典中所有的key必须是NSString类型的 4.NSNumber的对象不能是NaN或无穷大 *//* 第一个参数：要转换成JSON数据的OC对象，这里为一个字典 第二个参数：NSJSONWritingPrettyPrinted对转换之后的JSON对象进行排版，无意义 */NSData *data = [NSJSONSerialization dataWithJSONObject:dictM options:NSJSONWritingPrettyPrinted error:nil];//3.打印查看Data是否有值/* 第一个参数：要转换为String的二进制数据 第二个参数：编码方式，通常采用NSUTF8StringEncoding */NSString *strM = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];NSLog(@"%@",strM); OC对象和JSON数据格式之间的一一对应关系1234567891011121314151617181920//OC对象和JSON数据之间的一一对应关系-(void)oCWithJSON&#123; //JSON的各种数据格式 //NSString *test = @"\"flame\""; //NSString *test = @"true"; NSString *test = @"&#123;\"name\":\"flame\"&#125;"; //把JSON数据-&gt;OC对象,以便查看他们之间的一一对应关系 //注意点：被解析的JSON数据如果既不是字典也不是数组（比如是NSString）, 那么就必须使用这 NSJSONReadingAllowFragments id obj = [NSJSONSerialization JSONObjectWithData:[test dataUsingEncoding:NSUTF8StringEncoding] options:NSJSONReadingAllowFragments error:nil]; NSLog(@"%@", [obj class]); /* JSON数据格式和OC对象的一一对应关系 &#123;&#125; -&gt; 字典 [] -&gt; 数组 "" -&gt; 字符串 10/10.1 -&gt; NSNumber true/false -&gt; NSNumber null -&gt; NSNull */&#125; 如何查看复杂的JSON数据方法一： 在线格式化http://tool.oschina.net/codeformat/json方法二： 把解析后的数据写plist文件，通过plist文件可以直观的查看JSON的层次结构。[dictM writeToFile:@”文件路径/文件名.plist” atomically:YES]; 字典转模型框架 相关框架 Mantle 需要继承自MTModel JSONModel 需要继承自JSONModel MJExtension 不需要继承，无代码侵入性 自己设计和选择框架时需要注意的问题 侵入性 易用性，是否容易上手 扩展性，很容易给这个框架增加新的功能 XML解析XML简单介绍XML：可扩展标记语言http://baike.baidu.com/link?url=TbqIa8egIx6fbzxIPnajB253ae80Nli9O7sLob2LW9zt-lN1WKxuhfV5srC-lyaJpBgQXezNbHN8-QDmMY46dqQSI9SfOrzgKxB8GXCuhtmmoC1gpkqmJ1Z1PhWgV_TD XML解析XML解析的两种方式 SAX:从根元素开始，按顺序一个元素一个元素的往下解析，可用于解析大、小文件 DOM:一次性将整个XML文档加载到内存中，适合较小的文件 解析XML的工具 苹果原生NSXMLParser:使用SAX方式解析，使用简单 第三方框架 libxml2:纯C语言的，默认包含在iOS SDK中，同时支持DOM和SAX的方式解析 GDataXML:采用DOM方式解析，该框架由Google开发，是基于xml2的 XML解析代码使用NSXMLParser解析XML步骤和代理方法 1234567//解析步骤：//4.1 创建一个解析器NSXMLParser *parser = [[NSXMLParser alloc]initWithData:data];//4.2 设置代理parser.delegate = self;//4.3 开始解析[parser parse]; 12345678910111213//1.开始解析XML文档-(void)parserDidStartDocument:(nonnull NSXMLParser *)parser//2.开始解析XML中某个元素的时候调用，比如&lt;video&gt;-(void)parser:(nonnull NSXMLParser *)parser didStartElement:(nonnull NSString *)elementName namespaceURI:(nullable NSString *)namespaceURI qualifiedName:(nullable NSString *)qName attributes:(nonnull NSDictionary&lt;NSString *,NSString *&gt; *)attributeDict&#123; if ([elementName isEqualToString:@"videos"]) &#123; return; &#125; //字典转模型 TYVideo *video = [TYVideo objectWithKeyValues:attributeDict]; [self.videos addObject:video];&#125;//3.当某个元素解析完成之后调用，比如&lt;/video&gt;-(void)parser:(nonnull NSXMLParser *)parser didEndElement:(nonnull NSString *)elementName namespaceURI:(nullable NSString *)namespaceURI qualifiedName:(nullable NSString *)qName//4.XML文档解析结束-(void)parserDidEndDocument:(nonnull NSXMLParser *)parser 使用GDataParser解析XML的步骤和方法 123456789101112131415161718//配置环境// 1 先导入框架，然后按照框架使用注释配置环境// 2 GDataXML框架是MRC的，所以还需要告诉编译器以MRC的方式处理GDataXML的代码//加载XML文档（使用的是DOM的方式一口气把整个XML文档都吞下）GDataXMLDocument *doc = [[GDataXMLDocument alloc]initWithData:data options:kNilOptions error:nil];//获取XML文档的根元素，根据根元素取出XML中的每个子元素 NSArray * elements = [doc.rootElement elementsForName:@"video"];//取出每个子元素的属性并转换为模型for (GDataXMLElement *ele in elements) &#123; TYVideo *video = [[TYVideo alloc]init]; video.name = [ele attributeForName:@"name"].stringValue; video.length = [ele attributeForName:@"length"].stringValue.integerValue; video.url = [ele attributeForName:@"url"].stringValue; video.image = [ele attributeForName:@"image"].stringValue; video.ID = [ele attributeForName:@"id"].stringValue; //把转换好的模型添加到tableView的数据源self.videos数组中 [self.videos addObject:video];&#125; 多值参数和中文输出问题多值参数如何设置请求路径1234567891011121314/*如果一个参数对应着多个值，那么直接按照"参数=值&amp;参数=值"的方式拼接 */-(void)test&#123; //1.确定 URL NSURL *url = [NSURL URLWithString:@"URL字符串"]; //2.创建请求对象 NSURLRequest *request = [NSURLRequest requestWithURL:url]; //3.发送请求 [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) &#123; //4.解析 NSLog(@"%@",[NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]); &#125;];&#125; 如何解决字典和数组中输出乱码的问题给字典和数组添加一个分类，重写descriptionWithLocale方法，在该方法中拼接元素格式化输出。 1-(nonnull NSString *)descriptionWithLocale:(nullable id)locale]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS之Runloop]]></title>
    <url>%2F2016%2F04%2F11%2FiOS%E4%B9%8BRunloop%2F</url>
    <content type="text"><![CDATA[Runloop，正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。如果没有Runloop,那么程序一启动就会退出，什么事情都做不了；如果有了Runloop，那么相当于在内部有一个死循环，能够保证程序的持续运行。 Runloop的作用保持程序的持续运行(ios程序为什么能一直活着不会死) 处理app中的各种事件（比如触摸事件、定时器事件【NSTimer】、selector事件【选择器·performSelector···】） 节省CPU资源，提高程序性能，有事情就做事情，没事情就休息 main函数中的Runloop ： 在UIApplication函数内部就启动了一个Runloop 该函数返回一个int类型的值 这个默认启动的Runloop是跟主线程相关联的 Runloop对象在iOS开发中有两套api来访问Runloop foundation框架【NSRunloop】 core foundation框架【CFRunloopRef】 NSRunLoop和CFRunLoopRef都代表着RunLoop对象,它们是等价的，可以互相转换 NSRunLoop是基于CFRunLoopRef的一层OC包装，所以要了解RunLoop内部结构，需要多研究CFRunLoopRef层面的API（Core Foundation层面） Runloop与线程Runloop和线程的关系：一个Runloop对应着一条唯一的线程。为了让子线程不死，可以给这条子线程开启一个Runloop Runloop的创建：主线程Runloop已经创建好了，子线程的runloop需要手动创建 Runloop的生命周期：在第一次获取时创建，在线程结束时销毁 如何获取Runloop对象获得当前Runloop对象 1234//01 NSRunloop NSRunLoop * runloop1 = [NSRunLoop currentRunLoop]; //02 CFRunLoopRef CFRunLoopRef runloop2 = CFRunLoopGetCurrent(); 拿到当前应用程序的主Runloop（主线程对应的Runloop） 1234//01 NSRunloop NSRunLoop * runloop1 = [NSRunLoop mainRunLoop]; //02 CFRunLoopRef CFRunLoopRef runloop2 = CFRunLoopGetMain(); 注意点：开一个子线程创建runloop,不是通过alloc init方法创建，而是直接通过调用currentRunLoop方法来创建，它本身是一个懒加载的。 在子线程中，如果不主动获取Runloop的话，那么子线程内部是不会创建Runloop的。可以下载CFRunloopRef的源码，搜索_CFRunloopGet0,查看代码。 Runloop对象是利用字典来进行存储，而且key是对应的线程Value为该线程对应的Runloop。 Runloop相关类Runloop运行图 五个相关的类： CFRunloopRef CFRunloopModeRef【Runloop的运行模式】 CFRunloopSourceRef【Runloop要处理的事件源】 CFRunloopTimerRef【Timer事件】 CFRunloopObserverRef【Runloop的观察者（监听者）】 Runloop和相关类之间的关系图 Runloop要想跑起来，它的内部必须要有一个mode,这个mode里面必须有source\observer\timer，至少要有其中的一个。 CFRunloopModeRef CFRunloopModeRef代表着Runloop的运行模式 一个Runloop中可以有多个mode,一个mode里面又可以有多个source\observer\timer等等 每次runloop启动的时候，只能指定一个mode,这个mode被称为该Runloop的当前mode 如果需要切换mode,只能先退出当前Runloop,再重新指定一个mode进入 这样做主要是为了分割不同组的定时器等，让他们相互之间不受影响 系统默认注册了5个mode kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行 UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响 UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用 GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到 kCFRunLoopCommonModes: 这是一个占位用的Mode，不是一种真正的Mode CFRunloopTimerRef runloop一启动就会选中一种模式，当选中了一种模式之后其它的模式就都不管用。一个mode里面可以添加多个NSTimer,也就是说以后当创建NSTimer的时候，可以指定它是在什么模式下运行的。 它是基于时间的触发器，说直白点那就是时间到了我就触发一个事件，触发一个操作。基本上说的就是NSTimer 相关代码： 1234//NSTimer 调用了scheduledTimer方法，那么会自动添加到当前的runloop里面去，而且runloop的运行模式kCFRunLoopDefaultModeNSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];//更改模式[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; 12345678NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];//定时器添加到UITrackingRunLoopMode模式，一旦runloop切换模式，那么定时器就不工作[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];//定时器添加到NSDefaultRunLoopMode模式，一旦runloop切换模式，那么定时器就不工作[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];//占位模式：common modes标记//被标记为common modes的模式 kCFRunLoopDefaultMode UITrackingRunLoopMode[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; GCD中的定时器12345678910111213141516171819202122232425262728293031323334//0.创建一个队列dispatch_queue_t queue = dispatch_get_global_queue(0, 0);//1.创建一个GCD的定时器/*第一个参数：说明这是一个定时器第四个参数：GCD的回调任务添加到那个队列中执行，如果是主队列则在主线程执行*/dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);//2.设置定时器的开始时间，间隔时间以及精准度//设置开始时间，三秒钟之后调用dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW,3.0 *NSEC_PER_SEC);//设置定时器工作的间隔时间uint64_t intevel = 1.0 * NSEC_PER_SEC;/*第一个参数：要给哪个定时器设置第二个参数：定时器的开始时间DISPATCH_TIME_NOW表示从当前开始第三个参数：定时器调用方法的间隔时间第四个参数：定时器的精准度，如果传0则表示采用最精准的方式计算，如果传大于0的数值，则表示该定时切换i可以接收该值范围内的误差，通常传0该参数的意义：可以适当的提高程序的性能注意点：GCD定时器中的时间以纳秒为单位（面试）*/dispatch_source_set_timer(timer, start, intevel, 0 * NSEC_PER_SEC);//3.设置定时器开启后回调的方法/*第一个参数：要给哪个定时器设置第二个参数：回调block*/dispatch_source_set_event_handler(timer, ^&#123;NSLog(@"------%@",[NSThread currentThread]);&#125;);//4.执行定时器dispatch_resume(timer);//注意：dispatch_source_t本质上是OC类，在这里是个局部变量，需要强引用self.timer = timer; CFRunloopSourceRef 是事件源也就是输入源，有两种分类模式； 一种是按照苹果官方文档进行划分的 另一种是基于函数的调用栈来进行划分的（source0和source1）。 具体的分类情况 以前的分法Port-Based Sources Custom Input Sources Cocoa Perform Selector Sources 现在的分法Source0：非基于Port的 Source1：基于Port的 可以通过打断点的方式查看一个方法的函数调用栈 CFRunLoopObserverRef CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变 如何监听: 1234567//创建一个runloop监听者CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(),kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123; NSLog(@"监听runloop状态改变---%zd",activity); &#125;); //为runloop添加一个监听者 CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode); CFRelease(observer); 监听的状态 123456789typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), //即将进入Runloop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), //即将处理NSTimer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //即将处理Sources kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), //刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), //即将退出runloop kCFRunLoopAllActivities = 0x0FFFFFFFU //所有状态改变&#125;; Runloop运行逻辑每次运行runloop，你线程的runloop对象会自动处理之前未处理的消息，并通知相关的观察者，具体顺序如下： 通知观察者runloop已经启动 通知观察者任何即将要开始的定时器 通知观察者任何即将启动的非基于端口的源 启动任何准备好的非基于端口的源 如果基于端口的源准备好并处于等待状态，立即启动；并进入步骤9 通知观察者线程进入休眠 将线程置于休眠知道任一下面的事件发生： 某一事件到达基于端口的源 定时器启动 runloop设置的时间已经超时 runloop被显式唤醒 通知观察者线程将被唤醒 处理未处理的事件 如果用户定义的定时器启动，处理定时器事件并重启runloop，进入步骤2 如果输入源启动，传递相应的消息 如果runloop被显式唤醒而且时间还没超时，重启runloop，进入步骤2 通知观察者runloop结束 Runloop应用 NSTimer ImageView显示 PerformSelector 常驻线程 自动释放池 Runloop参考资料 苹果官方文档https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html CFRunLoopRef开源代码下载地址：http://opensource.apple.com/source/CF/CF-1151.16/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS之Runtime]]></title>
    <url>%2F2016%2F04%2F10%2FiOS%E4%B9%8Bruntime%2F</url>
    <content type="text"><![CDATA[RunTime简称运行时。它是一套纯C语言API,属于一个C语言库,包含了很多底层的C语言API。OC就是运行时机制，我们平时写的OC代码在运行的时候都会转换成runtime的C语言代码。 对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。事实证明：在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错。在编译阶段，C语言调用未实现的函数就会报错。 Runtime有什么作用在没有了解runtime之前，你会觉得它没有什么用，但当你深入的了解了OC的运行机制后，你就会觉的其实它的作用非常之大。 1. 发送消息 方法调用的本质就是让对象发送消息 objc_msgSend,只有对象才能发送消息，因此以objc开头 使用消息机制的前提，必须导入#import 消息机制原理:对象根据方法编号SEL去映射表查找对应的方法实现 消息机制代码说明： 1234567891011121314// 创建person对象 Person *p = [[Person alloc] init]; // 调用对象方法 [p eat]; // 本质：让对象发送消息 objc_msgSend(p, @selector(eat)); // 调用类方法的方式：两种 // 第一种通过类名调用 [Person eat]; // 第二种通过类对象调用 [[Person class] eat]; // 用类名调用类方法，底层会自动把类名转换成类对象调用 // 本质：让类对象发送消息 objc_msgSend([Person class], @selector(eat)); 2.交换方法如果系统自带的方法功能不够，可以给系统自带的方法扩展一些功能，并且保持原有的功能，有两种实现方式： 继承系统的类，重写方法 使用runtime,交换方法 使用Runtime实现方法交换： 在分类中交换方法地址，并实现方法 123456789101112131415161718192021222324252627282930313233@implementation UIImage (Image)//加载分类到内存中的时候调用+(void)load&#123; //获取imageNamed方法地址 Method imageName = class_getClassMethod(self, @selector(imageNamed:)); //获取imageWithName方法地址 Method imageWithName = class_getClassMethod(self, @selector(imageWithName:)); //交换两个方法的地址 method_exchangeImplementations(imageName, imageWithName); &#125;// 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.+(instancetype)imageWithName:(NSString *)name&#123; // 这里调用imageWithName，相当于调用imageName UIImage *image = [self imageWithName:name]; if (image == nil) &#123; NSLog(@"图片加载为空"); &#125; return image;&#125;@end``` * 调用系统方法，其实调用的是自己创建的方法```objc-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; //当图片不存在的时候会打印"图片加载为空" UIImage * image = [UIImage imageNamed:@"222"]; self.pageView.image = image;&#125; 3. 动态添加方法如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类添加方法解决。 调用未实现的方法 123Person * p = [[Person alloc] init];// 默认Person没有实现eat方法，通过performSelector方法调用会报错，但是动态添加方法就不会报错[p performSelector:@selector(eat)]; 动态的添加方法 1234567891011121314151617181920@implementation Person//默认方法都有两个隐式参数void eat (id self, SEL sel)&#123; NSLog(@"%@, %@", self, NSStringFromSelector(sel));&#125;//当一个对象调用未实现的方法时，系统会调用这个方法处理，并且会把对应的方法列表传过来+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; if (sel == @selector(eat)) &#123; //动态添加eat方法 // 第一个参数：给哪个类添加方法 // 第二个参数：添加方法的方法编号 // 第三个参数：添加方法的函数实现（函数地址） // 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd class_addMethod(self, @selector(eat), eat, "v@:"); &#125; NSLog(@"当一个对象调用未实现的方法时，会调用这个函数"); return [super resolveInstanceMethod:sel];&#125;@end 4. 给分类添加属性给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。所以即便分类不能添加属性，但是可以使用runtime实现这一功能。 在分类中声明属性 12345@interface NSObject (AddName)// @property在分类中，只会生成get,set方法的声明，不会生成下划线成员属性，和get,set方法的实现// 因此需要自己实现@property (nonatomic, strong) NSString *name;@end 在分类中实现属性的get，set方法 12345678910111213141516171819//定义一个关联的keystatic const char *key = "name";@implementation NSObject (AddName)//get方法-(NSString *)name&#123; //根据关联的key获取关联的值 return objc_getAssociatedObject(self, key);&#125;//set方法-(void)setName:(NSString *)name&#123; // 第一个参数：给哪个对象添加关联 // 第二个参数：关联的key，通过这个key获取 // 第三个参数：关联的value // 第四个参数:关联的策略 objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 为属性赋值 1234// 给系统NSObject类动态添加属性nameNSObject *objc = [[NSObject alloc] init];objc.name = @"flame";NSLog(@"%@",objc.name); 5. 使用runtime字典转模型提供一个分类，专门根据字典生成模型对应的属性字符串。 12345678910111213141516171819202122232425262728293031// 自动打印属性字符串+ (void)resolveDict:(NSDictionary *)dict&#123; // 拼接属性字符串代码 NSMutableString *strM = [NSMutableString string]; // 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码 [dict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; NSString *type; if ([obj isKindOfClass:NSClassFromString(@"__NSCFString")]) &#123; type = @"NSString"; &#125;else if ([obj isKindOfClass:NSClassFromString(@"__NSCFArray")])&#123; type = @"NSArray"; &#125;else if ([obj isKindOfClass:NSClassFromString(@"__NSCFNumber")])&#123; type = @"int"; &#125;else if ([obj isKindOfClass:NSClassFromString(@"__NSCFDictionary")])&#123; type = @"NSDictionary"; &#125;else if ([obj isKindOfClass:NSClassFromString(@"__NSCFBoolean")])&#123; type = @"Bool"; &#125; // 属性字符串 NSString *str; if ([type containsString:@"NS"]) &#123; str = [NSString stringWithFormat:@"@property (nonatomic, strong) %@ *%@;",type,key]; &#125;else&#123; str = [NSString stringWithFormat:@"@property (nonatomic, assign) %@ %@;",type,key]; &#125; // 每生成属性字符串，就自动换行。 [strM appendFormat:@"\n%@\n",str]; &#125;]; // 把拼接好的字符串打印出来，就好了。 NSLog(@"%@",strM);&#125; 使用runtime字典转模型 思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#import &lt;objc/message.h&gt;@implementation NSObject (Model)+ (instancetype)modelWithDict:(NSDictionary *)dict&#123; // 思路：遍历模型中所有属性-》使用运行 // 0.创建对应的对象 id objc = [[self alloc] init]; // 1.利用runtime给对象中的成员属性赋值 // class_copyIvarList:获取类中的所有成员属性 // Ivar：成员属性的意思 // 第一个参数：表示获取哪个类中的成员属性 // 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值 // 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。 unsigned int count; // 获取类中的所有成员属性 Ivar *ivarList = class_copyIvarList(self, &amp;count); for (int i = 0; i &lt; count; i++) &#123; // 根据角标，从数组取出对应的成员属性 Ivar ivar = ivarList[i]; // 获取成员属性名 NSString *name = [NSString stringWithUTF8String:ivar_getName(ivar)]; // 处理成员属性名-&gt;字典中的key // 从第一个角标开始截取 NSString *key = [name substringFromIndex:1]; // 根据成员属性名去字典中查找对应的value id value = dict[key]; // 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型 // 判断下value是否是字典 if ([value isKindOfClass:[NSDictionary class]]) &#123; // 字典转模型 // 获取模型的类对象，调用modelWithDict // 模型的类名已知，就是成员属性的类型 // 获取成员属性类型 NSString *type = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)]; // 生成的是这种@"@\"User\"" 类型 -》 @"User" 在OC字符串中 \" -&gt; "，\是转义的意思，不占用字符 // 裁剪类型字符串 NSRange range = [type rangeOfString:@"\""]; type = [type substringFromIndex:range.location + range.length]; range = [type rangeOfString:@"\""]; // 裁剪到哪个角标，不包括当前角标 type = [type substringToIndex:range.location]; // 根据字符串类名生成类对象 Class modelClass = NSClassFromString(type); if (modelClass) &#123; // 有对应的模型才需要转 // 把字典转模型 value = [modelClass modelWithDict:value]; &#125; &#125; // 三级转换：NSArray中也是字典，把数组中的字典转换成模型. // 判断值是否是数组 if ([value isKindOfClass:[NSArray class]]) &#123; // 判断对应类有没有实现字典数组转模型数组的协议 if ([self respondsToSelector:@selector(arrayContainModelClass)]) &#123; // 转换成id类型，就能调用任何对象的方法 id idSelf = self; // 获取数组中字典对应的模型 NSString *type = [idSelf arrayContainModelClass][key]; // 生成模型 Class classModel = NSClassFromString(type); NSMutableArray *arrM = [NSMutableArray array]; // 遍历字典数组，生成模型数组 for (NSDictionary *dict in value) &#123; // 字典转模型 id model = [classModel modelWithDict:dict]; [arrM addObject:model]; &#125; // 把模型数组赋值给value value = arrM; &#125; &#125; if (value) &#123; // 有值，才需要给模型的属性赋值 // 利用KVC给模型中的属性赋值 [objc setValue:value forKey:key]; &#125; &#125; return objc;&#125;@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS之多线程]]></title>
    <url>%2F2016%2F04%2F09%2FiOS%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[首先，在了解多线程之前要了解什么是进程，什么是线程进程是指在系统中正在运行的一个应用程序。每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。一个进程要想执行任务，必须得有至少一个线程，线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行。一个线程中任务的执行是串行的，如果要在1个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务。也就是说，在同一时间内，1个线程只能执行1个任务。 什么是多线程？即在一个进程（程序）中可以开启多条线程，每条线程可以并行（同时）执行不同的任务。 并行即同时执行。比如同时开启3条线程分别下载3个文件（分别是文件A、文件B、文件C）。 在同一时间里，CPU只能处理一条线程，只有一条线程在工作（执行）。多线程并发（同时）执行，其实是CPU快速地在多条线程之间快速切换，如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。 多线程优缺点优点: 能适当提高程序的执行效率。 能适当提高资源利用率（CPU、内存利用率） 缺点: 开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能。 线程越多，CPU在调度线程上的开销就越大。 程序设计更加复杂：比如线程之间的通信、多线程的数据共享 开启多线程的方式当一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”；它的作用就是刷新显示UI,处理UI事件。 不要将耗时操作放到主线程中去处理，会卡住线程。 和UI相关的刷新操作必须放到主线程中进行处理。 pthread特点： 一套通用的多线程API 适用于Unix\Linux\Windows等系统 跨平台\可移植 使用难度：*****使用语言：c语言使用频率：几乎不用线程生命周期：由程序员进行管理 使用说明：pthread的基本使用（需要包含头文件） 1#import &lt;pthread.h&gt; 具体实现代码： 123456789//使用pthread创建线程对象pthread_t thread;/*第一个参数:线程对象第二个参数:线程属性,NULL第三个参数:指向函数的指针第四个参数:前一个参数()方法中需要接受的参数*/pthread_create(&amp;thread, NULL, run, NULL); NSThread特点： 使用更加面向对象 简单易用，可直接操作线程对象 使用难度：***使用语言：OC语言使用频率：偶尔使用线程生命周期：由程序员进行管理 创建线程第一种创建线程的方式：alloc init 123456789//特点：需要手动开启线程，可以拿到线程对象进行详细的设置/*第一个参数：目标对象第二个参数：选择器，线程启动要调用哪个方法第三个参数：前面方法要接收的参数（最多只能接收一个参数，没有则传nil）*/NSThread *newThread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];//启动线程[newThread start]; 第二种创建线程的方式：分离出一条子线程 1234567//特点：不需要手动开启线程，不可以对线程对象进行详细的设置/* 第一个参数：选择器，线程启动要调用哪个方法 第二个参数：目标对象 第三个参数：前面方法要接收的参数*/[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:nil]; 第三种创建线程的方式：后台线程 123456//特点：自动启动线程，不能对线程对象进行详细的设置/*第一个参数：线程启动后调用的方法第二个参数：方法接收的参数*/[self performSelectorInBackground:@selector(run) withObject:nil]; 设置线程的属性12345//设置线程的属性//设置线程的名称thread.name = @"线程A";//设置线程的优先级,注意线程优先级的取值范围为0.0~1.0之间，1.0表示线程的优先级最高,如果不设置该值，那么理想状态下默认为0.5thread.threadPriority = 1.0; 线程的状态线程的各种状态：新建-就绪-运行-阻塞-死亡12345//常用的控制线程状态的方法[NSThread exit];//退出当前线程[NSThread sleepForTimeInterval:2.0];//阻塞线程[NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:2.0]];//阻塞线程//注意：线程死了不能复生 线程安全前提：多个线程访问同一块资源会发生数据安全问题解决方案：加互斥锁相关代码：@synchronized(self){}专业术语-线程同步原子和非原子属性（是否对setter方法加锁） 线程间通信123456789101112131415161718192021-(void)touchesBegan:(nonnull NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event&#123; //开启一条子线程来下载图片 [NSThread detachNewThreadSelector:@selector(downloadImage) toTarget:self withObject:nil];&#125;-(void)downloadImage&#123; //1.确定要下载网络图片的url地址，一个url唯一对应着网络上的一个资源 NSURL *url = [NSURL URLWithString:@"http://http://p2.wmpic.me/article/2016/03/17/1458205813_mEsdeUon.jpg"]; //2.根据url地址下载图片数据到本地（二进制数据） NSData *data = [NSData dataWithContentsOfURL:url]; //3.把下载到本地的二进制数据转换成图片 UIImage *image = [UIImage imageWithData:data]; //4.回到主线程刷新UI //4.1 第一种方式// [self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:YES]; //4.2 第二种方式// [self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:YES]; //4.3 第三种方式 [self.imageView performSelector:@selector(setImage:) onThread:[NSThread mainThread] withObject:image waitUntilDone:YES];&#125; 如何计算代码段的执行时间1234567891011//第一种方法NSDate *start = [NSDate date];//2.根据url地址下载图片数据到本地（二进制数据）NSData *data = [NSData dataWithContentsOfURL:url];NSDate *end = [NSDate date];NSLog(@"第二步操作花费的时间为%f",[end timeIntervalSinceDate:start]);//第二种方法CFTimeInterval start = CFAbsoluteTimeGetCurrent();NSData *data = [NSData dataWithContentsOfURL:url];CFTimeInterval end = CFAbsoluteTimeGetCurrent();NSLog(@"第二步操作花费的时间为%f",end - start); GCD特点： 旨在替代NSThread等线程技术 充分利用设备的多核（自动） 使用难度：**使用语言：C语言使用频率：经常使用线程生命周期：自动管理 GCD基本使用异步函数+并发队列：开启多条线程，并发执行任务异步函数+串行队列：开启一条线程，串行执行任务同步函数+并发队列：不开线程，串行执行任务同步函数+串行队列：不开线程，串行执行任务异步函数+主队列：不开线程，在主线程中串行执行任务同步函数+主队列：不开线程，串行执行任务（注意死锁发生） 注意同步函数和异步函数在执行顺序上面的差异 GCD线程间通信创建串行队列12345/*第一个参数:C语言的字符传,标签第二个参数:队列的类型*/dispatch_queue_t queue2 = dispatch_queue_create(const char *label, DISPATCH_QUEUE_SERIAL); 创建并发队列 12345/*第一个参数:C语言的字符传,标签第二个参数:队列的类型*/dispatch_queue_t queue2 = dispatch_queue_create(const char *label, DISPATCH_QUEUE_CONCURRENT); 创建全局队列 123456789101112131415161718//0.获取一个全局的队列dispatch_queue_t queue = dispatch_get_global_queue(0, 0);//1.先开启一个线程，把下载图片的操作放在子线程中处理dispatch_async(queue, ^&#123; //2.下载图片 NSURL *url = [NSURL URLWithString:@"http://p2.wmpic.me/article/2016/03/17/1458205813_mEsdeUon.jpg"]; NSData *data = [NSData dataWithContentsOfURL:url]; UIImage *image = [UIImage imageWithData:data]; NSLog(@"下载操作所在的线程--%@",[NSThread currentThread]); //3.回到主线程刷新UI dispatch_async(dispatch_get_main_queue(), ^&#123; self.imageView.image = image; //打印查看当前线程 NSLog(@"刷新UI---%@",[NSThread currentThread]); &#125;);&#125;); GCD其它常用函数栅栏函数（控制任务的执行顺序） 123dispatch_barrier_async(queue, ^&#123; NSLog(@"--dispatch_barrier_async-");&#125;); 延迟执行（延迟·控制在哪个线程执行） 123dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@"---%@",[NSThread currentThread]);&#125;); 一次性代码（注意不能放到懒加载） 123456789-(void)once&#123; //整个程序运行过程中只会执行一次 //onceToken用来记录该部分的代码是否被执行过 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; NSLog(@"-----"); &#125;);&#125; 快速迭代（开多个线程并发完成迭代操作）123dispatch_apply(subpaths.count, queue, ^(size_t index) &#123;&#125;); 队列组（同栅栏函数） 123456//创建队列组 dispatch_group_t group = dispatch_group_create(); //队列组中的任务执行完毕之后，执行该函数 dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); 注意事项：在iOS6.0之前，在GCD中凡是使用了带Crearte和retain的函数在最后都需要做一次release操作。而主队列和全局并发队列不需要我们手动release。在iOS6.0之后GCD已经被纳入到了ARC的内存管理范畴中，即便是使用retain或者create函数创建的对象也不再需要开发人员手动释放，我们像对待普通OC对象一样对待GCD就OK。 在使用栅栏函数的时候，苹果官方明确规定栅栏函数只有在和使用create函数自己的创建的并发队列一起使用的时候才有效 NSOperation特点： 基于GCD（底层是GCD） 比GCD多了一些更简单实用的功能 使用更加面向对象 使用难度：**使用语言：OC语言使用频率：经常使用线程生命周期：自动管理 NSOperation是对GCD的包装，其本身是只是抽象类，只有它的子类（三个子类分别是：NSBlockOperation、NSInvocationOperation以及自定义继承自NSOperation的类）才能创建对象 NSInvocationOperation123456789//1.封装操作/*第一个参数：目标对象第二个参数：该操作要调用的方法，最多接受一个参数第三个参数：调用方法传递的参数，如果方法不接受参数，那么该值传nil*/NSInvocationOperation *operation = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(run) object:nil];//2.启动操作[operation start]; NSBlockOperation1234567891011121314151617//1.封装操作/* NSBlockOperation提供了一个类方法，在该类方法中封装操作*/NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123; //在主线程中执行 NSLog(@"---download1--%@",[NSThread currentThread]);&#125;];//2.追加操作，追加的操作在子线程中执行[operation addExecutionBlock:^&#123; NSLog(@"---download2--%@",[NSThread currentThread]);&#125;];[operation addExecutionBlock:^&#123; NSLog(@"---download3--%@",[NSThread currentThread]);&#125;];//3.启动执行操作[operation start]; 自定义NSOperation1234567891011//如何封装操作？//自定义的NSOperation,通过重写内部的main方法实现封装操作-(void)main&#123; NSLog(@"--main--%@",[NSThread currentThread]);&#125;//如何使用？//1.实例化一个自定义操作对象TYOperation *op = [[TYOperation alloc]init];//2.执行操作[op start]; NSOperationQueueNSOperation中的两种队列 主队列 通过mainQueue获得，凡是放到主队列中的任务都将在主线程执行 非主队列 直接alloc init出来的队列。非主队列同时具备了并发和串行的功能，通过设置最大并发数属性来控制任务是并发执行还是串行执行 NSInvocationOperation123456789101112131415161718192021- (void)invocation&#123; /* GCD中的队列： 串行队列：自己创建的，主队列 并发队列：自己创建的，全局并发队列 NSOperationQueue 主队列：[NSOperationQueue mainqueue];凡事放在主队列中的操作都在主线程中执行 非主队列：[[NSOperationQueue alloc]init]，并发和串行，默认是并发执行的 */ //1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc]init]; //2.封装操作 NSInvocationOperation *op1 = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(download1) object:nil]; NSInvocationOperation *op2 = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(download2) object:nil]; NSInvocationOperation *op3 = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(download3) object:nil]; //3.把封装好的操作添加到队列中 [queue addOperation:op1]; [queue addOperation:op2]; [queue addOperation:op3];&#125; NSBlockOperation12345678910111213141516171819202122232425- (void)freeBlock&#123; //1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc]init]; //2.封装操作 NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"1----%@",[NSThread currentThread]); &#125;]; NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"2----%@",[NSThread currentThread]); &#125;]; [op2 addExecutionBlock:^&#123; NSLog(@"3----%@",[NSThread currentThread]); &#125;]; [op2 addExecutionBlock:^&#123; NSLog(@"4----%@",[NSThread currentThread]); &#125;]; //3.添加操作到队列中 [queue addOperation:op1]; [queue addOperation:op2] //补充：简便方法 [queue addOperationWithBlock:^&#123; NSLog(@"5----%@",[NSThread currentThread]); &#125;];&#125; 自定义NSOperation12345678910111213-(void)freeOperation&#123;//1.创建队列NSOperationQueue *queue = [[NSOperationQueue alloc]init];//2.封装操作//好处：1.信息隐蔽// 2.代码复用TYOperation *op1 = [[TYOperation alloc]init];TYOperation *op2 = [[TYOperation alloc]init];//3.添加操作到队列中[queue addOperation:op1];[queue addOperation:op2];&#125; NSOperation其它用法设置最大并发数[最大并发数关系着队列是串行还是并行]创建队列 1NSOperationQueue *queue = [[NSOperationQueue alloc]init]; 设置最大并发数 该属性需要在任务添加到队列中之前进行设置 该属性控制队列是串行执行还是并发执行 如果最大并发数等于1，那么该队列是串行的，如果大于1那么是并行的4.系统的最大并发数有个默认的值，为-1，如果该属性设置为0，那么不会执行任何任务 1queue.maxConcurrentOperationCount = 2; 暂停和恢复以及取消12345678910111213141516171819202122232425262728293031323334//设置暂停和恢复//suspended设置为YES表示暂停，suspended设置为NO表示恢复//暂停表示不继续执行队列中的下一个任务，暂停操作是可以恢复的if (self.queue.isSuspended) &#123; self.queue.suspended = NO;&#125;else&#123; self.queue.suspended = YES;&#125;//取消队列里面的所有操作//取消之后，当前正在执行的操作的下一个操作将不再执行，而且永远都不在执行，就像后面的所有任务都从队列里面移除了一样//取消操作是不可以恢复的[self.queue cancelAllOperations];---------自定义NSOperation取消操作---------------------------(void)main&#123; //耗时操作1 for (int i = 0; i&lt;1000; i++) &#123; NSLog(@"任务1-%d--%@",i,[NSThread currentThread]); &#125; NSLog(@"+++++++++++++++++++++++++++++++++"); //苹果官方建议，每当执行完一次耗时操作之后，就查看一下当前队列是否为取消状态，如果是，那么就直接退出 //好处是可以提高程序的性能 if (self.isCancelled) &#123; return; &#125; //耗时操作2 for (int i = 0; i&lt;1000; i++) &#123; NSLog(@"任务1-%d--%@",i,[NSThread currentThread]); &#125; NSLog(@"+++++++++++++++++++++++++++++++++");&#125; NSOperation实现线程间通信开子线程下载图片12345678910111213141516//1.创建队列NSOperationQueue *queue = [[NSOperationQueue alloc]init];//2.使用简便方法封装操作并添加到队列中[queue addOperationWithBlock:^&#123; //3.在该block中下载图片 NSURL *url = [NSURL URLWithString:@"http://p2.wmpic.me/article/2016/03/17/1458205813_mEsdeUon.jpg"]; NSData *data = [NSData dataWithContentsOfURL:url]; UIImage *image = [UIImage imageWithData:data]; NSLog(@"下载图片操作--%@",[NSThread currentThread]); //4.回到主线程刷新UI [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; self.imageView.image = image; NSLog(@"刷新UI操作---%@",[NSThread currentThread]); &#125;];&#125;]; 下载多张图片合成综合案例（设置操作依赖）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455- (void)download&#123; //1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc]init]; //2.封装操作下载图片1 NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; NSURL *url = [NSURL URLWithString:@"http://p2.wmpic.me/article/2016/03/14/1457926891_nZGraHTj.jpg"]; NSData *data = [NSData dataWithContentsOfURL:url]; //拿到图片数据 self.image1 = [UIImage imageWithData:data]; &#125;]; //3.封装操作下载图片2 NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; NSURL *url = [NSURL URLWithString:@"http://p3.wmpic.me/article/2016/01/08/1452222281_PmFnXZHU.jpg"]; NSData *data = [NSData dataWithContentsOfURL:url]; //拿到图片数据 self.image2 = [UIImage imageWithData:data]; &#125;]; //4.合成图片 NSBlockOperation *combine = [NSBlockOperation blockOperationWithBlock:^&#123; //4.1 开启图形上下文 UIGraphicsBeginImageContext(CGSizeMake(200, 200)); //4.2 画第一幅图 [self.image1 drawInRect:CGRectMake(0, 0, 200, 100)]; //4.3 画第二幅图 [self.image2 drawInRect:CGRectMake(0, 100, 200, 100)]; //4.4 根据图形上下文拿到图片数据 UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); //NSLog(@"%@",image); //4.5 关闭图形上下文 UIGraphicsEndImageContext(); //7.回到主线程刷新UI [[NSOperationQueue mainQueue]addOperationWithBlock:^&#123; self.imageView.image = image; NSLog(@"刷新UI---%@",[NSThread currentThread]); &#125;]; &#125;]; //5.设置操作依赖 [combine addDependency:op1]; [combine addDependency:op2]; //6.添加操作到队列中执行 [queue addOperation:op1]; [queue addOperation:op2]; [queue addOperation:combine]; &#125; 单例设计模式 iOS开发多种设计模式之一—-单例模式 什么是单例在程序运行过程，一个类有且只有一个实例对象 使用场合在整个应用程序中，共享一份资源（这份资源只需要创建初始化1次） 在不同的内存管理机制下实现单例:ARC实现单例步骤: 在类的内部提供一个static修饰的全局变量 提供一个类方法，方便外界访问 重写+allocWithZone方法，保证永远都只为单例对象分配一次内存空间 严谨起见，重写-copyWithZone方法和-MutableCopyWithZone方法 代码实现: 1234567891011121314151617181920212223242526272829303132333435363738//提供一个static修饰的全局变量，强引用着已经实例化的单例对象实例static TYSingleTools *_instance;//类方法，返回一个单例对象+(instancetype)shareTools&#123; //注意：这里建议使用self,而不是直接使用类名Tools（考虑继承） return [[self alloc]init];&#125;//保证永远只分配一次存储空间+(instancetype)allocWithZone:(struct _NSZone *)zone&#123; //第一种：使用GCD中的一次性代码// static dispatch_once_t onceToken;// dispatch_once(&amp;onceToken, ^&#123;// _instance = [super allocWithZone:zone];// &#125;); //第二种：使用加锁的方式，保证只分配一次存储空间 @synchronized(self) &#123; if (_instance == nil) &#123; _instance = [super allocWithZone:zone]; &#125; &#125; return _instance;&#125;/*1.mutableCopy 创建一个新的可变对象，并初始化为原对象的值，新对象的引用计数为 1；2.copy 返回一个不可变对象。分两种情况：（1）若原对象是不可变对象，那么返回原对象，并将其引用计数加 1 ；（2）若原对象是可变对象，那么创建一个新的不可变对象，并初始化为原对象的值，新对象的引用计数为 1。*///让代码更加的严谨-(nonnull id)copyWithZone:(nullable NSZone *)zone&#123;// return [[self class] allocWithZone:zone]; return _instance;&#125;-(nonnull id)mutableCopyWithZone:(nullable NSZone *)zone&#123; return _instance;&#125; MRC实现单例步骤: 在类的内部提供一个static修饰的全局变量 提供一个类方法，方便外界访问 重写+allocWithZone方法，保证永远都只为单例对象分配一次内存空间 严谨起见，重写-copyWithZone方法和-MutableCopyWithZone方法 重写release和retain方法 建议在retainCount方法中返回一个最大值（有经验的程序员通过打印retainCount这个值可以猜到这是一个单例） 配置MRC环境知识: 注意ARC不是垃圾回收机制，是编译器特性 配置MRC环境：build setting -&gt;搜索automatic ref-&gt;修改为NO 代码实现: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//提供一个static修饰的全局变量，强引用着已经实例化的单例对象实例static TYSingleTools *_instance;//类方法，返回一个单例对象+(instancetype)shareTools&#123; //注意：这里建议使用self,而不是直接使用类名Tools（考虑继承） return [[self alloc]init];&#125;//保证永远只分配一次存储空间+(instancetype)allocWithZone:(struct _NSZone *)zone&#123; //使用GCD中的一次性代码// static dispatch_once_t onceToken;// dispatch_once(&amp;onceToken, ^&#123;// _instance = [super allocWithZone:zone];// &#125;); //使用加锁的方式，保证只分配一次存储空间 @synchronized(self) &#123; if (_instance == nil) &#123; _instance = [super allocWithZone:zone]; &#125; &#125; return _instance;&#125;//让代码更加的严谨-(nonnull id)copyWithZone:(nullable NSZone *)zone&#123;// return [[self class] allocWithZone:zone]; return _instance;&#125;-(nonnull id)mutableCopyWithZone:(nullable NSZone *)zone&#123; return _instance;&#125;//在MRC环境下，如果用户retain了一次，那么直接返回instance变量，不对引用计数器+1//如果用户release了一次，那么什么都不做，因为单例模式在整个程序运行过程中都拥有且只有一份，程序退出之后被释放，所以不需要对引用计数器操作-(oneway void)release&#123;&#125;-(instancetype)retain&#123; return _instance;&#125;//惯用法，有经验的程序员通过打印retainCount这个值可以猜到这是一个单例-(NSUInteger)retainCount&#123; return MAXFLOAT;&#125; 忽略ARC和MRC的单例通用版本可以使用条件编译来判断当前项目环境是ARC还是MRC，从而实现一份代码在不同的内存管理机制下都可以实现单例。123456条件编译:#if __has_feature(objc_arc)//如果是ARC，那么就执行这里的代码1#else//如果不是ARC，那么就执行代理的代码2#endif 注意：单例是不可以用继承的。 参考资料 GCDAPI:https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html#//apple_ref/c/func/dispatch_queue_create Libdispatch版本源码：http://www.opensource.apple.com/source/libdispatch/libdispatch-187.5/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac搭建hexo + github博客]]></title>
    <url>%2F2015%2F09%2F01%2FMac%E6%90%AD%E5%BB%BAhexo%20%2B%20githu%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[环境配置1. node.js用来生成静态页面.Mac中自带了node.js.下载地址 2.Git用来将本地Hexo内容提交到Github上。Xcode自带Git，这里不再赘述。如果没有Xcode可以参考Hexo官网上的安装方法。 搭建步骤一般搭建方法 待续… 优化搭建方法(全部存放于gitHub中,包括Hexo源文件和生成的静态页面文件) 概述:Hexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，就不可能了。如果我们将Hexo生成的网站文件存放到GitHub上进行管理的。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程。我们需要有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。 搭建流程 创建仓库，Flametinary.github.io； 创建两个分支：master 与 hexo； 设置hexo为默认分支（我们只需要手动管理这个分支上的Hexo网站文件）； 使用git clone git@github.com:FlameTinary/FlameTinary.github.io.git拷贝仓库； 在本地Flametinary.github.io文件夹下通过Git bash依次执行npm install -g hexo-cli、hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）; 修改_config.yml中的deploy参数，分支应为master； 依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件； 执行hexo generate -d生成网站并部署到GitHub上。 相关问题解决 在将hexo源文件提交到git的hexo目录中出现modified: themes/next的问题. 原因: 由于next主题是存放于GitHub中的,因此在将next主题clone下来的时候,同时携带了一些GitHub的相关文件,是由这些脏数据引起的. 解决办法: 删除相关文件即可,进入存放hexo的文件夹-&gt;themes-&gt;next,其中有git/GitHub/gitattribute,三个文件,删除即可. git 分支可以commit成功,但是push不到origin hexo.原因: 本地的hexo分支没有关联到origin上的hexo分支.解决办法:使用git branch --set-upstream hexo origin/hexo. 如果在修改hexo文件,比如修改next主题后,hexo s显示了修改后的效果,但是 hexo generate/hexo deploy后却在GitHub page上没有效果,可以先 hexo clean一下,然后在执行部署hexo g -d. 在hexo deploy后显示error:Deployer not found: git,尝试执行npm install hexo-deployer-git --save可修复. 执行hexo s命令后，页面访问显示Cannot GET/, 重新执行npm install. 执行hexo deploy,打开gitHub page,显示页面404 not found.原因:主要是Jekyll升级所致解决办法: .deploy_git 目录, 添加 .nojekyll 空文件 source目录, 添加.nojekyll 空文件 修改 Hexo 上层_config.yml配置文件, 添加include: - .nojekyll 重新部署推送: hexo d -g]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
