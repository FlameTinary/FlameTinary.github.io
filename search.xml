<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>cocoapods结构解析</title>
      <link href="/2020/09/20/cocoapods%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/09/20/cocoapods%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>CocoaPods是用 Ruby 写的，并由若干个 Ruby 包 (gems) 构成的。在解析整合过程中，最重要的几个 gems 分别是： CocoaPods/CocoaPods, CocoaPods/Core, 和 CocoaPods/Xcodeproj (是的，CocoaPods 是一个依赖管理工具 – 利用依赖管理进行构建的！)。<br>podspecs存储路径：~/.cocoapods<br>缓存文件存储路径：~/Library/Caches/CocoaPods</p></blockquote><a id="more"></a><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><h3 id="CocoaPods-CocoaPod"><a href="#CocoaPods-CocoaPod" class="headerlink" title="CocoaPods/CocoaPod"></a>CocoaPods/CocoaPod</h3><p>这是是一个面向用户的组件，每当执行一个 pod 命令时，这个组件都将被激活。该组件包括了所有使用 CocoaPods 涉及到的功能，并且还能通过调用所有其它的 gems 来执行任务。</p><h3 id="CocoaPods-Core"><a href="#CocoaPods-Core" class="headerlink" title="CocoaPods/Core"></a>CocoaPods/Core</h3><p>Core 组件提供支持与 CocoaPods 相关文件的处理，文件主要是 Podfile 和 podspecs。</p><ul><li>Podfile：Podfile 是一个文件，用于定义项目所需要使用的第三方库。该文件支持高度定制，你可以根据个人喜好对其做出定制。更多相关信息，请查阅 Podfile 指南。</li><li>Podspec：.podspec 也是一个文件，该文件描述了一个库是怎样被添加到工程中的。它支持的功能有：列出源文件、framework、编译选项和某个库所需要的依赖等。</li></ul><h3 id="CocoaPods-Xcodeproj"><a href="#CocoaPods-Xcodeproj" class="headerlink" title="CocoaPods/Xcodeproj"></a>CocoaPods/Xcodeproj</h3><p>这个 gem 组件负责所有工程文件的整合。它能够对创建并修改 .xcodeproj 和 .xcworkspace 文件。它也可以作为单独的一个 gem 包使用。如果你想要写一个脚本来方便的修改工程文件，那么可以使用这个 gem。</p><h2 id="运行-pod-install-命令"><a href="#运行-pod-install-命令" class="headerlink" title="运行 pod install 命令"></a>运行 pod install 命令</h2><p>当运行 pod install 命令时会引发许多操作。要想深入了解这个命令执行的详细内容，可以在这个命令后面加上 –verbose。运行指令后会有如下操作：</p><h3 id="读取Podfile文件"><a href="#读取Podfile文件" class="headerlink" title="读取Podfile文件"></a>读取Podfile文件</h3><p>在安装期间，第一步是要弄清楚显示或隐式的声明了哪些第三方库。在加载 podspecs 过程中，CocoaPods 就建立了包括版本信息在内的所有的第三方库的列表。Podspecs 被存储在本地路径 ~/.cocoapods 中。</p><h3 id="版本控制和冲突"><a href="#版本控制和冲突" class="headerlink" title="版本控制和冲突"></a>版本控制和冲突</h3><p>如果依赖的某些库同时使用了一个第三方库，但是版本不同，那么默认是向后兼容，既高版本的兼容低版本的；<br>但是，总会有一些第三方库会存在不能向后兼容的问题，这时候就需要手动解决兼容问题。比如：同时依赖了一个库的1.2.5和2.1.3，那么需要用户通过明确指定使用的版本来解决冲突。</p><h3 id="加载源文件"><a href="#加载源文件" class="headerlink" title="加载源文件"></a>加载源文件</h3><p>CocoaPods 执行的下一步是加载源码。每个 .podspec 文件都包含一个源代码的索引，这些索引一般包裹一个 git 地址和 git tag。它们以 commit SHAs 的方式存储在 ~/Library/Caches/CocoaPods 中。这个路径中文件的创建是由 Core gem 负责的。<br>CocoaPods 将依照 Podfile、.podspec 和缓存文件的信息将源文件下载到 Pods 目录中。</p><h3 id="生成Pod-xcodeproj"><a href="#生成Pod-xcodeproj" class="headerlink" title="生成Pod.xcodeproj"></a>生成Pod.xcodeproj</h3><p>每次 pod install 执行，如果检测到改动时，CocoaPods 会利用 Xcodeproj gem 组件对 Pods.xcodeproj 进行更新。如果该文件不存在，则用使用默认配置。否则，会将已有的配置项加载至内存中。</p><h3 id="安装第三方库"><a href="#安装第三方库" class="headerlink" title="安装第三方库"></a>安装第三方库</h3><p>当cocoapods往工程中添加一个第三方库时，不仅仅是添加了第三方库的源码，还会添加很多内容。由于每个第三方库会有一个独立的target，因此对于每个库，都会添加几个额外的文件：</p><ul><li>一个包含编译选项的.xcconfig文件</li><li>一个同时包含编译设置和CocoaPods默认配置的私有.xcconfig文件</li><li>一个编译所必须的prefix.pch文件</li><li>一个编译必须的dummy.m文件</li></ul><p>如果源码中包含资源bundle，那么在target的执行脚本Pods-Resources.sh中会添加bundle相关的指令。<br>还有一个Pods-environment.h文件，其中包含一些宏，这些宏是用来检测某个组件是否来自pod。<br>最后，将生成两个认可文件，一个是 plist，另一个是 markdown，这两个文件用于给最终用户查阅相关许可信息。</p><ul><li>Podfile.lock</li></ul><p>该文件记录了Pod中的依赖的每个组件，以及依赖组件的版本</p><ul><li>Manifest.lock</li></ul><p>这是每次运行 pod install 命令时创建的 Podfile.lock 文件的副本。如果你遇见过这样的错误 沙盒文件与 Podfile.lock 文件不同步 (The sandbox is not in sync with the Podfile.lock)。这是因为 Manifest.lock 文件和 Podfile.lock 文件不一致所引起。由于 Pods 所在的目录并不总在版本控制之下，这样可以保证开发者运行 app 之前都能更新他们的 pods，否则 app 可能会 crash，或者在一些不太明显的地方编译失败。</p><h2 id="xcproj"><a href="#xcproj" class="headerlink" title="xcproj"></a>xcproj</h2><p>如果你已经依照我们的建议在系统上安装了 xcproj，它会对 Pods.xcodeproj 文件执行一下 touch 以将其转换成为旧的 ASCII plist 格式的文件。为什么要这么做呢？虽然在很久以前就不被其它软件支持了，但是 Xcode 仍然依赖于这种格式。如果没有 xcproj，你的 Pods.xcodeproj 文件将会以 XML 格式的 plist 文件存储，当你用 Xcode 打开它时，它会被改写，并造成大量的文件改动。</p><h3 id="文件结构变化"><a href="#文件结构变化" class="headerlink" title="文件结构变化"></a>文件结构变化</h3><p>执行pod install 后，我们的工程结构发生了变化，在以前的基础上添加了如下文件：</p><ol><li>PodFile：依赖描述文件</li><li>Podfile.lock：当前安装的依赖库的版本</li><li>xxx.xcworkspace：xcworkspace文件，使用CocoaPod管理依赖的项目，XCode只能使用workspace编译项目，如果还只打开以前的xcodeproj文件进行开发，编译会失败 xcworkspace文件实际是一个文件夹，实际Workspace信息保存在contents.xcworkspacedata里，该文件的内容非常简单，实际上只指示它所使用的工程的文件目录</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">Workspace</span></span></span><br><span class="line"><span class="tag">   <span class="attr">version</span> = <span class="string">"1.0"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">FileRef</span></span></span><br><span class="line"><span class="tag">      <span class="attr">location</span> = <span class="string">"group:CardPlayer/CardPlayer.xcodeproj"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">FileRef</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">FileRef</span></span></span><br><span class="line"><span class="tag">      <span class="attr">location</span> = <span class="string">"group:Pods/Pods.xcodeproj"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">FileRef</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Workspace</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>Pods/</li></ol><ul><li>Pods.xcodeproj，所有的第三方库都由Pods工程构建，每个三方库对应一个Pods工程中的Target。</li><li>每个第三方库都会在Pods目录下对应一个目录。</li><li>Headers，在Headers文件中有两个目录，Private和Public，其中包含第三方库的私有和公有的头文件，这些文件都是快捷连接，其真正的位置在每个三方库的文件夹目录下。</li></ul><p><img src="https://s1.ax1x.com/2020/09/25/09o0VP.jpg" alt="header结构"></p><ol><li>Target Support Files 支撑Target的文件</li></ol><p><img src="https://s1.ax1x.com/2020/09/25/09oYgH.jpg" alt="Target Support Files"></p><h2 id="工程结构的变化"><a href="#工程结构的变化" class="headerlink" title="工程结构的变化"></a>工程结构的变化</h2><h3 id="Pods工程变化"><a href="#Pods工程变化" class="headerlink" title="Pods工程变化"></a>Pods工程变化</h3><p>Pods工程会为每个依赖的第三方库定义一个Target，还会定义一个Pods-xxx的Target，每个Target会生成一个静态库<br><img src="https://s1.ax1x.com/2020/09/25/09oUKA.png" alt="Pods结构"></p><p>Pods工程会新建两个Configuration，每个Configuration会为不同的Target设置不同的xcconfig，xcconfig指出了头文件查找的目录，要链接的第三方，链接目录等。<br><img src="https://s1.ax1x.com/2020/09/25/09osPS.png" alt="7"><br>AFNetworking.xcconfig文件的内容：</p><p>CONFIGURATION_BUILD_DIR = $PODS_CONFIGURATION_BUILD_DIR/AFNetworking<br>GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1<br>HEADER_SEARCH_PATHS = “${PODS_ROOT}/Headers/Private” “${PODS_ROOT}/Headers/Private/AFNetworking” “${PODS_ROOT}/Headers/Public” “${PODS_ROOT}/Headers/Public/AFNetworking”<br>OTHER_LDFLAGS = -framework “CoreGraphics” -framework “MobileCoreServices” -framework “Security” -framework “SystemConfiguration”<br>PODS_BUILD_DIR = $BUILD_DIR<br>PODS_CONFIGURATION_BUILD_DIR = $PODS_BUILD_DIR/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)<br>PODS_ROOT = ${SRCROOT}<br>PODS_TARGET_SRCROOT = ${PODS_ROOT}/AFNetworking<br>PRODUCT_BUNDLE_IDENTIFIER = org.cocoapods.${PRODUCT_NAME:rfc1034identifier}<br>SKIP_INSTALL = YES</p><p>Header_SERACH_PATHS：编译时查找头文件的目录<br>OTHER_LD_FLAGS：指明要链接的framework</p><p>Pods-CardPlayer.debug.xcconfig文件的内容：</p><p>GCC_PREPROCESSOR_DEFINITIONS = $(inherited) COCOAPODS=1<br>HEADER_SEARCH_PATHS = $(inherited) “${PODS_ROOT}/Headers/Public” “${PODS_ROOT}/Headers/Public/AFNetworking”<br>LIBRARY_SEARCH_PATHS = $(inherited) “$PODS_CONFIGURATION_BUILD_DIR/AFNetworking”<br>OTHER_CFLAGS = $(inherited) -isystem “${PODS_ROOT}/Headers/Public” -isystem “${PODS_ROOT}/Headers/Public/AFNetworking”<br>OTHER_LDFLAGS = $(inherited) -ObjC -l”AFNetworking” -framework “CoreGraphics” -framework “MobileCoreServices” -framework “Security” -framework “SystemConfiguration”<br>PODS_BUILD_DIR = $BUILD_DIR<br>PODS_CONFIGURATION_BUILD_DIR = $PODS_BUILD_DIR/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME)<br>PODS_PODFILE_DIR_PATH = ${SRCROOT}/..<br>PODS_ROOT = ${SRCROOT}/../Pods</p><p>OTHER_LDFLAGS：说明了编译Pods时需要链接的第三方库，还需要链接其它framework<br>所以我们在xcode里能看到AFNetworking依赖的framework:</p><p><img src="https://s1.ax1x.com/2020/09/25/09odbt.png" alt="6"></p><h3 id="主工程变化"><a href="#主工程变化" class="headerlink" title="主工程变化"></a>主工程变化</h3><p>引入CocoaPods后，主工程的设置也会发生相应的变化，引入之前：<br><img src="https://s1.ax1x.com/2020/09/25/09oBUf.png" alt="4"></p><p>Debug和Release中的Configuration没有设置任何配置文件，引入CocoaPods后的变化：<br><img src="https://s1.ax1x.com/2020/09/25/09oaDI.jpg" alt="3"><br>可以看到，采用CocoaPods之后，Debug和Release设置了相应的配置文件，这些配置文件指明了头文件的查找目录和要链接的第三方库</p><h2 id="编译并链接第三方库"><a href="#编译并链接第三方库" class="headerlink" title="编译并链接第三方库"></a>编译并链接第三方库</h2><p><a href="http://www.srcmini.com/3965.html" target="_blank" rel="noopener">Podfile语法中文参考文档</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 配置远程登录服务器</title>
      <link href="/2020/01/21/linux%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2020/01/21/linux%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="创建服务器"><a href="#创建服务器" class="headerlink" title="创建服务器"></a>创建服务器</h2><p>创建谷歌GCP服务器</p><h2 id="在服务器配置sshd-config"><a href="#在服务器配置sshd-config" class="headerlink" title="在服务器配置sshd_config"></a>在服务器配置sshd_config</h2><h3 id="登录服务器"><a href="#登录服务器" class="headerlink" title="登录服务器"></a>登录服务器</h3><p>打开终端, 输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@&lt;这里是你服务器的ip地址&gt;</span><br></pre></td></tr></table></figure><p>输入密码, 就完成了服务器的登录</p><h3 id="使用vim打开sshd-config文件"><a href="#使用vim打开sshd-config文件" class="headerlink" title="使用vim打开sshd_config文件"></a>使用vim打开<code>sshd_config</code>文件</h3><p>在服务器中打开sshd_config文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>修改<code>sshd_config</code>文件中的几个地方</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RSAAuthentication yes     <span class="comment"># RSA认证</span></span><br><span class="line">PubkeyAuthentication yes  <span class="comment"># 公钥认证</span></span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys  <span class="comment"># 公钥认证文件路径</span></span><br></pre></td></tr></table></figure><h2 id="本地生成ssh-keygen"><a href="#本地生成ssh-keygen" class="headerlink" title="本地生成ssh-keygen"></a>本地生成ssh-keygen</h2><p>回到本地, 使用<code>ssh-keygen</code>生成公钥和私钥</p><h2 id="将生成的public-key放到服务器"><a href="#将生成的public-key放到服务器" class="headerlink" title="将生成的public key放到服务器"></a>将生成的public key放到服务器</h2><p>进入<code>/.ssh</code>目录, 执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n ~/.ssh/id_rsa.pub&gt;&gt;root@&lt;这里是你服务器的ip地址&gt;:~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>期间会输入服务器的密码.</p><h2 id="本地创建ssh的config文件-并配置host"><a href="#本地创建ssh的config文件-并配置host" class="headerlink" title="本地创建ssh的config文件, 并配置host"></a>本地创建ssh的config文件, 并配置host</h2><p>在本机的目录<code>~/.ssh</code>下创建config文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch config</span><br></pre></td></tr></table></figure><p>然后使用vim打开进行编辑</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ssh模版</span></span><br><span class="line">Host            hostname</span><br><span class="line">HostName        xxx.xxx.xxx.xxx</span><br><span class="line">Port            22</span><br><span class="line">User            root <span class="comment"># 用户名</span></span><br><span class="line">ServerAliveInterval 60 <span class="comment"># 每隔60秒 发送KeepAlive请求，保证不会因为超时空闲断开</span></span><br><span class="line">IdentityFile    ~/.ssh/id_rsa <span class="comment">#私钥地址</span></span><br></pre></td></tr></table></figure><h2 id="使用配置好的Host登录远端服务器"><a href="#使用配置好的Host登录远端服务器" class="headerlink" title="使用配置好的Host登录远端服务器"></a>使用配置好的Host登录远端服务器</h2><p>使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh &lt;刚才配置的HostName&gt;</span><br></pre></td></tr></table></figure><p>就完成了登录</p>]]></content>
      
      
      <categories>
          
          <category> hide </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac配置Vim</title>
      <link href="/2019/08/28/Mac%E9%85%8D%E7%BD%AEVim/"/>
      <url>/2019/08/28/Mac%E9%85%8D%E7%BD%AEVim/</url>
      
        <content type="html"><![CDATA[<blockquote><p>相信不少同学在Mac上使用过<code>vi</code>或者<code>vim</code>命令，这个命令是打开mac自带的vim编辑器的命令，如果只是简单的修改文件，使用vim无疑是很方便的；但是如果使用mac自带的vim来做大量文档编辑的工作，那就可能力不从心了。<br>这个时候，你就需要更复杂的vim编辑器来负担这样的工作了,Mac目前有两个Vim客户端可供我们使用<br>1、<strong>MacVim：</strong>使用Cocoa GUI，这是Mac上更新还很活跃的版本，也是Mac上最多人使用的版本。<a href="https://github.com/macvim-dev/macvim" target="_blank" rel="noopener">下载地址</a><br>2、使用Carbon GUI的版本，但是这个版本目前基本上不再更新。<a href="http://sourceforge.net/projects/macosxvim/files/" target="_blank" rel="noopener">下载地址</a></p></blockquote><a id="more"></a><p>我主要是使用的<strong>MacVim</strong>，所以就记录一下MacVim的安装以及使用过程。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>从上面提供的链接下载MacVim，并按照安装mac应用的步骤安装好MavVim。这个时候还没有结束。</p><p>想象一下，我们以前在terminal中打开一个文件是这样的：<code>vi &lt;文件名称&gt;</code>，这样很coooooooooool；</p><p>但是，我们现在使用MacVim，却得鼠标点击打开MacVim，然后再从MacVim打开文件。这样是不是比以前繁琐了很多。那么，能不能像从前一样，使用命令打开文件呢？</p><p>答案是可以的。</p><p>我们先把MacVim打开,第一次打开MacVim是这个样子：</p><p><img src="https://s2.ax1x.com/2019/08/28/m7xckQ.jpg" alt="第一次打开MacVim"></p><p>在MacVim的界面中我们输入<code>:h mvim</code>，MacVim会提示我们将<code>mvim</code>命令的路径添加到我们的PATH</p><p><img src="https://s2.ax1x.com/2019/08/28/m7xgYj.jpg" alt="提示"></p><p><strong>添加PATH步骤：</strong></p><ol><li><code>vi ~/.bash_podfile</code>打开PATH所在路径</li><li>将MacVim提供的命令路径写入PATH：<code>export PATH=/Applications/MacVim.app/Contents/bin:$PATH</code></li><li>执行<code>source ~/.bash_podfile</code>重启bash</li></ol><p>这个时候，我们就可以直接在Terminal中使用<code>mvim</code>命令来打开文件了。</p><p>是不是觉得输入mvim命令还是不如vim命令舒服？那么我们就使用vim来打开MacVim!</p><p>使用命令<code>mvim ~/.zshrc</code> 或者<code>mvim ~/.bashrc</code>，如果你使用的是zsh那么使用前者，如果使用的是bash，那么使用后者。</p><p>打开后，在文件末尾新增一段文字<code>alias vim=&#39;mvim&#39;</code>，意思就是给mvim命令起一个别名。</p><p>然后保存退出，如果你是zsh使用<code>source ~/.zshrc</code>重新载入，如果是bash使用<code>source ~/.bashrc</code>载入。</p><p>接下来就是见证奇迹的时刻了，输入命令<code>vim &lt;你要打开的文档&gt;</code>，看看是不是使用MacVim打开了!</p><h2 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h2><blockquote><p>经过上面的一系列骚操作，现在我们可以使用MacVim正常的进行编辑了，但是，我们还可以对MacVim进行更深层次的扩展，那就是给MacVim添加插件！</p></blockquote><h3 id="Vundle-命令"><a href="#Vundle-命令" class="headerlink" title="Vundle 命令"></a>Vundle 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装插件</span></span><br><span class="line">:BundleInstall</span><br><span class="line"><span class="comment"># 更新插件</span></span><br><span class="line">:BundleUpdate</span><br><span class="line"><span class="comment"># 清除不需要的插件</span></span><br><span class="line">:BundleClean</span><br><span class="line"><span class="comment"># 列出当前的插件</span></span><br><span class="line">:BundleList</span><br><span class="line"><span class="comment"># 搜索插件</span></span><br><span class="line">:BundleSearch</span><br></pre></td></tr></table></figure><h2 id="配置-vimrc文件"><a href="#配置-vimrc文件" class="headerlink" title="配置~/.vimrc文件"></a>配置~/.vimrc文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" 关闭vim的所有扩展功能</span></span><br><span class="line"><span class="string">set nocompatible</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> 配置插件路径</span><br><span class="line"><span class="built_in">set</span> rtp+=~/.vim/bundle/vundle/  </span><br><span class="line">call vundle<span class="comment">#begin()</span></span><br><span class="line"></span><br><span class="line"><span class="string">" 在这里添加你想安装的Vim插件</span></span><br><span class="line"><span class="string">Bundle 'gmarik/vundle'</span></span><br><span class="line"><span class="string">"</span> Python补全强力插件</span><br><span class="line">Bundle <span class="string">'davidhalter/jedi'</span></span><br><span class="line"><span class="string">" 添加引号,括号配对补全</span></span><br><span class="line"><span class="string">Bundle 'jiangmiao/auto-pairs'</span></span><br><span class="line"><span class="string">"</span> 添加/解除注释</span><br><span class="line">Bundle <span class="string">'scrooloose/nerdcommenter'</span></span><br><span class="line"></span><br><span class="line">call vundle<span class="comment">#end()       " required</span></span><br><span class="line"></span><br><span class="line"><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">"</span> 一般设定</span><br><span class="line"><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">"</span> 设定默认解码</span><br><span class="line"><span class="built_in">set</span> fenc=utf-8</span><br><span class="line"><span class="built_in">set</span> fencs=utf-8,usc-bom,euc-jp,gb18030,gbk,gb2312,cp936</span><br><span class="line"></span><br><span class="line"><span class="string">"去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限</span></span><br><span class="line"><span class="string">set nocompatible</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> 显示中文帮助</span><br><span class="line"><span class="keyword">if</span> version &gt;= 603</span><br><span class="line">    <span class="built_in">set</span> helplang=cn</span><br><span class="line">    <span class="built_in">set</span> encoding=utf-8</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"><span class="string">" 语法高亮</span></span><br><span class="line"><span class="string">syntax on</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> 设置配色</span><br><span class="line">colorscheme solarized  <span class="string">"可能需要提前下载</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> 设置字体</span><br><span class="line"><span class="built_in">set</span> guifont=Monaco:h14</span><br><span class="line"></span><br><span class="line"><span class="string">" 设置gvim启动窗口的位置，以及大小</span></span><br><span class="line"><span class="string">"</span> winpos 300 105</span><br><span class="line"><span class="string">" set lines=30 columns=100</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> 开启行号显示</span><br><span class="line"><span class="built_in">set</span> number</span><br><span class="line"></span><br><span class="line"><span class="string">"下面两行在进行编写代码时，在格式对起上很有用；</span></span><br><span class="line"><span class="string">"</span>第一行，vim使用自动对起，也就是把当前行的对起格式应用到下一行；</span><br><span class="line"><span class="string">"第二行，依据上面的对起格式，智能的选择对起方式，对于类似C语言编</span></span><br><span class="line"><span class="string">"</span>写上很有用</span><br><span class="line"><span class="built_in">set</span> autoindent</span><br><span class="line"><span class="built_in">set</span> smartindent</span><br><span class="line"></span><br><span class="line"><span class="string">"查询时非常方便，如要查找book单词，当输入到/b时，会自动找到第一</span></span><br><span class="line"><span class="string">"</span>个b开头的单词，当输入到/bo时，会自动找到第一个bo开头的单词，依</span><br><span class="line"><span class="string">"次类推，进行查找时，使用此设置会快速找到答案，当你找要匹配的单词</span></span><br><span class="line"><span class="string">"</span>时，别忘记回车</span><br><span class="line"><span class="built_in">set</span> incsearch</span><br><span class="line"></span><br><span class="line"><span class="string">" 高亮当前行</span></span><br><span class="line"><span class="string">set cursorline</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> 启动的时候不显示那个援助索马里儿童的提示</span><br><span class="line"><span class="built_in">set</span> shortmess=atI</span><br><span class="line"></span><br><span class="line"><span class="string">" 我的状态行显示的内容（包括文件类型和解码）</span></span><br><span class="line"><span class="string">set statusline=%F%m%r%h%w\[POS=%l,%v][%p%%]\%&#123;strftime(\"%d/%m/%y\ -\ %H:%M\")&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> 总是显示状态行</span><br><span class="line"><span class="built_in">set</span> laststatus=2</span><br><span class="line"></span><br><span class="line"><span class="string">" 制表符为4</span></span><br><span class="line"><span class="string">set tabstop=4</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> 统一缩进为4</span><br><span class="line"><span class="built_in">set</span> softtabstop=4</span><br><span class="line"><span class="built_in">set</span> shiftwidth=4</span><br><span class="line"></span><br><span class="line"><span class="string">" 在c,c++,python文件中用空格代替制表符</span></span><br><span class="line"><span class="string">autocmd FileType c,cpp,python set shiftwidth=4 | set expandtab</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> 侦测文件类型</span><br><span class="line">filetype on</span><br><span class="line"></span><br><span class="line"><span class="string">" 载入文件类型插件</span></span><br><span class="line"><span class="string">filetype plugin on</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> 为特定文件类型载入相关缩进文件</span><br><span class="line">filetype indent on</span><br><span class="line">   <span class="string">" 如果文件类型为.sh文件</span></span><br><span class="line"><span class="string">    if &amp;filetype == 'sh'</span></span><br><span class="line"><span class="string">        call setline(1,</span></span><br><span class="line"><span class="string">        "</span>\<span class="comment">#########################################################################")</span></span><br><span class="line">        call append(line(<span class="string">"."</span>), <span class="string">"\# File Name: "</span>.expand(<span class="string">"%"</span>))</span><br><span class="line">        call append(line(<span class="string">"."</span>)+1, <span class="string">"\# Author: Sheldon"</span>)</span><br><span class="line">        call append(line(<span class="string">"."</span>)+2, <span class="string">"\# mail: tinarychina@gmail.com"</span>)</span><br><span class="line">        call append(line(<span class="string">"."</span>)+3, <span class="string">"\# Created Time: "</span>.strftime(<span class="string">"%F %R"</span>))</span><br><span class="line">        call append(line(<span class="string">"."</span>)+4, <span class="string">"\#########################################################################"</span>)</span><br><span class="line">        call append(line(<span class="string">"."</span>)+5, <span class="string">"\#!/bin/bash"</span>)</span><br><span class="line">        call append(line(<span class="string">"."</span>)+6, <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        call setline(1, <span class="string">"/*************************************************************************"</span>)</span><br><span class="line">        call append(line(<span class="string">"."</span>), <span class="string">"    &gt; File Name: "</span>.expand(<span class="string">"%"</span>))</span><br><span class="line">        call append(line(<span class="string">"."</span>)+1, <span class="string">"    &gt; Author: Sheldon"</span>)</span><br><span class="line">        call append(line(<span class="string">"."</span>)+2, <span class="string">"    &gt; Mail: tinarychina@gmail.com "</span>)</span><br><span class="line">        call append(line(<span class="string">"."</span>)+3, <span class="string">"    &gt; Created Time: "</span>.strftime(<span class="string">"%F %R"</span>))</span><br><span class="line">        call append(line(<span class="string">"."</span>)+4, <span class="string">" ************************************************************************/"</span>)</span><br><span class="line">        call append(line(<span class="string">"."</span>)+5, <span class="string">""</span>)</span><br><span class="line">    endif</span><br><span class="line">    <span class="keyword">if</span> &amp;filetype == <span class="string">'python'</span></span><br><span class="line">        call append(line(<span class="string">"."</span>)+5, <span class="string">"\#!/usr/bin/env python"</span>)</span><br><span class="line">        call append(line(<span class="string">"."</span>)+6, <span class="string">"\#coding: utf-8"</span>)</span><br><span class="line">        call append(line(<span class="string">"."</span>)+7, <span class="string">""</span>)</span><br><span class="line">    endif</span><br><span class="line">    <span class="keyword">if</span> &amp;filetype == <span class="string">'cpp'</span></span><br><span class="line">        call append(line(<span class="string">"."</span>)+6, <span class="string">"#include&lt;iostream&gt;"</span>)</span><br><span class="line">        call append(line(<span class="string">"."</span>)+7, <span class="string">"using namespace std;"</span>)</span><br><span class="line">        call append(line(<span class="string">"."</span>)+8, <span class="string">""</span>)</span><br><span class="line">    endif</span><br><span class="line">    <span class="keyword">if</span> &amp;filetype == <span class="string">'c'</span></span><br><span class="line">        call append(line(<span class="string">"."</span>)+6, <span class="string">"#include&lt;stdio.h&gt;"</span>)</span><br><span class="line">        call append(line(<span class="string">"."</span>)+7, <span class="string">""</span>)</span><br><span class="line">    endif</span><br><span class="line">    <span class="string">" 新建文件后，自动定位到文件末尾</span></span><br><span class="line"><span class="string">    autocmd BufNewFile * normal G</span></span><br><span class="line"><span class="string">endfunc</span></span><br></pre></td></tr></table></figure><h2 id="vim-安装主题"><a href="#vim-安装主题" class="headerlink" title="vim 安装主题"></a>vim 安装主题</h2><p>在<code>~/.vim/</code>路径下新建一个<strong>colors</strong>文件夹，然后下载主题，例如：<a href="https://github.com/tomasr/molokai，将下载好的molokai.vim放入colors文件夹中。" target="_blank" rel="noopener">https://github.com/tomasr/molokai，将下载好的molokai.vim放入colors文件夹中。</a></p><p>使用vim打开<code>~/.vimrc</code>，并添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot; 代码颜色主题</span><br><span class="line">syntax on</span><br><span class="line">syntax enable</span><br><span class="line">set t_Co=256</span><br><span class="line">colorscheme molokai</span><br></pre></td></tr></table></figure></p><p>然后重新打开vim编辑器，就发现主题已经更换了</p>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zsh命令大全</title>
      <link href="/2019/08/28/zsh%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
      <url>/2019/08/28/zsh%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>bash和zsh两种shell功能非常相似，只不过zsh的功能比bash更强大一些。这两种shell的快捷键命令也非常相似，对于常用shell的人来说，了解一些快捷键操作将会十分有益，因为使用快捷键将能大大节约操作时间。大部分快捷键是用来快速导航或编辑当前命令行。</p></blockquote><p>但是！！！</p><p>记不住呀，所以记录一下~</p><a id="more"></a><p>⌃ + u：清空当前行</p><p>⌃ + a：移动到行首</p><p>⌃ + e：移动到行尾</p><p>⌃ + f：向前移动</p><p>⌃ + b：向后移动</p><p>⌃ + p：上一条命令</p><p>⌃ + n：下一条命令</p><p>⌃ + r：搜索历史命令</p><p>⌃ + y：召回最近用命令删除的文字</p><p>⌃ + h：删除光标之前的字符</p><p>⌃ + d：删除光标所指的字符</p><p>⌃ + w：删除光标之前的单词</p><p>⌃ + k：删除从光标到行尾的内容</p><p>⌃ + t：交换光标和之前的字符</p><p>⌘ + Click：可以打开文件，文件夹和链接</p><p>⌘ + n：新建窗口</p><p>⌘ + t：新建标签页</p><p>⌘ + w：关闭当前页</p><p>⌘ + 数字&amp;⌘ + 方向键：切换标签页</p><p>⌥⌘ + 数字：切换窗口</p><p>⌘ + enter：切换全屏</p><p>⌘ + d：左右分屏</p><p>⇧⌘ + d：上下分屏</p><p>⌘ + ;：自动补全历史记录</p><p>⇧⌘ + h：自动补全剪贴板历史</p><p>⌥⌘ + e：查找所有来定位某个标签页</p><p>⌘ + r&amp;⌃ + l：清屏</p><p>⌘ + /：显示光标位置</p><p>⌥⌘ + b：历史回放</p><p>⌘ + f：查找，然后用tab和⇧ + tab可以向右和向左补全，补全之后的内容会被自动复制， 还可以用⌥ + enter将查找结果输入终端</p>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac终端神器--iTerm2</title>
      <link href="/2019/08/28/Mac%E7%BB%88%E7%AB%AF%E7%A5%9E%E5%99%A8-iTerm2/"/>
      <url>/2019/08/28/Mac%E7%BB%88%E7%AB%AF%E7%A5%9E%E5%99%A8-iTerm2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>打造人见人爱的终端</p></blockquote><a id="more"></a><h2 id="下载iTerm2"><a href="#下载iTerm2" class="headerlink" title="下载iTerm2"></a>下载iTerm2</h2><blockquote><p><a href="https://www.iterm2.com/" target="_blank" rel="noopener">官网下载</a></p></blockquote><p>安装完成后，在<code>/bin</code>目录下会多出一个zsh的文件。</p><p>Mac系统默认使用dash作为终端，可以使用命令修改默认使用zsh：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git贮藏（Stashing）</title>
      <link href="/2019/08/22/Git%E8%B4%AE%E8%97%8F%EF%BC%88Stashing%EF%BC%89/"/>
      <url>/2019/08/22/Git%E8%B4%AE%E8%97%8F%EF%BC%88Stashing%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们在工作中经常会遇到一种情况，当我们在项目的当前分支修改了一些代码，工作进行到一半，又需要去其他的分支处理一些事情；这个时候，你不想把修改了一半的代码提交到git，但不提交又无法切到其他分支；怎么办呢？</p></blockquote><a id="more"></a><p>我们可以使用Git的一个功能——Stashing（贮藏）。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>Stashing可以将当前工作区已修改状态下的文件储存起来，在栈中增加一条存储。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="列出所有的存储列表"><a href="#列出所有的存储列表" class="headerlink" title="列出所有的存储列表"></a>列出所有的存储列表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure><h3 id="应用存储"><a href="#应用存储" class="headerlink" title="应用存储"></a>应用存储</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>重新应用最后一次的存储，同时，将其从栈中移走。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><p>通过存储名应用到当前工作区，但并不会从栈中移除。</p><h3 id="取消贮藏"><a href="#取消贮藏" class="headerlink" title="取消贮藏"></a>取消贮藏</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash show -p stash@&#123;0&#125; | git apply -R</span><br></pre></td></tr></table></figure><p>取消之前所应用贮藏的修改。</p><h3 id="移除贮藏"><a href="#移除贮藏" class="headerlink" title="移除贮藏"></a>移除贮藏</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash drop &lt;stash name&gt;</span><br></pre></td></tr></table></figure><p>从栈中移除贮藏</p><h3 id="通过贮藏创建新分支"><a href="#通过贮藏创建新分支" class="headerlink" title="通过贮藏创建新分支"></a>通过贮藏创建新分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash branch &lt;branch name&gt;</span><br></pre></td></tr></table></figure><p>创建一个新的分支，并且检出你贮藏工作时所做的提交，重新应用于你的工作，如果成功，将会丢弃贮藏。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS搭建远程私有库</title>
      <link href="/2019/08/21/iOS%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E7%A7%81%E6%9C%89%E5%BA%93/"/>
      <url>/2019/08/21/iOS%E6%90%AD%E5%BB%BA%E8%BF%9C%E7%A8%8B%E7%A7%81%E6%9C%89%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>iOS搭建远程私有库</p></blockquote><a id="more"></a><h2 id="一、创建远程私有索引库"><a href="#一、创建远程私有索引库" class="headerlink" title="一、创建远程私有索引库"></a>一、创建远程私有索引库</h2><blockquote><p>这个库的作用是存放索引文件</p></blockquote><h2 id="二、将远程索引库链接（下载）到本地"><a href="#二、将远程索引库链接（下载）到本地" class="headerlink" title="二、将远程索引库链接（下载）到本地"></a>二、将远程索引库链接（下载）到本地</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo add &lt;仓库名&gt; &lt;仓库源地址（SSH地址）&gt;</span><br></pre></td></tr></table></figure><h2 id="三、创建远程代码私有仓库"><a href="#三、创建远程代码私有仓库" class="headerlink" title="三、创建远程代码私有仓库"></a>三、创建远程代码私有仓库</h2><h3 id="1-在本地创建-pod-项目"><a href="#1-在本地创建-pod-项目" class="headerlink" title="1. 在本地创建 pod 项目"></a>1. 在本地创建 pod 项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib create &lt;pod库名字&gt;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">Cloning `https://github.com/CocoaPods/pod-template.git` into `&lt;我的pod库名称，手动马赛克&gt;`.</span><br><span class="line">Configuring &lt;我的pod库名称，手动马赛克&gt; template.</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">To get you started we need to ask a few questions, this should only take a minute.</span><br><span class="line"></span><br><span class="line">If this is your first time we recommend running through with the guide:</span><br><span class="line"> - https://guides.cocoapods.org/making/using-pod-lib-create.html</span><br><span class="line"> ( hold cmd and click links to open <span class="keyword">in</span> a browser. )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">What platform <span class="keyword">do</span> you want to use?? [ iOS / macOS ]</span><br><span class="line"> &gt; iOS</span><br><span class="line"></span><br><span class="line">What language <span class="keyword">do</span> you want to use?? [ Swift / ObjC ]</span><br><span class="line"> &gt; ObjC</span><br><span class="line"></span><br><span class="line">Would you like to include a demo application with your library? [ Yes / No ]</span><br><span class="line"> &gt; Yes</span><br><span class="line"></span><br><span class="line">Which testing frameworks will you use? [ Specta / Kiwi / None ]</span><br><span class="line"> &gt; Kiwi</span><br><span class="line"></span><br><span class="line">Would you like to <span class="keyword">do</span> view based testing? [ Yes / No ]</span><br><span class="line"> &gt; Yes</span><br><span class="line"></span><br><span class="line">What is your class prefix?</span><br><span class="line"> &gt; TY</span><br><span class="line"></span><br><span class="line">Running pod install on your new library.</span><br><span class="line"></span><br><span class="line">Analyzing dependencies</span><br><span class="line">Fetching podspec <span class="keyword">for</span> `&lt;我的pod库名称，手动马赛克&gt;` from `../`</span><br><span class="line">Downloading dependencies</span><br><span class="line">Installing &lt;我的pod库名称，手动马赛克&gt; (0.1.0)</span><br><span class="line">Installing FBSnapshotTestCase (2.1.4)</span><br><span class="line">Installing Kiwi (3.0.0)</span><br><span class="line">Generating Pods project</span><br><span class="line">Integrating client project</span><br><span class="line"></span><br><span class="line">[!] Please close any current Xcode sessions and use `&lt;我的pod库名称，手动马赛克&gt;.xcworkspace` <span class="keyword">for</span> this project from now on.</span><br><span class="line">Sending stats</span><br><span class="line">Pod installation complete! There are 3 dependencies from the Podfile and 3 total pods installed.</span><br><span class="line"></span><br><span class="line"> Ace! you<span class="string">'re ready to go!</span></span><br><span class="line"><span class="string"> We will start you off by opening your project in Xcode</span></span><br><span class="line"><span class="string">  open '</span>&lt;我的pod库路径，手动马赛克&gt;<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To learn more about the template see `https://github.com/CocoaPods/pod-template.git`.</span></span><br><span class="line"><span class="string">To learn more about creating a new pod, see `https://guides.cocoapods.org/making/making-a-cocoapod`.</span></span><br></pre></td></tr></table></figure><h3 id="2-修改内容"><a href="#2-修改内容" class="headerlink" title="2. 修改内容"></a>2. 修改内容</h3><p>把需要提交的代码放到路径(当前项目根目录/项目名/Classes/)下面，删除ReplaceMe.m。</p><h3 id="3-修改-podspec文件"><a href="#3-修改-podspec文件" class="headerlink" title="3. 修改.podspec文件"></a>3. 修改.podspec文件</h3><h3 id="4-提交"><a href="#4-提交" class="headerlink" title="4. 提交"></a>4. 提交</h3><p>提交代码到本地pod库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"add file"</span></span><br><span class="line">git remote add origin &lt;远端pod库地址:https://gitlab.com/xxx.git&gt;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>打tag并提交tag到origin</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag 0.1.0</span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><p>验证本地spec文件是否有误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint</span><br></pre></td></tr></table></figure><p>验证远程spec文件是否有误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint</span><br></pre></td></tr></table></figure><p>上传.podspec索引文件到索引库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo push &lt;索引库名称&gt; &lt;.podspec文件名称&gt;  --allow-warnings --use-libraries --verbose</span><br></pre></td></tr></table></figure><p><strong>tip: </strong>消除pod库警告<code>inhibit_all_warnings!</code>。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS常用第三方库整理</title>
      <link href="/2019/08/19/iOS%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%95%B4%E7%90%86/"/>
      <url>/2019/08/19/iOS%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>整理我们在APP开发过程中经常或者必须使用的一些第三方的pod库。</p></blockquote><a id="more"></a><h2 id="主模块"><a href="#主模块" class="headerlink" title="主模块"></a>主模块</h2><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><ul><li><a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">Masonry</a> 代码布局</li><li><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="noopener">UITableView-FDTemplateLayoutCell</a> tableview自适应高度</li></ul><h3 id="指示器"><a href="#指示器" class="headerlink" title="指示器"></a>指示器</h3><ul><li><a href="https://github.com/jdg/MBProgressHUD" target="_blank" rel="noopener">MBProgressHUD</a></li><li><a href="https://github.com/SVProgressHUD/SVProgressHUD" target="_blank" rel="noopener">SVProgressHUD</a></li><li><a href="https://github.com/scalessec/Toast" target="_blank" rel="noopener">Toast</a></li><li><a href="https://github.com/CoderMJLee/MJRefresh" target="_blank" rel="noopener">MJRefresh</a></li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul><li><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a></li><li><a href="https://github.com/yuantiku/YTKNetwork" target="_blank" rel="noopener">YTKNetwork</a></li></ul><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><ul><li><a href="https://github.com/CoderMJLee/MJExtension" target="_blank" rel="noopener">MJExtension</a></li><li><a href="https://github.com/ibireme/YYModel" target="_blank" rel="noopener">YYModel</a></li><li><a href="https://github.com/protocolbuffers/protobuf" target="_blank" rel="noopener">Protobuf</a> 存储和读取结构化数据</li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li><a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">FMDB</a></li><li><a href="https://github.com/Tencent/wcdb" target="_blank" rel="noopener">WCDB</a></li></ul><h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><ul><li>JPush 极光</li></ul><h3 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h3><ul><li>UMengSocial 友盟</li></ul><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><ul><li><a href="https://github.com/SDWebImage/SDWebImage" target="_blank" rel="noopener">SDWebImage</a> 图片下载和缓存</li><li><a href="https://github.com/mwaterfall/MWPhotoBrowser" target="_blank" rel="noopener">MWPhotoBrowser</a> 图片浏览</li><li><a href="https://github.com/Flipboard/FLAnimatedImage" target="_blank" rel="noopener">FLAnimatedImage</a> gif动图加载</li><li><a href="https://github.com/gsdios/SDCycleScrollView" target="_blank" rel="noopener">SDCycleScrollView</a> 轮播图</li></ul><h3 id="音视频"><a href="#音视频" class="headerlink" title="音视频"></a>音视频</h3><ul><li><a href="https://github.com/LaiFengiOS/LFLiveKit" target="_blank" rel="noopener">LFLiveKit</a> RTMP streaming SDK for iOS.</li></ul><h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><ul><li><a href="https://github.com/TTTAttributedLabel/TTTAttributedLabel" target="_blank" rel="noopener">TTTAttributedLabel</a> 富文本</li><li><a href="https://github.com/ibireme/YYText" target="_blank" rel="noopener">YYText</a></li></ul><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><ul><li><a href="https://link.jianshu.com/?t=https://github.com/facebook/pop" target="_blank" rel="noopener">pop</a></li><li><a href="https://github.com/ChenYilong/CYLTabBarController" target="_blank" rel="noopener">CYLTabBarController</a> tabbar 动画</li></ul><h3 id="js-OC交互"><a href="#js-OC交互" class="headerlink" title="js-OC交互"></a>js-OC交互</h3><ul><li><a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="noopener">WebViewJavascriptBridge</a></li></ul><h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><ul><li>Bugly</li><li><a href="https://github.com/kishikawakatsumi/UICKeyChainStore" target="_blank" rel="noopener">UICKeyChainStore</a> 钥匙串API</li><li><a href="https://github.com/tonymillion/Reachability" target="_blank" rel="noopener">Reachability</a> 网络情况监测</li><li><a href="https://github.com/CocoaLumberjack/CocoaLumberjack" target="_blank" rel="noopener">CocoaLumberjack</a> Mac和iOS上一个简捷、强大、灵活的日志框架</li><li><a href="https://github.com/didi/DoraemonKit" target="_blank" rel="noopener">DoraemonKit</a> 一款功能齐全的客户端（ iOS 、Android ）研发助手</li><li><a href="https://github.com/Tencent/MLeaksFinder" target="_blank" rel="noopener">MLeaksFinder</a> 内存泄露</li><li><a href="https://github.com/soffes/SAMKeychain" target="_blank" rel="noopener">SAMKeychain</a> 钥匙串API</li><li><a href="https://github.com/Flipboard/FLEX" target="_blank" rel="noopener">FLEX</a> 可以在app中进行debug</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://github.com/ibireme/YYKit" target="_blank" rel="noopener">YYKit</a></li><li><a href="https://github.com/hackiftekhar/IQKeyboardManager" target="_blank" rel="noopener">IQKeyboardManager</a> 键盘管理</li><li><a href="https://github.com/ReactiveCocoa/ReactiveObjC" target="_blank" rel="noopener">ReactiveObjC</a> RAC</li><li><a href="https://github.com/BlocksKit/BlocksKit" target="_blank" rel="noopener">BlocksKit</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WCDB的使用和封装</title>
      <link href="/2019/08/13/WCDB%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%B0%81%E8%A3%85/"/>
      <url>/2019/08/13/WCDB%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>公司的项目所使用的数据库是FMDB，并对其进行了二次封装；由于年久失修，遂决定改为WCDB，因此，抽时间对WCDB进行了一番研究。<br><a href="https://github.com/Tencent/wcdb" target="_blank" rel="noopener">WCDB</a>是腾讯开源的一款供客户端使用的数据库，基于<a href="https://github.com/sqlcipher/sqlcipher" target="_blank" rel="noopener">SQLCipher</a>，支持iOS，macOS和Android。</p><a id="more"></a><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="易用"><a href="#易用" class="headerlink" title="易用"></a>易用</h3><p>WCDB通过深度封装数据库语言，使开发者可以通过OC或者Swift的代码方式使用数据库，无需为了拼接SQL而写一大坨代码；</p><h3 id="高效"><a href="#高效" class="headerlink" title="高效"></a>高效</h3><p>WCDB通过框架层和<a href="https://github.com/sqlcipher/sqlcipher" target="_blank" rel="noopener">SQLCipher</a>源码优化，使其有更高效的表现；</p><h3 id="完整"><a href="#完整" class="headerlink" title="完整"></a>完整</h3><p>WCDB覆盖了数据库使用过程中大多数的使用场景和需求；</p><ul><li><strong>加密：</strong>WCDB提供基于<a href="https://github.com/sqlcipher/sqlcipher" target="_blank" rel="noopener">SQLCipher</a>的数据库加密。</li><li><strong>损坏修复：</strong>WCDB内建了Repair Kit用于修复损坏的数据库。</li><li><strong>反注入：</strong>WCDB内建了对SQL注入的保护。</li></ul><h2 id="安装WCDB"><a href="#安装WCDB" class="headerlink" title="安装WCDB"></a>安装WCDB</h2><p>使用Cocoapods安装WCDB：</p><ol><li>更新pod repo：<code>pod repo update</code></li><li>在Podfile对应的target中，添加<code>pod &#39;WCDB&#39;</code></li><li>执行<code>pod install --verbose</code></li><li>打开workspace</li><li>引入头文件’#import <wcdb wcdb.h>‘</wcdb></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用WCD分为2部分：<strong>ORM</strong>和<strong>CRUD</strong>。</p><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>ORM的作用就是映射数据库字段和我们的数据模型；WCDB使用内置的宏来连接类、属性与表、字段。共有三类宏，分别对应数据库的字段、索引和约束。</p><h4 id="字段宏"><a href="#字段宏" class="headerlink" title="字段宏"></a>字段宏</h4><p>字段宏以WCDB_SYNTHESIZE开头，定义了类属性与字段之间的联系。</p><ul><li><code>WCDB_SYNTHESIZE(className, propertyName)</code>是最简单的的用法，直接使用propertyName作为数据库中字段的名称。</li><li><code>WCDB_SYNTHESIZE_COLUMN(className, propertyName, columnName)</code>支持自定义字段名。</li><li><code>WCDB_SYNTHESIZE_DEFAULT(className, propertyName, defaultValue)</code>自定义字段默认值（可以是任意C类型或NSString, NSData, NSNumber, NSNull）。</li><li><code>WCDB_SYNTHESIZE_COLUMN_DEFAULT(className, propertyName, cloumnName, defaultValue)</code>。</li></ul><p><a href="https://github.com/Tencent/wcdb/blob/master/objc/sample/orm/WCTSampleORM.mm" target="_blank" rel="noopener">字段宏参考</a></p><h4 id="索引宏"><a href="#索引宏" class="headerlink" title="索引宏"></a>索引宏</h4><p>索引宏以WCDB_INDEX开头，定义了数据库的索引属性。支持定义索引的排序方式。</p><ul><li><code>WCDB_INDEX(className, indexSubfixName, propertyName)</code>是基础用法，直接指定某个字段为索引。同时，WCDB会将tableName + indexSubfixName作为该索引的名字。</li><li><code>WCDB_INDEX_ASC(className, indexSubfixName, propertyName)</code>升序。</li><li><code>WCDB_INDEX_DESC(className, indexSubfixName, propertyName)</code>降序。</li><li><code>WCDB_UNIQUE_INDEX(className, indexSubfixName, propertyName)</code>唯一索引。</li><li><code>WCDB_UNIQUE_INDEX_ASC(className, indexSubfixName, propertyName)</code>唯一索引升序排列。</li><li><code>WCDB_UNIQUE_INDEX_DESC(className, indexSubfixName, propertyName)</code>唯一索引降序排列。</li></ul><p>WCDB通过<code>indexSubfixName</code>匹配多索引。相同的<code>indexSubfixName</code>会被组合为多字段索引。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WCDB_INDEX(WCTSampleORMIndex, &quot;_multiIndexSubfix&quot;, multiIndexPart1)</span><br><span class="line">WCDB_INDEX(WCTSampleORMIndex, &quot;_multiIndexSubfix&quot;, multiIndexPart2)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Tencent/wcdb/blob/master/objc/sample/orm/WCTSampleORMIndex.mm" target="_blank" rel="noopener">索引宏例子</a></p><h4 id="约束宏"><a href="#约束宏" class="headerlink" title="约束宏"></a>约束宏</h4><p>约束宏包含了<strong>字段约束</strong>和<strong>表约束</strong>。</p><h5 id="字段约束"><a href="#字段约束" class="headerlink" title="字段约束"></a>字段约束</h5><p>主键约束以WCDB_PRIMARY开头，定义了数据库的主键；支持自定义主键的排序方式、是否自增。</p><ul><li><code>WCDB_PRIMARY(className, propertyName)</code>是基础用法，直接使用propertyName作为数据库的主键。</li><li><code>WCDB_PRIMARY_ASC(className, propertyName)</code>主键升序。</li><li><code>WCDB_PRIMARY_DESC(className, propertyName)</code>主键降序。</li><li><code>WCDB_PRIMARY_AUTO_INCREMENT(className, propertyName)</code>主键自增。</li><li><code>WCDB_PRIMARY_ASC_AUTO_INCREMENT(className, propertyName)</code>主键自增及升序的组合。</li><li><code>WCDB_PRIMARY_DESC_AUTO_INCREMENT(className, propertyName)</code>主键自增及降序组合。</li></ul><p>非空约束：<code>WCDB_NOT_NULL(className, propertyName)</code>，当该字段插入数据为空时，数据库会返回错误。<br>唯一约束：<code>WCDB_UNIQUE(className, propertyName)</code>，当该字段插入数据与其他列冲突时，数据库会返回错误。</p><p><strong>注意：</strong>使用了主键自增后，创建的模型必须设置<code>isAutoIncrement</code>为YES。</p><h5 id="表约束"><a href="#表约束" class="headerlink" title="表约束"></a>表约束</h5><p>多主键约束以<code>WCDB_MULTI_PRIMARY</code>开头，定义了数据库的多主键，支持自定义每个主键的排序方式。</p><ul><li><code>WCDB_MULTI_PRIMARY(className, constraintName, propertyName)</code>为基础用法，多个主键通过constrainName匹配。</li><li><code>WCDB_MULTI_PRIMARY_ASC(className, constraintName, propertyName)</code>多主键升序。</li><li><code>WCDB_MULTI_PRIMARY_DESC(className, constraintName, propertyName)</code>多主键降序。</li></ul><p>多字段唯一约束以<code>WCDB_MULTI_UNIQUE</code>开头，定义了数据库的多字段组合唯一，支持自定义每个字段的排序方式。</p><ul><li><code>WCDB_MULTI_UNIQUE(className, constraintName, propertyName)</code>基础用法。</li><li><code>WCDB_MULTI_UNIQUE_ASC(className, constraintName, propertyName)</code>升序。</li><li><code>WCDB_MULTI_UNIQUE_DESC(className, constraintName, propertyName)</code>降序。</li></ul><p><a href="https://github.com/Tencent/wcdb/blob/master/objc/sample/orm/WCTSampleORMTableConstraint.mm" target="_blank" rel="noopener">表约束示例</a></p><h4 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h4><p>由于SQLite只支持增加字段，并不支持删除和重命名字段。因此，WCDB在删除字段的时候只是将其定义删除；删除定义后，WCDB只是将该字段忽略，其旧数据依然在数据库中，但新增的数据基本<strong>不会因为该字段产生额外的性能和空间损耗</strong>。<br>由于SQLite不支持修改字段名称，所以WCDB采用重新映射的方式。</p><h3 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h3><p>WCDB提供了三个基础类进行数据库操作：<code>WCTDatabase</code>、<code>WCTTable</code>、<code>WCTTransaction</code>。它们的接口都是<strong>线程安全的</strong>。</p><h4 id="WCTDatabase"><a href="#WCTDatabase" class="headerlink" title="WCTDatabase"></a>WCTDatabase</h4><p>表示一个数据库，可以进行所有的数据库操作。</p><h5 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h5><p><code>WCTDatabase</code>通过<code>initWithPath:</code>接口进行创建。该接口会同时创建path中不存在的目录。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span>* path = <span class="string">@"&lt;这里是数据库路径&gt;"</span>;</span><br><span class="line">WCTDatabase *database = [[WCTDatabase alloc] initWithPath:path];</span><br></pre></td></tr></table></figure><h5 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h5><p>WCDB采用懒加载的方式管理对象，因此SQLite连接会在第一次被访问的时候打开。开发者<strong>不需要手动打开数据库</strong>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断数据库是否能够打开</span></span><br><span class="line"><span class="keyword">if</span> ([database canOpen]) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断数据库是否已经打开</span></span><br><span class="line"><span class="keyword">if</span> ([database isOpened]) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="关闭数据库"><a href="#关闭数据库" class="headerlink" title="关闭数据库"></a>关闭数据库</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[database close];</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>由于WCDB支持多线程访问数据库，因此，该接口会阻塞等待所有线程均已操作结束。</p><p>对于一个特定路径的数据库，WCDB会在所有对象对其的引用结束时，自动关闭数据库，并且回收内存和SQLite连接。因此，大多数的时候，开发者并<strong>不需要手动关闭数据库</strong>。</p><h4 id="WCTTable"><a href="#WCTTable" class="headerlink" title="WCTTable"></a>WCTTable</h4><p>表示一个表。等价于预设了<code>class</code>和<code>tableName</code>的<code>WCTDatabase</code>，仅可以进行数据库的CRUD。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WCTTable* table = [database getTableOfName:tableName</span><br><span class="line">                                 withClass:WCTSampleTable.class];</span><br></pre></td></tr></table></figure><h4 id="WCTTransaction"><a href="#WCTTransaction" class="headerlink" title="WCTTransaction"></a>WCTTransaction</h4><p>表示一个事务。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WCTTransaction *transaction = [database getTransaction];</span><br></pre></td></tr></table></figure><p>与WCTDatabase的事务不同，WCTTransaction可以在函数和对象之间传递，实现跨线程的事务。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//You can do a transaction in different threads using WCTTransaction.</span></span><br><span class="line"><span class="comment">//But it's better to run serially, or an inner thread mutex will guarantee this.</span></span><br><span class="line"><span class="built_in">BOOL</span> ret = [transaction begin];</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_queue_create(<span class="string">"other thread"</span>, DISPATCH_QUEUE_SERIAL), ^&#123;</span><br><span class="line">  WCTSampleTransaction *object = [[WCTSampleTransaction alloc] init];</span><br><span class="line">  <span class="built_in">BOOL</span> ret = [transaction insertObject:object</span><br><span class="line">                                  into:tableName];</span><br><span class="line">  <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">      [transaction commit];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      [transaction rollback];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="CRUD操作"><a href="#CRUD操作" class="headerlink" title="CRUD操作"></a>CRUD操作</h4><h5 id="创建数据库-1"><a href="#创建数据库-1" class="headerlink" title="创建数据库"></a>创建数据库</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> ret = [database createTableAndIndexesOfName:tableName</span><br><span class="line">                                       withClass:WCTSampleTable.class];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> ret = [database createTableOfName:tableName</span><br><span class="line">                     withColumnDefList:&#123;</span><br><span class="line">                     WCTSampleTable.intValue.def(WCTColumnTypeInteger32),</span><br><span class="line">                     WCTSampleTable.stringValue.def(WCTColumnTypeString)</span><br><span class="line">           &#125;];</span><br></pre></td></tr></table></figure><h5 id="将数据插入表"><a href="#将数据插入表" class="headerlink" title="将数据插入表"></a>将数据插入表</h5><ul><li><code>insertObject:into:和insertObjects:into:</code>，插入单个或多个对象</li><li><code>insertOrReplaceObject:into</code>和<code>insertOrReplaceObjects:into</code>，插入单个或多个对象。当对象的主键在数据库内已经存在时，更新数据；否则插入对象。</li><li><code>insertObject:onProperties:into:</code>和<code>insertObjects:onProperties:into:</code>，插入单个或多个对象的部分属性</li><li><code>insertOrReplaceObject:onProperties:into</code>和<code>insertOrReplaceObjects:onProperties:into</code>，插入单个或多个对象的部分属性。当对象的主键在数据库内已经存在时，更新数据；否则插入对象。</li></ul><h5 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h5><ul><li><code>deleteAllObjectsFromTable:</code>删除表内的所有数据</li><li><code>deleteObjectsFromTable:</code>后可组合接 where、orderBy、limit、offset以删除部分数据</li></ul><h5 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h5><ul><li><code>updateAllRowsInTable:onProperties:withObject:</code>，通过object更新数据库中所有指定列的数据</li><li><code>updateRowsInTable:onProperties:withObject:</code>后可组合接 where、orderBy、limit、offset以通过object更新指定列的部分数据</li><li><code>updateAllRowsInTable:onProperty:withObject:</code>，通过object更新数据库某一列的数据</li><li><code>updateRowsInTable:onProperty:withObject:</code>后可组合接 where、orderBy、limit、offset以通过object更新某一列的部分数据</li><li><code>updateAllRowsInTable:onProperties:withRow:</code>，通过数组更新数据库中的所有指定列的数据</li><li><code>updateRowsInTable:onProperties:withRow:</code>后可组合接 where、orderBy、limit、offset以通过数组更新指定列的部分数据</li><li><code>updateAllRowsInTable:onProperty:withRow:</code>，通过数组更新数据库某一列的数据</li><li><code>updateRowsInTable:onProperty:withRow:</code>后可组合接 where、orderBy、limit、offset以通过数组更新某一列的部分数</li></ul><h5 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h5><ul><li><code>getOneObjectOfClass:fromTable:</code>后可接 where、orderBy、limit、offset以从数据库中取出一行数据并组合成object</li><li><code>getOneObjectOnResults:fromTable:</code>后可接 where、orderBy、limit、offset以从数据库中取出一行数据的部分列并组合成object</li><li><code>getOneRowOnResults:fromTable:</code>后可接 where、orderBy、limit、offset以从数据库中取出一行数据的部分列并组合成数组</li><li><code>getOneColumnOnResult:fromTable:</code>后可接 where、orderBy、limit、offset以从数据库中取出一列数据并组合成数组</li><li><code>getOneDistinctColumnOnResult:fromTable:</code>后可接 where、orderBy、limit、offset以从数据库中取出一列数据，并取distinct后组合成数组。</li><li><code>getOneValueOnResult:fromTable:</code>后可接 where、orderBy、limit、offset以从数据库中取出一行数据的某一列</li><li><code>getAllObjectsOfClass:fromTable:</code>，取出所有数据，并组合成object</li><li><code>getObjectsOfClass:fromTable:</code>后可接 where、orderBy、limit、offset以从数据库中取出一部分数据，并组合成object</li><li><code>getAllObjectsOnResults:fromTable:</code>，取出所有数据的指定列，并组合成object</li><li><code>getObjectsOnResults:fromTable:</code>后可接where、orderBy、limit、offset以从数据库中取出一部分数据的指定列，并组合成object</li><li><code>getAllRowsOnResults:fromTable:</code>，取出所有数据的指定列，并组合成数组</li><li><code>getRowsOnResults:fromTable:</code>后可接where、orderBy、limit、offset以从数据库中取出一部分数据的指定列，并组合成数组</li></ul><p><a href="https://github.com/Tencent/wcdb/blob/master/objc/sample/convenient/sample_convenient_main.mm" target="_blank" rel="noopener">CRUD示例</a></p><h5 id="链式接口"><a href="#链式接口" class="headerlink" title="链式接口"></a>链式接口</h5><p>WCDB对于增删改查操作，都提供了对应的类以实现链式调用</p><ul><li>WCTInsert</li><li>WCTDelete</li><li>WCTUpdate</li><li>WCTSelect</li><li>WCTRowSelect</li><li>WCTMultiSelect</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WCTSelect *select = [database prepareSelectObjectsOnResults:Message.localID.max()</span><br><span class="line">                                                  fromTable:<span class="string">@"message"</span>];</span><br><span class="line"><span class="built_in">NSArray</span>&lt;Message *&gt; *objects = [[[[select where:Message.localID &gt; <span class="number">0</span>] </span><br><span class="line">                               groupBy:&#123;Message.content&#125;]</span><br><span class="line">                                    orderBy:Message.createTime.order()] </span><br><span class="line">                                     limit:<span class="number">10</span>].allObjects;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><h4 id="调试SQL"><a href="#调试SQL" class="headerlink" title="调试SQL"></a>调试SQL</h4><p>[WCTStatistics SetGlobalSQLTrace:]会监控所有执行的SQL，该接口可用于调试，确定SQL是否执行正确。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SQL Execution Monitor</span></span><br><span class="line">[WCTStatistics SetGlobalSQLTrace:^(<span class="built_in">NSString</span> *sql) &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"SQL: %@"</span>, sql);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h4 id="WINQ"><a href="#WINQ" class="headerlink" title="WINQ"></a>WINQ</h4><h4 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h4><h4 id="隔离C-代码"><a href="#隔离C-代码" class="headerlink" title="隔离C++代码"></a>隔离C++代码</h4><h4 id="关于数据库加密"><a href="#关于数据库加密" class="headerlink" title="关于数据库加密"></a>关于数据库加密</h4><h4 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h4><h5 id="主键自增-Auto-Increment"><a href="#主键自增-Auto-Increment" class="headerlink" title="主键自增(Auto Increment)"></a>主键自增(Auto Increment)</h5><h5 id="as重定向"><a href="#as重定向" class="headerlink" title="as重定向"></a>as重定向</h5><h5 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h5><h4 id="基础类共享"><a href="#基础类共享" class="headerlink" title="基础类共享"></a>基础类共享</h4><p>对于同一个路径的数据库，不同的<code>WCTDatabase</code>、<code>WCTTable</code>、<code>WCTTransaction</code>对象共享同一个WCDB核心。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WCTDatabase* database1 = [[WCTDatabase alloc] initWithPath:path];</span><br><span class="line">WCTDatabase* database2 = [[WCTDatabase alloc] initWithPath:path];</span><br><span class="line">database1.tag = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, database2.tag);<span class="comment">//print 1</span></span><br></pre></td></tr></table></figure><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p>WCDB提供了删除数据库、移动数据库、获取数据库占用空间和使用路径的文件操作接口。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)removeFilesWithError:(WCTError **)error;</span><br><span class="line">- (<span class="built_in">BOOL</span>)moveFilesToDirectory:(<span class="built_in">NSString</span> *)directory withExtraFiles:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)extraFiles andError:(WCTError **)error;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)getPaths;</span><br><span class="line">- (<span class="built_in">NSUInteger</span>)getFilesSizeWithError:(WCTError **)error;</span><br></pre></td></tr></table></figure><p>若是一个线程正在操作数据库，而另一个线程进行移动数据库的操作，可能会导致数据库的损坏；因此，文件操作通常放在关闭数据库后。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[database close:^&#123;</span><br><span class="line">  WCTError *error = <span class="literal">nil</span>;</span><br><span class="line">  <span class="built_in">BOOL</span> ret = [database moveFilesToDirectory:otherDirectory withError:&amp;error];</span><br><span class="line">  <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"Move files Error %@"</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jenkins执行GitHub中的Python代码</title>
      <link href="/2019/08/13/jenkins%E6%89%A7%E8%A1%8CGitHub%E4%B8%AD%E7%9A%84Python%E4%BB%A3%E7%A0%81/"/>
      <url>/2019/08/13/jenkins%E6%89%A7%E8%A1%8CGitHub%E4%B8%AD%E7%9A%84Python%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>jenkins是很好用的一个自动化测试和执行代码的工具，<a href="https://sheldon.top/2019/08/12/jenkins%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/" target="_blank" rel="noopener">查看如何安装jenkins</a>;</p><p>我们的代码是存储在代码仓库里面的，一般，我们使用GitHub来存放我们的代码；</p><p>那么，怎么使用jenkins来直接执行我们存放在GitHub中的代码呢？</p><a id="more"></a><h2 id="jenkins-创建一个任务"><a href="#jenkins-创建一个任务" class="headerlink" title="jenkins 创建一个任务"></a>jenkins 创建一个任务</h2><p><img src="https://s2.ax1x.com/2019/08/13/mCdKhR.jpg" alt="jenkins创建任务"></p><h2 id="配置jenkins"><a href="#配置jenkins" class="headerlink" title="配置jenkins"></a>配置jenkins</h2><h3 id="选择GitHub项目"><a href="#选择GitHub项目" class="headerlink" title="选择GitHub项目"></a>选择GitHub项目</h3><p><img src="https://s2.ax1x.com/2019/08/13/mC0QOK.jpg" alt="填写项目地址"></p><h3 id="填写源码管理"><a href="#填写源码管理" class="headerlink" title="填写源码管理"></a>填写源码管理</h3><p><img src="https://s2.ax1x.com/2019/08/13/mCBfCd.jpg" alt="源码管理"></p><p>如果没有凭证，就点击Credentials右边的<strong>添加</strong><br><img src="https://s2.ax1x.com/2019/08/13/mCrrTO.jpg" alt="添加凭证"><br><strong>注意：</strong>这里添加的是SSH的私钥</p><h4 id="如何查询自己的ssh密钥？"><a href="#如何查询自己的ssh密钥？" class="headerlink" title="如何查询自己的ssh密钥？"></a>如何查询自己的ssh密钥？</h4><ol><li><p>进入ssh文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure></li><li><p>查看私钥文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa</span><br></pre></td></tr></table></figure></li></ol><h3 id="定时构建（可选）"><a href="#定时构建（可选）" class="headerlink" title="定时构建（可选）"></a>定时构建（可选）</h3><p><img src="https://s2.ax1x.com/2019/08/13/mCspAU.jpg" alt="定时构建"></p><h3 id="每次构建之前清空一下Jenkins工作空间，避免拉取的代码有冲突"><a href="#每次构建之前清空一下Jenkins工作空间，避免拉取的代码有冲突" class="headerlink" title="每次构建之前清空一下Jenkins工作空间，避免拉取的代码有冲突"></a>每次构建之前清空一下Jenkins工作空间，避免拉取的代码有冲突</h3><p><img src="https://s2.ax1x.com/2019/08/13/mCswCQ.jpg" alt="清空工作空间"></p><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>在构建选项中选择<strong>增加构建步骤-&gt;Execute shell</strong>;</p><p>然后填写需要执行的脚本：<br><img src="https://s2.ax1x.com/2019/08/13/mCyGRJ.jpg" alt="执行脚本"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>点击保存，然后就可以build我的项目啦！</p>]]></content>
      
      
      <categories>
          
          <category> jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git本地库连接远端库</title>
      <link href="/2019/08/13/git%E6%9C%AC%E5%9C%B0%E5%BA%93%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%AB%AF%E5%BA%93/"/>
      <url>/2019/08/13/git%E6%9C%AC%E5%9C%B0%E5%BA%93%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%AB%AF%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>我们使用git有时候会有这种情况：<br>我们只在本地创建了git仓库，并没有在GitHub上创建远端仓库；当我们在本的的git仓库提交了几次修改后，想要将此git仓库放在GitHub，那么我们需要怎么做呢？<br><a id="more"></a></p><h2 id="连接远程仓库"><a href="#连接远程仓库" class="headerlink" title="连接远程仓库"></a>连接远程仓库</h2><p>假设我们已经在GitHub上创建了一个空的仓库</p><p>先cd到我们本地git仓库所在的目录,然后执行git连接操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:FlameTinary/TYPythonTools.git</span><br></pre></td></tr></table></figure><h2 id="错误步骤"><a href="#错误步骤" class="headerlink" title="错误步骤"></a>错误步骤</h2><p>然后执行<code>git pull</code>，会发现，报错了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">warning: no common commits</span><br><span class="line">remote: Enumerating objects: 4, done.</span><br><span class="line">remote: Counting objects: 100% (4/4), done.</span><br><span class="line">remote: Compressing objects: 100% (4/4), done.</span><br><span class="line">Unpacking objects: 100% (4/4), done.</span><br><span class="line">remote: Total 4 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">From github.com:FlameTinary/TYPythonTools</span><br><span class="line"> * [new branch]      master     -&gt; origin/master</span><br><span class="line">There is no tracking information for the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(1) for details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to set tracking information for this branch you can do so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; master</span><br><span class="line"></span><br><span class="line"> ✘ sheldon@tianyudeMacBook-Pro  ~/Documents/TYPythonTools   master  git pull remote master</span><br><span class="line">fatal: &apos;remote&apos; does not appear to be a git repository</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure><p>执行<code>git pull origin master --allow-unrelated-histories</code>也不行；</p><p>那么怎么办呢？</p><h2 id="正确步骤"><a href="#正确步骤" class="headerlink" title="正确步骤"></a>正确步骤</h2><p>原来是我们本的的branch和远端的branch无法对应起来；</p><p>可以执行<code>git branch --set-upstream-to=origin/master master</code>，会出现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Branch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;origin&apos;.</span><br></pre></td></tr></table></figure><p>然后我们再执行<code>git pull origin master --allow-unrelated-histories</code>；</p><p>最后将本地内容推送到远端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>大功告成！！</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><h3 id="1-连接远端仓库"><a href="#1-连接远端仓库" class="headerlink" title="1. 连接远端仓库"></a>1. 连接远端仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:FlameTinary/TYPythonTools.git</span><br></pre></td></tr></table></figure><h3 id="2-连接分支"><a href="#2-连接分支" class="headerlink" title="2. 连接分支"></a>2. 连接分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/master master</span><br></pre></td></tr></table></figure><h3 id="3-拉取远端代码"><a href="#3-拉取远端代码" class="headerlink" title="3. 拉取远端代码"></a>3. 拉取远端代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure><h3 id="4-推送本地代码到远端"><a href="#4-推送本地代码到远端" class="headerlink" title="4. 推送本地代码到远端"></a>4. 推送本地代码到远端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决jenkins在装有anaconda环境的机器上执行Python文件，Python环境错误的问题</title>
      <link href="/2019/08/13/%E8%A7%A3%E5%86%B3jenkins%E5%9C%A8%E8%A3%85%E6%9C%89anaconda%E7%8E%AF%E5%A2%83%E7%9A%84%E6%9C%BA%E5%99%A8%E4%B8%8A%E6%89%A7%E8%A1%8CPython%E6%96%87%E4%BB%B6%EF%BC%8CPython%E7%8E%AF%E5%A2%83%E9%94%99%E8%AF%AF%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2019/08/13/%E8%A7%A3%E5%86%B3jenkins%E5%9C%A8%E8%A3%85%E6%9C%89anaconda%E7%8E%AF%E5%A2%83%E7%9A%84%E6%9C%BA%E5%99%A8%E4%B8%8A%E6%89%A7%E8%A1%8CPython%E6%96%87%E4%BB%B6%EF%BC%8CPython%E7%8E%AF%E5%A2%83%E9%94%99%E8%AF%AF%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>使用jenkins定时执行某些任务或者执行测试是很方便的一个工作，但是有些时候如果碰到一些环境或者冲突方面的问题也是比较头疼的。<br><a id="more"></a></p><p>python分为2.7和3.0以上两个大版本，所以一些朋友的电脑中会同时存在这两种版本。由于我的电脑是MacBook pro， 所以系统中自动安装的2.7的版本。</p><p>但我需要使用3.7的版本作为主要开发，且系统中的2.7版本也不能删除，因为系统的一些功能需要依赖2.7的版本。</p><p>所以，在经过双版本的折腾后，还是选择了Anaconda的怀抱。</p><p>以前一直使用Jenkins自动执行iOS程序，最近写了一个Python的工具，需要定时执行，所以也是用Jenkins来操作；但是，问题来了，在Jenkins中的<code>Execute shell</code>中直接写了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python <span class="string">"文件路径"</span></span><br></pre></td></tr></table></figure><p>这样却报错了…</p><p><img src="https://s2.ax1x.com/2019/08/13/m9JIQe.jpg" alt="jenkins错误"></p><p>可是明明在Terminal中执行没有问题啊！！</p><p>第一次猜测可能是Jenkins找不到python的路径，所以在Jenkins -&gt; Manage Jenkins -&gt; Configure System -&gt; 全局属性 -&gt; Environment variables -&gt; 中添加了Python的路径，然并卵！</p><p><img src="https://s2.ax1x.com/2019/08/13/m9JxSS.jpg" alt="配置python在jenkins中的路径"></p><p>继续折腾，既然找不到包，那么我就把包放在工程文件所在的路径中，最后还是找不到!</p><p>最后直接使用python绝对路径执行文件</p><p><img src="https://s2.ax1x.com/2019/08/13/m9YAYV.jpg" alt="路径执行python"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/anaconda3/bin/python ~/Documents/TYPythonTools/TYChartRobot.py</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Command Line Tools 使用</title>
      <link href="/2019/08/12/Command-Line-Tools-%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/08/12/Command-Line-Tools-%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><h3 id="查看目前我使用的工具XCODE版本"><a href="#查看目前我使用的工具XCODE版本" class="headerlink" title="查看目前我使用的工具XCODE版本"></a>查看目前我使用的工具XCODE版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># command</span></span><br><span class="line">xcode-select --<span class="built_in">print</span>-path</span><br><span class="line"></span><br><span class="line"><span class="comment"># print</span></span><br><span class="line">/Applications/Xcode.app/Contents/Developer</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="选择XCODE中的默认版本用于我的命令行工具"><a href="#选择XCODE中的默认版本用于我的命令行工具" class="headerlink" title="选择XCODE中的默认版本用于我的命令行工具"></a>选择XCODE中的默认版本用于我的命令行工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># command</span></span><br><span class="line">sudo xcode-select -switch &lt;path/to/&gt;Xcode.app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释</span></span><br><span class="line">`&lt;path/to/&gt;`是路径要使用的开发Xcode.app包</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line">sudo xcode-select -switch /Applications/Xcode5.1.1/Xcode.app</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><code>xcodebuild</code>是一个命令行工具，可以让你的工程通过<code>projects</code>、<code>workspaces</code>进行编译、测试、分析、打包。它可以运行在包含一个或多个Target的工程上面，或者在<code>projects</code> 、<code>workspaces</code>包含<code>scheme</code>上面。</p><h3 id="列出所有的Target"><a href="#列出所有的Target" class="headerlink" title="列出所有的Target"></a>列出所有的Target</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># command</span></span><br><span class="line">xcodebuild -list -project &lt;your project name&gt;.xcodeproj</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释</span></span><br><span class="line">`&lt;your project name&gt;`是你工程的名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">xcodebuild -list -project TYDemos.xcodeproj</span><br><span class="line"></span><br><span class="line"><span class="comment"># print </span></span><br><span class="line">Information about project <span class="string">"TYDemos"</span>:</span><br><span class="line">    Targets:</span><br><span class="line">        TYDemos</span><br><span class="line">        qwer</span><br><span class="line"></span><br><span class="line">    Build Configurations:</span><br><span class="line">        Debug</span><br><span class="line">        Release</span><br><span class="line"></span><br><span class="line">    If no build configuration is specified and -scheme is not passed <span class="keyword">then</span> <span class="string">"Release"</span> is used.</span><br><span class="line"></span><br><span class="line">    Schemes:</span><br><span class="line">        qwer</span><br><span class="line">        TYDemos</span><br></pre></td></tr></table></figure><h3 id="编译你工程的配置和schemes"><a href="#编译你工程的配置和schemes" class="headerlink" title="编译你工程的配置和schemes"></a>编译你工程的配置和schemes</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># command</span></span><br><span class="line">xcodebuild -scheme &lt;your scheme name&gt; build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释</span></span><br><span class="line">`&lt;your scheme name&gt;`是你选择特定的编译和执行的一个scheme</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">xocdebuild -scheme TYGameSceneDemo build</span><br><span class="line"></span><br><span class="line"><span class="comment"># print</span></span><br><span class="line">note: Using new build system</span><br><span class="line">note: Planning build</span><br><span class="line">2019-06-13 11:23:50.516 xcodebuild[61408:7436815]  DTDeviceKit: deviceType from 00008006-000F29961AC1002E was NULL</span><br><span class="line">2019-06-13 11:23:50.516 xcodebuild[61408:7436815]  DTDeviceKit: deviceType from 00008006-000F29961AC1002E was NULL</span><br><span class="line">2019-06-13 11:23:50.516 xcodebuild[61408:7436815]  iPhoneSupport: 📱&lt;DVTiOSDevice (0x7ff824b6d8b0), Sheldon’s iPhone 7plus, iPhone, 12.2 (16E227), 312a7baecea95257c11a5eb61d1203138faac05c&gt; unable to mount DeveloperDiskImage (Error Domain=com.apple.dtdevicekit Code=601 <span class="string">"Could not find platform"</span> UserInfo=&#123;NSLocalizedDescription=Could not find platform&#125;)</span><br><span class="line">note: Constructing build description</span><br><span class="line">CreateBuildDirectory /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    <span class="built_in">builtin</span>-create-build-directory /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products</span><br><span class="line"></span><br><span class="line">CreateBuildDirectory /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    <span class="built_in">builtin</span>-create-build-directory /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex</span><br><span class="line"></span><br><span class="line">MkDir /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    /bin/mkdir -p /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app</span><br><span class="line"></span><br><span class="line">ProcessProductPackaging /Users/sheldon/Library/MobileDevice/Provisioning\ Profiles/e91c7402-e02a-45ac-aff3-c73c563abcfb.mobileprovision /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app/embedded.mobileprovision (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    <span class="built_in">builtin</span>-productPackagingUtility /Users/sheldon/Library/MobileDevice/Provisioning\ Profiles/e91c7402-e02a-45ac-aff3-c73c563abcfb.mobileprovision -o /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app/embedded.mobileprovision</span><br><span class="line"></span><br><span class="line">WriteAuxiliaryFile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/DerivedSources/Entitlements.plist (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    write-file /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/DerivedSources/Entitlements.plist</span><br><span class="line"></span><br><span class="line">ProcessProductPackaging <span class="string">""</span> /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo.app.xcent (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Entitlements:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"application-identifier"</span> = <span class="string">"CC9XV3GRSV.top.sheldon.TYGameSceneDemo"</span>;</span><br><span class="line">    <span class="string">"com.apple.developer.team-identifier"</span> = CC9XV3GRSV;</span><br><span class="line">    <span class="string">"get-task-allow"</span> = 1;</span><br><span class="line">    <span class="string">"keychain-access-groups"</span> =     (</span><br><span class="line">        <span class="string">"CC9XV3GRSV.top.sheldon.TYGameSceneDemo"</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">builtin</span>-productPackagingUtility -entitlements -format xml -o /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo.app.xcent</span><br><span class="line"></span><br><span class="line">WriteAuxiliaryFile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/all-product-headers.yaml (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    write-file /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/all-product-headers.yaml</span><br><span class="line"></span><br><span class="line">WriteAuxiliaryFile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo.hmap (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    write-file /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo.hmap</span><br><span class="line"></span><br><span class="line">WriteAuxiliaryFile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-project-headers.hmap (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    write-file /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-project-headers.hmap</span><br><span class="line"></span><br><span class="line">WriteAuxiliaryFile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-own-target-headers.hmap (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    write-file /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-own-target-headers.hmap</span><br><span class="line"></span><br><span class="line">WriteAuxiliaryFile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-generated-files.hmap (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    write-file /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-generated-files.hmap</span><br><span class="line"></span><br><span class="line">WriteAuxiliaryFile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-all-non-framework-target-headers.hmap (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    write-file /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-all-non-framework-target-headers.hmap</span><br><span class="line"></span><br><span class="line">WriteAuxiliaryFile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-all-target-headers.hmap (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    write-file /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-all-target-headers.hmap</span><br><span class="line"></span><br><span class="line">CompileC /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/GameViewController.o /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/GameViewController.m normal arm64 objective-c com.apple.compilers.llvm.clang.1_0.compiler (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    <span class="built_in">export</span> LANG=en_US.US-ASCII</span><br><span class="line">    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -x objective-c -arch arm64 -fmessage-length=178 -fdiagnostics-show-note-include-stack -fmacro-backtrace-limit=0 -fcolor-diagnostics -std=gnu11 -fobjc-arc -fobjc-weak -fmodules -gmodules -fmodules-cache-path=/Users/sheldon/Library/Developer/Xcode/DerivedData/ModuleCache.noindex -fmodules-prune-interval=86400 -fmodules-prune-after=345600 -fbuild-session-file=/Users/sheldon/Library/Developer/Xcode/DerivedData/ModuleCache.noindex/Session.modulevalidation -fmodules-validate-once-per-build-session -Wnon-modular-include-in-framework-module -Werror=non-modular-include-in-framework-module -Wno-trigraphs -fpascal-strings -O0 -fno-common -Wno-missing-field-initializers -Wno-missing-prototypes -Werror=<span class="built_in">return</span>-type -Wdocumentation -Wunreachable-code -Wno-implicit-atomic-properties -Werror=deprecated-objc-isa-usage -Wno-objc-interface-ivars -Werror=objc-root-class -Wno-arc-repeated-use-of-weak -Wimplicit-retain-self -Wduplicate-method-match -Wno-missing-braces -Wparentheses -Wswitch -Wunused-function -Wno-unused-label -Wno-unused-parameter -Wunused-variable -Wunused-value -Wempty-body -Wuninitialized -Wconditional-uninitialized -Wno-unknown-pragmas -Wno-shadow -Wno-four-char-constants -Wno-conversion -Wconstant-conversion -Wint-conversion -Wbool-conversion -Wenum-conversion -Wno-float-conversion -Wnon-literal-null-conversion -Wobjc-literal-conversion -Wshorten-64-to-32 -Wpointer-sign -Wno-newline-eof -Wno-selector -Wno-strict-selector-match -Wundeclared-selector -Wdeprecated-implementations -DDEBUG=1 -DOBJC_OLD_DISPATCH_PROTOTYPES=0 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS12.2.sdk -fstrict-aliasing -Wprotocol -Wdeprecated-declarations -miphoneos-version-min=12.2 -g -Wno-sign-conversion -Winfinite-recursion -Wcomma -Wblock-capture-autoreleasing -Wstrict-prototypes -Wno-semicolon-before-method-body -Wunguarded-availability -fembed-bitcode-marker -index-store-path /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Index/DataStore -iquote /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-generated-files.hmap -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-own-target-headers.hmap -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-all-target-headers.hmap -iquote /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-project-headers.hmap -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/include -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/DerivedSources-normal/arm64 -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/DerivedSources/arm64 -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/DerivedSources -F/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos -MMD -MT dependencies -MF /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/GameViewController.d --serialize-diagnostics /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/GameViewController.dia -c /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/GameViewController.m -o /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/GameViewController.o</span><br><span class="line"></span><br><span class="line">CompileC /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/AppDelegate.o /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/AppDelegate.m normal arm64 objective-c com.apple.compilers.llvm.clang.1_0.compiler (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    <span class="built_in">export</span> LANG=en_US.US-ASCII</span><br><span class="line">    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -x objective-c -arch arm64 -fmessage-length=178 -fdiagnostics-show-note-include-stack -fmacro-backtrace-limit=0 -fcolor-diagnostics -std=gnu11 -fobjc-arc -fobjc-weak -fmodules -gmodules -fmodules-cache-path=/Users/sheldon/Library/Developer/Xcode/DerivedData/ModuleCache.noindex -fmodules-prune-interval=86400 -fmodules-prune-after=345600 -fbuild-session-file=/Users/sheldon/Library/Developer/Xcode/DerivedData/ModuleCache.noindex/Session.modulevalidation -fmodules-validate-once-per-build-session -Wnon-modular-include-in-framework-module -Werror=non-modular-include-in-framework-module -Wno-trigraphs -fpascal-strings -O0 -fno-common -Wno-missing-field-initializers -Wno-missing-prototypes -Werror=<span class="built_in">return</span>-type -Wdocumentation -Wunreachable-code -Wno-implicit-atomic-properties -Werror=deprecated-objc-isa-usage -Wno-objc-interface-ivars -Werror=objc-root-class -Wno-arc-repeated-use-of-weak -Wimplicit-retain-self -Wduplicate-method-match -Wno-missing-braces -Wparentheses -Wswitch -Wunused-function -Wno-unused-label -Wno-unused-parameter -Wunused-variable -Wunused-value -Wempty-body -Wuninitialized -Wconditional-uninitialized -Wno-unknown-pragmas -Wno-shadow -Wno-four-char-constants -Wno-conversion -Wconstant-conversion -Wint-conversion -Wbool-conversion -Wenum-conversion -Wno-float-conversion -Wnon-literal-null-conversion -Wobjc-literal-conversion -Wshorten-64-to-32 -Wpointer-sign -Wno-newline-eof -Wno-selector -Wno-strict-selector-match -Wundeclared-selector -Wdeprecated-implementations -DDEBUG=1 -DOBJC_OLD_DISPATCH_PROTOTYPES=0 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS12.2.sdk -fstrict-aliasing -Wprotocol -Wdeprecated-declarations -miphoneos-version-min=12.2 -g -Wno-sign-conversion -Winfinite-recursion -Wcomma -Wblock-capture-autoreleasing -Wstrict-prototypes -Wno-semicolon-before-method-body -Wunguarded-availability -fembed-bitcode-marker -index-store-path /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Index/DataStore -iquote /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-generated-files.hmap -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-own-target-headers.hmap -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-all-target-headers.hmap -iquote /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-project-headers.hmap -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/include -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/DerivedSources-normal/arm64 -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/DerivedSources/arm64 -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/DerivedSources -F/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos -MMD -MT dependencies -MF /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/AppDelegate.d --serialize-diagnostics /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/AppDelegate.dia -c /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/AppDelegate.m -o /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/AppDelegate.o</span><br><span class="line"></span><br><span class="line">WriteAuxiliaryFile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/TYGameSceneDemo.LinkFileList (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    write-file /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/TYGameSceneDemo.LinkFileList</span><br><span class="line"></span><br><span class="line">CompileC /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/main.o /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/main.m normal arm64 objective-c com.apple.compilers.llvm.clang.1_0.compiler (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    <span class="built_in">export</span> LANG=en_US.US-ASCII</span><br><span class="line">    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -x objective-c -arch arm64 -fmessage-length=178 -fdiagnostics-show-note-include-stack -fmacro-backtrace-limit=0 -fcolor-diagnostics -std=gnu11 -fobjc-arc -fobjc-weak -fmodules -gmodules -fmodules-cache-path=/Users/sheldon/Library/Developer/Xcode/DerivedData/ModuleCache.noindex -fmodules-prune-interval=86400 -fmodules-prune-after=345600 -fbuild-session-file=/Users/sheldon/Library/Developer/Xcode/DerivedData/ModuleCache.noindex/Session.modulevalidation -fmodules-validate-once-per-build-session -Wnon-modular-include-in-framework-module -Werror=non-modular-include-in-framework-module -Wno-trigraphs -fpascal-strings -O0 -fno-common -Wno-missing-field-initializers -Wno-missing-prototypes -Werror=<span class="built_in">return</span>-type -Wdocumentation -Wunreachable-code -Wno-implicit-atomic-properties -Werror=deprecated-objc-isa-usage -Wno-objc-interface-ivars -Werror=objc-root-class -Wno-arc-repeated-use-of-weak -Wimplicit-retain-self -Wduplicate-method-match -Wno-missing-braces -Wparentheses -Wswitch -Wunused-function -Wno-unused-label -Wno-unused-parameter -Wunused-variable -Wunused-value -Wempty-body -Wuninitialized -Wconditional-uninitialized -Wno-unknown-pragmas -Wno-shadow -Wno-four-char-constants -Wno-conversion -Wconstant-conversion -Wint-conversion -Wbool-conversion -Wenum-conversion -Wno-float-conversion -Wnon-literal-null-conversion -Wobjc-literal-conversion -Wshorten-64-to-32 -Wpointer-sign -Wno-newline-eof -Wno-selector -Wno-strict-selector-match -Wundeclared-selector -Wdeprecated-implementations -DDEBUG=1 -DOBJC_OLD_DISPATCH_PROTOTYPES=0 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS12.2.sdk -fstrict-aliasing -Wprotocol -Wdeprecated-declarations -miphoneos-version-min=12.2 -g -Wno-sign-conversion -Winfinite-recursion -Wcomma -Wblock-capture-autoreleasing -Wstrict-prototypes -Wno-semicolon-before-method-body -Wunguarded-availability -fembed-bitcode-marker -index-store-path /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Index/DataStore -iquote /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-generated-files.hmap -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-own-target-headers.hmap -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-all-target-headers.hmap -iquote /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo-project-headers.hmap -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/include -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/DerivedSources-normal/arm64 -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/DerivedSources/arm64 -I/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/DerivedSources -F/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos -MMD -MT dependencies -MF /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/main.d --serialize-diagnostics /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/main.dia -c /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/main.m -o /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/main.o</span><br><span class="line"></span><br><span class="line">Ld /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app/TYGameSceneDemo normal arm64 (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    <span class="built_in">export</span> IPHONEOS_DEPLOYMENT_TARGET=12.2</span><br><span class="line">    /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -arch arm64 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS12.2.sdk -L/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos -F/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos -filelist /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/TYGameSceneDemo.LinkFileList -Xlinker -rpath -Xlinker @executable_path/Frameworks -miphoneos-version-min=12.2 -dead_strip -Xlinker -object_path_lto -Xlinker /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/TYGameSceneDemo_lto.o -Xlinker -export_dynamic -Xlinker -no_deduplicate -fembed-bitcode-marker -fobjc-arc -fobjc-link-runtime -Xlinker -dependency_info -Xlinker /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Objects-normal/arm64/TYGameSceneDemo_dependency_info.dat -o /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app/TYGameSceneDemo</span><br><span class="line"></span><br><span class="line">Copy SceneKit assets /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/art.scnassets (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    /Applications/Xcode.app/Contents/Developer/usr/bin/copySceneKitAssets /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/art.scnassets -o /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app/art.scnassets --target-platform=iphoneos --target-version=12.2 --target-build-dir=/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos --resources-folder-path=TYGameSceneDemo.app</span><br><span class="line">copySceneKitAssets: Copy ship.scn</span><br><span class="line">copySceneKitAssets: Copy texture.png</span><br><span class="line">copySceneKitAssets: Running scntool on /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app/art.scnassets/ship.scn</span><br><span class="line"></span><br><span class="line">CompileAssetCatalog /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/Assets.xcassets (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    /Applications/Xcode.app/Contents/Developer/usr/bin/actool --output-format human-readable-text --notices --warnings --<span class="built_in">export</span>-dependency-info /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/assetcatalog_dependencies --output-partial-info-plist /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/assetcatalog_generated_info.plist --app-icon AppIcon --compress-pngs --<span class="built_in">enable</span>-on-demand-resources YES --sticker-pack-identifier-prefix top.sheldon.TYGameSceneDemo.sticker-pack. --target-device iphone --target-device ipad --minimum-deployment-target 12.2 --platform iphoneos --product-type com.apple.product-type.application --compile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/Assets.xcassets</span><br><span class="line">/* com.apple.actool.compilation-results */</span><br><span class="line">/Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/assetcatalog_generated_info.plist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CompileStoryboard /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/Base.lproj/Main.storyboard (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    <span class="built_in">export</span> XCODE_DEVELOPER_USR_PATH=/Applications/Xcode.app/Contents/Developer/usr/bin/..</span><br><span class="line">    /Applications/Xcode.app/Contents/Developer/usr/bin/ibtool --errors --warnings --notices --module TYGameSceneDemo --output-partial-info-plist /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Base.lproj/Main-SBPartialInfo.plist --auto-activate-custom-fonts --target-device iphone --target-device ipad --minimum-deployment-target 12.2 --output-format human-readable-text --compilation-directory /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Base.lproj /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/Base.lproj/Main.storyboard</span><br><span class="line"></span><br><span class="line">CompileStoryboard /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/Base.lproj/LaunchScreen.storyboard (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    <span class="built_in">export</span> XCODE_DEVELOPER_USR_PATH=/Applications/Xcode.app/Contents/Developer/usr/bin/..</span><br><span class="line">    /Applications/Xcode.app/Contents/Developer/usr/bin/ibtool --errors --warnings --notices --module TYGameSceneDemo --output-partial-info-plist /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Base.lproj/LaunchScreen-SBPartialInfo.plist --auto-activate-custom-fonts --target-device iphone --target-device ipad --minimum-deployment-target 12.2 --output-format human-readable-text --compilation-directory /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Base.lproj /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/Base.lproj/LaunchScreen.storyboard</span><br><span class="line"></span><br><span class="line">ProcessInfoPlistFile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app/Info.plist /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/Info.plist (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    <span class="built_in">builtin</span>-infoPlistUtility /Users/sheldon/Documents/TYDemos/TYGameSceneDemo/TYGameSceneDemo/Info.plist -producttype com.apple.product-type.application -genpkginfo /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app/PkgInfo -expandbuildsettings -format binary -platform iphoneos -additionalcontentfile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Base.lproj/LaunchScreen-SBPartialInfo.plist -additionalcontentfile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Base.lproj/Main-SBPartialInfo.plist -additionalcontentfile /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/assetcatalog_generated_info.plist -requiredArchitecture arm64 -o /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app/Info.plist</span><br><span class="line"></span><br><span class="line">LinkStoryboards (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    <span class="built_in">export</span> XCODE_DEVELOPER_USR_PATH=/Applications/Xcode.app/Contents/Developer/usr/bin/..</span><br><span class="line">    /Applications/Xcode.app/Contents/Developer/usr/bin/ibtool --errors --warnings --notices --module TYGameSceneDemo --target-device iphone --target-device ipad --minimum-deployment-target 12.2 --output-format human-readable-text --link /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Base.lproj/LaunchScreen.storyboardc /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/Base.lproj/Main.storyboardc</span><br><span class="line"></span><br><span class="line">CodeSign /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    <span class="built_in">export</span> CODESIGN_ALLOCATE=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/codesign_allocate</span><br><span class="line"></span><br><span class="line">Signing Identity:     <span class="string">"iPhone Developer: sheldondev@163.com (***********)"</span></span><br><span class="line">Provisioning Profile: <span class="string">"iOS Team Provisioning Profile: top.sheldon.TYGameSceneDemo"</span></span><br><span class="line">                      (e91c7402-e02a-45ac-aff3-c73c563abcfb)</span><br><span class="line"></span><br><span class="line">    /usr/bin/codesign --force --sign A4F946689397857CA5F807E9FFB76913085216E4 --entitlements /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Intermediates.noindex/TYGameSceneDemo.build/Debug-iphoneos/TYGameSceneDemo.build/TYGameSceneDemo.app.xcent --timestamp=none /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app</span><br><span class="line"></span><br><span class="line">Validate /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    <span class="built_in">builtin</span>-validationUtility /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app</span><br><span class="line"></span><br><span class="line">Touch /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app (<span class="keyword">in</span> target: TYGameSceneDemo)</span><br><span class="line">    <span class="built_in">cd</span> /Users/sheldon/Documents/TYDemos/TYGameSceneDemo</span><br><span class="line">    /usr/bin/touch -c /Users/sheldon/Library/Developer/Xcode/DerivedData/TYGameSceneDemo-fnnafecckruutfccltqcqgjtvkco/Build/Products/Debug-iphoneos/TYGameSceneDemo.app</span><br><span class="line"></span><br><span class="line">** BUILD SUCCEEDED **</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/55b80e746e38" target="_blank" rel="noopener">通过Xcode命令行编译</a><br><a href="https://www.jianshu.com/p/9b8bc8351223" target="_blank" rel="noopener">用xcconfig文件配置iOS app环境变量</a><br><a href="https://developer.apple.com/library/archive/technotes/tn2339/_index.html#//apple_ref/doc/uid/DTS40014588-CH1-HOW_DO_I_BUILD_MY_PROJECTS_FROM_THE_COMMAND_LINE_" target="_blank" rel="noopener">官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> hide </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java注解</title>
      <link href="/2019/08/12/java%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/08/12/java%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h2><p>注解，顾名思义，注解,就是对某一事物进行添加注释说明，会存放一些信息，这些信息可能对以后某个时段来说是很有用处的。<br><a id="more"></a></p><h2 id="java中的注解"><a href="#java中的注解" class="headerlink" title="java中的注解"></a>java中的注解</h2><p>Java注解又叫java标注，java提供了一套机制，使得我们可以对方法、类、参数、包、域以及变量等添加标准(即附上某些信息)。且在以后某个时段通过反射将标注的信息提取出来以供使用。</p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><h3 id="为什么自定义注解"><a href="#为什么自定义注解" class="headerlink" title="为什么自定义注解"></a>为什么自定义注解</h3><p>Java从1.5版本以后默认内置三个标注：</p><ul><li><code>@Override</code>:只能用在方法之上的，用来告诉别人这一个方法是改写父类的。</li><li><code>@Deprecated</code>:建议别人不要使用旧的API的时候用的,编译的时候会用产生警告信息,可以设定在程序里的所有的元素上。</li><li><code>@SuppressWarnings</code>:这一个类型可以来暂时把一些警告信息消息关闭。<br>但是，仅仅这三个标注是不能满足我们开发时一些需求的。所以java允许我们自定义注解来使用。<h3 id="怎么自定义注解"><a href="#怎么自定义注解" class="headerlink" title="怎么自定义注解"></a>怎么自定义注解</h3>自定义步骤大致分为两步：</li></ul><ol><li>通过<code>@interface</code>关键字声明注解名称，以及注解的成员属性或者叫做注解的参数。</li><li>使用java内置的四个元注解对这个自定义标注的功能和范围进行一些限制。</li></ol><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>元注解，就是定义注解的注解，也就是说这些元注解是的作用就是专门用来约束其它注解的注解。请区别上面那三个注解，他们也是通过元注解定义而来的。<br>元注解有哪些呢，主要有四个<code>@Target</code>,<code>@Retention</code>,<code>@Documented</code>,<code>@Inherited</code></p><ul><li><code>@Target</code> 表示该注解用于什么地方，可能的 ElemenetType 参数包括： <ul><li><code>ElemenetType.CONSTRUCTOR</code> 构造器声明 </li><li><code>ElemenetType.FIELD</code> 域声明（包括 enum 实例） </li><li><code>ElemenetType.LOCAL_VARIABLE</code> 局部变量声明 </li><li><code>ElemenetType.METHOD</code> 方法声明 </li><li><code>ElemenetType.PACKAGE</code> 包声明 </li><li><code>ElemenetType.PARAMETER</code> 参数声明 </li><li><code>ElemenetType.TYPE</code> 类，接口（包括注解类型）或enum声明 </li></ul></li><li><code>@Retention</code> 表示在什么级别保存该注解信息。可选的 RetentionPolicy 参数包括： <ul><li><code>RetentionPolicy.SOURCE</code> 注解将被编译器丢弃 </li><li><code>RetentionPolicy.CLASS</code> 注解在class文件中可用，但会被VM丢弃 </li><li><code>RetentionPolicy.RUNTIME</code> VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。 </li></ul></li><li><code>@Documented</code> 将此注解包含在 javadoc 中 </li><li><code>@Inherited</code> 允许子类继承父类中的注解 <h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE) <span class="comment">// 这个标注用于类</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME) <span class="comment">//这个标注会一直保留到运行时</span></span><br><span class="line"><span class="meta">@Documented</span> <span class="comment">// 将此注解包含在javadoc中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TYDescription &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">Value</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TYName &#123;</span><br><span class="line">    <span class="function">String <span class="title">originate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">community</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TYName</span>(originate = <span class="string">"Sheldon"</span>, community = <span class="string">"sheldon.com"</span>)</span><br><span class="line"><span class="meta">@TYDescription</span>(Value = <span class="string">"desc String!!!"</span>)</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
      
      
      <categories>
          
          <category> hide </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kvocontroller使用和解析</title>
      <link href="/2019/08/12/kvocontroller%E4%BD%BF%E7%94%A8%E5%92%8C%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/08/12/kvocontroller%E4%BD%BF%E7%94%A8%E5%92%8C%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/facebook/KVOController" target="_blank" rel="noopener">facebook/KVOController</a>是对Cocoa中KVO的封装。它提供简单、现代的API，并且是线程安全的。优点如下：</p><ul><li>通知是通过block、action或者NSKeyValueObserving回调（即-observeValueForKeyPath:ofObject:change:context）来实现；</li><li>不会出现移除observer的异常；</li><li>在controller销毁时隐式地移除observer；</li><li>保证了线程安全。<br>简单地说，KVOController让我们更优雅、简单、安全地使用KVO。</li></ul><a id="more"></a><h2 id="使用KVOController"><a href="#使用KVOController" class="headerlink" title="使用KVOController"></a>使用KVOController</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入框架</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;KVOController/KVOController.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="comment">// 设置示例模型和示例按钮</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)TestModel *model;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)<span class="built_in">UIButton</span> *button;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置KVO</span></span><br><span class="line">FBKVOController *kvoController = [FBKVOController controllerWithObserver:<span class="keyword">self</span>];</span><br><span class="line"><span class="keyword">self</span>.KVOController = kvoController;</span><br><span class="line"><span class="comment">//设置model</span></span><br><span class="line"><span class="keyword">self</span>.model = [TestModel new];</span><br><span class="line"><span class="keyword">self</span>.model.name = <span class="string">@"hah"</span>;</span><br><span class="line"><span class="comment">// 添加一个button</span></span><br><span class="line"><span class="keyword">self</span>.button = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeSystem</span>];</span><br><span class="line"><span class="keyword">self</span>.button.frame = <span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">[<span class="keyword">self</span>.button setTitle:<span class="keyword">self</span>.model.name forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">[<span class="keyword">self</span>.button addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(buttonClick:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.button];</span><br><span class="line"><span class="comment">//添加监听</span></span><br><span class="line">[<span class="keyword">self</span>.KVOController observe:<span class="keyword">self</span>.model</span><br><span class="line">                    keyPath:FBKVOKeyPath(_model.name)</span><br><span class="line">                    options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                      block:^(<span class="keyword">id</span>  _Nullable observer, <span class="keyword">id</span>  _Nonnull object, <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; * _Nonnull change)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, change);</span><br><span class="line">     <span class="built_in">NSString</span> *title = (<span class="built_in">NSString</span> *)change[<span class="string">@"new"</span>];</span><br><span class="line">     [<span class="keyword">self</span>.button setTitle:title forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// button 点击方法</span></span><br><span class="line">- (<span class="keyword">void</span>)buttonClick:(<span class="built_in">UIButton</span> *)sender &#123;</span><br><span class="line">    <span class="keyword">self</span>.model.name = [<span class="keyword">self</span>.model.name isEqual: <span class="string">@"hah"</span>] ? <span class="string">@"gogo"</span> : <span class="string">@"hah"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><ul><li><a href="https://www.jianshu.com/p/8deccb9c8398" target="_blank" rel="noopener">KVOController详解</a></li><li><a href="https://draveness.me/kvocontroller" target="_blank" rel="noopener">如何优雅地使用 KVO</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> hide </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notification与多线程</title>
      <link href="/2019/08/12/Notification%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/08/12/Notification%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>原文：</p><blockquote><p>In a multithreaded application, notifications are always delivered in the thread in which the notification was posted, which may not be the same thread in which an observer registered itself.</p></blockquote><p>翻译：</p><blockquote><p>在多线程应用中，Notification在哪个线程中post，就在哪个线程中被转发，而不一定是在注册观察者的那个线程中。</p></blockquote><a id="more"></a><p>举个🌰：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主线程中add</span></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(observerSelect) name:<span class="string">@"qwer"</span> object:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"1.current thread -- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子线程中post</span></span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3.current thread -- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@"qwer"</span> object:<span class="literal">nil</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observerSelect &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"2.current thread -- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-26</span> <span class="number">11</span>:<span class="number">24</span>:<span class="number">29.987543</span>+<span class="number">0800</span> timerTest[<span class="number">46207</span>:<span class="number">2785353</span>] <span class="number">1.</span>current thread -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x600002814d00</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-26</span> <span class="number">11</span>:<span class="number">24</span>:<span class="number">33.270912</span>+<span class="number">0800</span> timerTest[<span class="number">46207</span>:<span class="number">2785409</span>] <span class="number">3.</span>current thread -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x60000284e880</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-26</span> <span class="number">11</span>:<span class="number">24</span>:<span class="number">33.271095</span>+<span class="number">0800</span> timerTest[<span class="number">46207</span>:<span class="number">2785409</span>] <span class="number">2.</span>current thread -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x60000284e880</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure></p><p>虽然我们在主线程中注册了通知者，但在全局队列中post，并不是在主线程中处理的，所以，我们在处理回调结果时，一定要注意线程问题。</p><p>那么，我们如何能在子线程中post，在主线程中进行处理呢？</p><p>看看官方文档：</p><blockquote><p>For example, if an object running in a background thread is listening for notifications from the user interface, such as a window closing, you would like to receive the notifications in the background thread instead of the main thread. In these cases, you must capture the notifications as they are delivered on the default thread and redirect them to the appropriate thread.</p></blockquote><p>翻译：</p><blockquote><p>例如，如果在后台线程中运行的对象正在侦听来自用户界面的通知（例如关闭窗口），则您希望在后台线程而不是主线程中接收通知。在这些情况下，您必须捕获在默认线程上传递的通知，并将它们重定向到相应的线程。</p></blockquote><p>根据官方文档修改我们上面的例子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> () &lt;<span class="title">NSMachPortDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span>    *notifications;         <span class="comment">// 通知队列</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSThread</span>          *notificationThread;    <span class="comment">// 期望线程</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSLock</span>            *notificationLock;      <span class="comment">// 用于对通知队列加锁的锁对象，避免线程冲突</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSMachPort</span>        *notificationPort;      <span class="comment">// 用于向期望线程发送信号的通信端口</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">self</span>.notifications = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line"><span class="keyword">self</span>.notificationLock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">self</span>.notificationThread = [<span class="built_in">NSThread</span> currentThread];</span><br><span class="line"><span class="keyword">self</span>.notificationPort = [[<span class="built_in">NSMachPort</span> alloc] init];</span><br><span class="line"><span class="keyword">self</span>.notificationPort.delegate = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 往当前线程的run loop添加端口源</span></span><br><span class="line"><span class="comment">// 当Mach消息到达而接收线程的run loop没有运行时，则内核会保存这条消息，直到下一次进入run loop</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:<span class="keyword">self</span>.notificationPort</span><br><span class="line">                            forMode:(__bridge <span class="built_in">NSString</span> *)kCFRunLoopCommonModes];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(observerSelectNotification:) name:<span class="string">@"qwer"</span> object:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"1.current thread -- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    </span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"3.current thread -- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@"qwer"</span> object:<span class="literal">nil</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Delegates are sent this if they respond, otherwise they</span></span><br><span class="line"><span class="comment">// are sent handlePortMessage:; argument is the raw Mach message</span></span><br><span class="line">- (<span class="keyword">void</span>)handleMachMessage:(<span class="keyword">void</span> *)msg&#123;</span><br><span class="line">    [<span class="keyword">self</span>.notificationLock lock];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"5.current thread -- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="keyword">while</span> ([<span class="keyword">self</span>.notifications count]) &#123;</span><br><span class="line">        <span class="built_in">NSNotification</span> *notification = [<span class="keyword">self</span>.notifications objectAtIndex:<span class="number">0</span>];</span><br><span class="line">        [<span class="keyword">self</span>.notifications removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">        [<span class="keyword">self</span>.notificationLock unlock];</span><br><span class="line">        [<span class="keyword">self</span> observerSelectNotification:notification];</span><br><span class="line">        [<span class="keyword">self</span>.notificationLock lock];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.notificationLock unlock];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observerSelectNotification:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSThread</span> currentThread] != _notificationThread) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"4.current thread -- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="comment">// Forward the notification to the correct thread.</span></span><br><span class="line">        [<span class="keyword">self</span>.notificationLock lock];</span><br><span class="line">        [<span class="keyword">self</span>.notifications addObject:notification];</span><br><span class="line">        [<span class="keyword">self</span>.notificationLock unlock];</span><br><span class="line">        [<span class="keyword">self</span>.notificationPort sendBeforeDate:[<span class="built_in">NSDate</span> date]</span><br><span class="line">                                   components:<span class="literal">nil</span></span><br><span class="line">                                         from:<span class="literal">nil</span></span><br><span class="line">                                     reserved:<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2.current thread -- %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"process notification"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-26</span> <span class="number">11</span>:<span class="number">58</span>:<span class="number">30.826178</span>+<span class="number">0800</span> timerTest[<span class="number">47621</span>:<span class="number">2830678</span>] <span class="number">1.</span>current thread -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x6000023c93c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-26</span> <span class="number">11</span>:<span class="number">58</span>:<span class="number">33.826488</span>+<span class="number">0800</span> timerTest[<span class="number">47621</span>:<span class="number">2830764</span>] <span class="number">3.</span>current thread -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x600002388740</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-26</span> <span class="number">11</span>:<span class="number">58</span>:<span class="number">33.826702</span>+<span class="number">0800</span> timerTest[<span class="number">47621</span>:<span class="number">2830764</span>] <span class="number">4.</span>current thread -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x600002388740</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-26</span> <span class="number">11</span>:<span class="number">58</span>:<span class="number">33.826899</span>+<span class="number">0800</span> timerTest[<span class="number">47621</span>:<span class="number">2830678</span>] <span class="number">5.</span>current thread -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x6000023c93c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-26</span> <span class="number">11</span>:<span class="number">58</span>:<span class="number">33.827061</span>+<span class="number">0800</span> timerTest[<span class="number">47621</span>:<span class="number">2830678</span>] <span class="number">2.</span>current thread -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x6000023c93c0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2019</span><span class="number">-03</span><span class="number">-26</span> <span class="number">11</span>:<span class="number">58</span>:<span class="number">33.827151</span>+<span class="number">0800</span> timerTest[<span class="number">47621</span>:<span class="number">2830678</span>] process notification</span><br></pre></td></tr></table></figure></p><p>可以看到，我们在全局dispatch队列中抛出的Notification，如愿地在主线程中接收到了。</p><p>这种实现方式的具体解析及其局限性大家可以参考官方文档<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Notifications/Articles/Threading.html#//apple_ref/doc/uid/20001289-CEGJFDFG" target="_blank" rel="noopener">Delivering Notifications To Particular Threads</a>，在此不多做解释。当然，更好的方法可能是我们自己去子类化一个NSNotificationCenter，或者单独写一个类来处理这种转发。</p><p>参考：</p><ul><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Notifications/Articles/Notifications.html" target="_blank" rel="noopener">Notification Programming Topics</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html" target="_blank" rel="noopener">Threading Programming Guide</a></li><li><a href="http://southpeak.github.io/2015/03/14/nsnotification-and-multithreading/" target="_blank" rel="noopener">Notification与多线程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> hide </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下配置多个ssh-key</title>
      <link href="/2019/08/12/Mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAssh-key/"/>
      <url>/2019/08/12/Mac%E4%B8%8B%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AAssh-key/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在我们的工作经常会遇到公司的git仓库需要配置SSH-Key，而自己的github也需要配置SSH-Key，如果你不想使用同一个SSH-Key，那么可以生成多个SSH-Key，从而分别配置不同的仓库。</p></blockquote><a id="more"></a><p>打开终端，查看当前<code>~/.ssh</code>路径中存在的SSH-Key：<br><img src="/Users/sheldon/Pictures/Xnip2019-05-28_15-54-48.jpg" alt></p><p>我的路径下已经存在了一个SSH-Key了，那么接下来再创建一个SSH-Key:</p><p><img src="/Users/sheldon/Pictures/Xnip2019-05-28_15-57-34.jpg" alt></p><p>使用命令创建：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"这里填写你的邮箱地址"</span></span><br></pre></td></tr></table></figure></p><p>在<code>Enter file in which to save the key (&lt;文件路径&gt;):</code>这里输入自定义的SSH-Key名称<strong>（必须写，不然会默认覆盖原来的Key）</strong></p><p>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (&lt;文件路径&gt;): id_rsa_github</span><br></pre></td></tr></table></figure></p><p>然后输入密码（密码不可见）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure></p><p>当看到这样的字样，说明创建成功了：<br><img src="/Users/sheldon/Pictures/Xnip2019-05-28_16-01-35.jpg" alt></p><p>将SSH-Key添加到ssh-agent中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add id_rsa_github</span><br></pre></td></tr></table></figure></p><p>输入密码:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase <span class="keyword">for</span> id_rsa_github:</span><br></pre></td></tr></table></figure></p><p>添加成功：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Identity added: id_rsa_github (&lt;邮箱地址&gt;)</span><br></pre></td></tr></table></figure></p><p>查看公钥：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa_github.pub</span><br></pre></td></tr></table></figure></p><p>将公钥配置到github的ssh-key中；最后验证是否联通：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><p>成功字样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi &lt;这里是github的用户名&gt;! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jenkins 打包流程</title>
      <link href="/2019/08/12/jenkins%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/"/>
      <url>/2019/08/12/jenkins%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="安装jenkins"><a href="#安装jenkins" class="headerlink" title="安装jenkins"></a>安装jenkins</h2><p>我们使用Homebrew安装jenkins</p><a id="more"></a><h3 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a>安装Homebrew</h3><ol><li>首先确认机器有没有安装Homebrew</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew -v</span><br></pre></td></tr></table></figure><ol><li>如果未安装，则安装Homebrew</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><ol><li>安装java环境</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install Caskroom/cask/java</span><br></pre></td></tr></table></figure><p>由于现在的java最高版本为12.0，jenkins不支持，所以我们安装一个第三方的java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install homebrew/cask-versions/adoptopenjdk8</span><br></pre></td></tr></table></figure><ol><li>安装jenkins</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install jenkins</span><br></pre></td></tr></table></figure><ol><li>链接文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sfv /usr/local/opt/jenkins/*.plist ~/Library/LaunchAgents</span><br></pre></td></tr></table></figure><ol><li>启动jenkins</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">launchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hide </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人简历</title>
      <link href="/2019/03/28/curriculumVitae/"/>
      <url>/2019/03/28/curriculumVitae/</url>
      
        <content type="html"><![CDATA[<h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><style>table th:nth-of-type(1) {    width: 20%;}</style><table><thead><tr><th style="text-align:left">姓名 / 性别</th><th style="text-align:left">田宇 / 男</th></tr></thead><tbody><tr><td style="text-align:left">专业</td><td style="text-align:left">网络工程</td></tr><tr><td style="text-align:left">毕业院校</td><td style="text-align:left">中北大学信息商务学院</td></tr><tr><td style="text-align:left">E-mail</td><td style="text-align:left">tinarychina@gmail.com / ty24089@163.com</td></tr><tr><td style="text-align:left">电话/微信</td><td style="text-align:left">17722529692</td></tr><tr><td style="text-align:left">工作年限</td><td style="text-align:left">5年</td></tr><tr><td style="text-align:left">技术博客</td><td style="text-align:left"><a href="https://sheldon.top" target="_blank" rel="noopener">https://sheldon.top</a></td></tr><tr><td style="text-align:left">求职意向</td><td style="text-align:left">iOS开发工程师</td></tr><tr><td style="text-align:left">现居/期望城市</td><td style="text-align:left">北京市</td></tr></tbody></table><h2 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h2><h3 id="深圳市闪拍精灵网络技术有限公司（2016-05-2018-12）"><a href="#深圳市闪拍精灵网络技术有限公司（2016-05-2018-12）" class="headerlink" title="深圳市闪拍精灵网络技术有限公司（2016.05-2018.12）"></a>深圳市闪拍精灵网络技术有限公司（2016.05-2018.12）</h3><blockquote><p>负责客户端核心功能的开发和维护以及产品的迭代开发和优化，编写相关开发文档，参与需求评审和接口评审并讨论相关问题，在客户端组分配开发任务以及控制开发进度；在开发过程中协调API后台、移动端、web的工作。</p></blockquote><p><strong>作品：</strong>90秒、Ai优惠、快淘优品、惠拍优品、闪电拍卖<br><strong>项目内容：</strong></p><ul><li>项目架构以MVC为主，部分项目使用MVVM，统一后台接口规范 RESTful 风格。</li><li>项目以Objective-C语言为主，部分页面使用Swift编写。</li><li>部分项目使用响应式框架，主要是为了解决数据变化引起的页面布局和结构的改变。</li><li>项目使用自定义埋点（90秒使用GrowingIO无埋点框架）,运用分类为按钮添加action监听，添加编码属性。</li><li>使用GCD和自定义NSOpration处理数据内容，接口调用等。</li><li>使用Runtime实现通过CMS配置相关内容，控制页面跳转不同页面。</li><li>自定义DispatchTimer并管理Timer组，实现使用CACurrentMediaTime()计算倒计时数据，抛弃控制器做计算的过程，减轻控制器负担。</li><li>封装TableView，减少控制器中相关代码量。</li><li>使用CABasicAnimation实现相关页面动画效果。</li></ul><h3 id="北京圣合软件科技有限公司（2015-03-2016-02）"><a href="#北京圣合软件科技有限公司（2015-03-2016-02）" class="headerlink" title="北京圣合软件科技有限公司（2015.03-2016.02）"></a>北京圣合软件科技有限公司（2015.03-2016.02）</h3><blockquote><p>负责客户端相关功能的开发和迭代维护，配合其他相关部门提供相应的产品技术支持。</p></blockquote><p><strong>作品：</strong>留留学<br><strong>项目内容：</strong>项目严格遵循MVC设计框架模式开发,降低耦合度；多处使用GCD多线程技术；使用Block回调机制进行多页面之间传值；在应用内部使用系统提供的内置浏览器控件，加载网页数据；集成了第三方SDK环信即时聊天系统，使用户之间可以实时聊天并使用苹果公司的APNS服务，实时的推送消息到用户；集成第三方分享平台，将链接分享至第三方社交应用等。</p><h3 id="世界邦信息技术有限公司（2013-07-2015-02）"><a href="#世界邦信息技术有限公司（2013-07-2015-02）" class="headerlink" title="世界邦信息技术有限公司（2013.07-2015.02）"></a>世界邦信息技术有限公司（2013.07-2015.02）</h3><blockquote><p>负责公司iPhone手机客户端的的开发和维护，协助高级开发人员完成项目的开发和迭代。</p></blockquote><p><strong>作品：</strong>行程大师、全球地铁图<br><strong>项目内容：</strong>通过自定义UI控件与控件之间的搭配使用，使App界面丰富多彩，方便用户使用和交互；使用RunLoop中的commonModes实现拖动页面和scrollView滚动之间互不干扰；混合开发，在应用内部使用系统提供的内置浏览器控件，加载网页数据，达到更快捷的开发App并且方便于维护；使用苹果公司的APNS服务，实时的推送消息到用户等。</p><h2 id="技能列表"><a href="#技能列表" class="headerlink" title="技能列表"></a>技能列表</h2><ul><li>精通Objective-C语言，熟练掌握iOS平台各类API，熟悉iOS内存管理机制，熟悉iOS多线程。</li><li>熟悉Swift语言及其特性以及SDK等。</li><li>能熟练的运用AFNetworking、SDWebImage、Masonry、Reactivecocoa等开源项目。</li><li>能熟练使用纯代码或者Storyboard，xib进行开发。</li><li>能熟练的使用Instruments下的性能调试工具进行性能优化。</li><li>熟悉网络数据(JSON/XML)的请求以及解析并转化模型，Charles网络数据抓包分析。</li><li>熟练使用Git、SVN等代码管理工具。</li><li>熟悉MVC、MVVM、委托代理、通知观察等开发模式。</li><li>熟悉TCP/UDP/HTTP/HTTPS/XMPP等协议。</li><li>熟悉腾讯Bugly的Crash错误分析，熟悉GrowingIO无埋点技术等。</li><li>熟悉持续集成Jenkins,fastlane等工具。</li><li>熟悉iOS数据持久化，NSUserDefaults、NSKeyedArchiver、SQLite3、 CoreData等。</li><li>熟悉后台接口规范以及各种调试工具。</li><li>了解React Native、Weex、Flutter等跨平台开发技术。</li></ul><h2 id="兴趣爱好"><a href="#兴趣爱好" class="headerlink" title="兴趣爱好"></a>兴趣爱好</h2><ul><li>搭建过VPN，目前使用的为自己在Google Cloud Platform搭建的CentOS7服务器。</li><li>使用Python编写一些抓取图片的小脚本。</li><li>搭建过持续集成jenkins+fir+钉钉机器人通知等持续集成工具，可以自动打包、上传并通知测试人员。</li><li>个人喜欢各种球类运动和唱歌。</li></ul><h2 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h2><ul><li>责任心强，性格外向，人际沟通能力良好，有协调团队工作的能力，喜欢拥抱新技术。</li><li>工作认真负责，认真对待每一件事情，每一个技术点，反馈及时，能做到尽早暴露风险以及问题</li><li>工作经验丰富，开发快速，有良好的编程能力和习惯，喜欢规范化代码以及积极优化代码。</li></ul><h2 id="作品链接"><a href="#作品链接" class="headerlink" title="作品链接"></a>作品链接</h2><ul><li><a href="https://itunes.apple.com/cn/app/90%E7%A7%92/id1435124139?mt=8" target="_blank" rel="noopener">90秒</a>、<a href="https://itunes.apple.com/cn/app/ai%E4%BC%98%E6%83%A0/id1396344295?mt=8" target="_blank" rel="noopener">Ai优惠</a>、<a href="https://itunes.apple.com/cn/app/%E5%BF%AB%E6%B7%98%E4%BC%98%E5%93%81/id1383652396" target="_blank" rel="noopener">快淘优品</a>、<a href>惠拍优品</a>、<a href>闪电拍卖</a></li></ul><h2 id="社交主页"><a href="#社交主页" class="headerlink" title="社交主页"></a>社交主页</h2><ul><li>个人博客：<a href="https://sheldon.top" target="_blank" rel="noopener">Sheldon’s blog</a></li><li>GitHub：<a href="https://github.com/FlameTinary" target="_blank" rel="noopener">Sheldon</a></li><li>简书：<a href="https://www.jianshu.com/u/a1e222f75cc7" target="_blank" rel="noopener">搁浅的青蛙</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> hide </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详细解析HTTP和HTTPS</title>
      <link href="/2019/03/04/%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90HTTP%E5%92%8CHTTPS/"/>
      <url>/2019/03/04/%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90HTTP%E5%92%8CHTTPS/</url>
      
        <content type="html"><![CDATA[<blockquote><p>HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。<br>为了解决HTTP协议的这一缺陷，需要使用另一种协议：HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。  </p></blockquote><a id="more"></a><h2 id="HTTP和HTTPS的基本概念"><a href="#HTTP和HTTPS的基本概念" class="headerlink" title="HTTP和HTTPS的基本概念"></a>HTTP和HTTPS的基本概念</h2><p>HTTP（HyperText Transfer Protocol：超文本传输协议）：是互联网上应用最为广泛的一种协议，用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。<br>HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 <code>http://</code> 打头的都是标准 HTTP 服务。</p><p>HTTPS（Hypertext Transfer Protocol Secure：超文本传输安全协议）：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。<br>HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式：</p><ol><li>TCP 三次同步握手</li><li>客户端验证服务器数字证书</li><li>DH 算法协商对称加密算法的密钥、hash 算法的密钥</li><li>SSL 安全加密隧道协商完成</li><li>网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。</li></ol><p>HTTPS协议的主要作用有两种：</p><ol><li>建立一个信息安全通道，来保证数据传输的安全</li><li>确认网站的真实性</li></ol><h2 id="HTTP与HTTPS有什么区别"><a href="#HTTP与HTTPS有什么区别" class="headerlink" title="HTTP与HTTPS有什么区别"></a>HTTP与HTTPS有什么区别</h2><ul><li>HTTP协议是明文传输，因此HTTP协议非常不安全；HTTPS（SSL+HTTP）数据传输过程是加密的，安全性较好。</li><li>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</li><li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</li><li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li><li>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</li></ul><h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><p><img src="http://www.runoob.com/wp-content/uploads/2018/09/05234233-eed6ddcba93c42be8847e98d6da62802.jpg" alt></p><ul><li>第一次握手：客户端尝试连接服务器，向服务器发送 syn 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认</li><li>第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个 SYN包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态</li><li>第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手<br><img src="http://www.runoob.com/wp-content/uploads/2018/09/dffdff.png" alt></li></ul><h2 id="HTTPS的工作原理"><a href="#HTTPS的工作原理" class="headerlink" title="HTTPS的工作原理"></a>HTTPS的工作原理</h2><p><img src="http://www.runoob.com/wp-content/uploads/2018/09/https-intro.png" alt></p><ol><li><strong>客户端发起HTTPS请求</strong><br>用户在浏览器里输入一个 https 网址，然后连接到 server 的 443 端口。</li><li><strong>服务端配置</strong><br>采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl 就是个不错的选择，有 1 年的免费服务)。<br>这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</li><li><strong>传送证书</strong><br>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</li><li><strong>客户端解析证书</strong><br>这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。<br>如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</li><li><strong>传送加密信息</strong><br>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</li><li><strong>服务端解密信息</strong><br>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</li><li><strong>传输加密后的信息</strong><br>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</li><li><strong>客户端解密信息</strong><br>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git服务器的搭建</title>
      <link href="/2019/01/22/Git%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/01/22/Git%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。搭建Git服务器需要准备一台运行Linux的机器，这样，通过几条简单的apt命令就可以完成安装。</p></blockquote><a id="more"></a><h1 id="第一步，安装Git"><a href="#第一步，安装Git" class="headerlink" title="第一步，安装Git"></a>第一步，安装<code>Git</code></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure><h1 id="第二步，创建一个git用户，用来运行git服务："><a href="#第二步，创建一个git用户，用来运行git服务：" class="headerlink" title="第二步，创建一个git用户，用来运行git服务："></a>第二步，创建一个<code>git</code>用户，用来运行<code>git</code>服务：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo adduser git</span><br></pre></td></tr></table></figure><h1 id="第三步，创建证书登录："><a href="#第三步，创建证书登录：" class="headerlink" title="第三步，创建证书登录："></a>第三步，创建证书登录：</h1><p>收集所有需要登录的用户的公钥，就是他们自己的<code>id_rsa.pub</code>文件，把所有公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。</p><h1 id="第四步，初始化Git仓库："><a href="#第四步，初始化Git仓库：" class="headerlink" title="第四步，初始化Git仓库："></a>第四步，初始化<code>Git</code>仓库：</h1><p>先选定一个目录作为<code>Git</code>仓库，假定是<code>/srv/sample.git</code>，在<code>/srv</code>目录下输入命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo git init --bare sample.git</span><br></pre></td></tr></table></figure></p><p><code>Git</code>就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的<code>Git</code>仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的<code>Git</code>仓库通常都以<code>.git</code>结尾。然后，把<code>owner</code>改为<code>git</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R git:git sample.git</span><br></pre></td></tr></table></figure></p><h1 id="第五步，禁用shell登录："><a href="#第五步，禁用shell登录：" class="headerlink" title="第五步，禁用shell登录："></a>第五步，禁用<code>shell</code>登录：</h1><p>出于安全考虑，第二步创建的<code>git</code>用户不允许登录<code>shell</code>，这可以通过编辑<code>/etc/passwd</code>文件完成。找到类似下面的一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/bin/bash</span><br></pre></td></tr></table></figure></p><p>改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure></p><p>这样，<code>git</code>用户可以正常通过<code>ssh</code>使用<code>git</code>，但无法登录<code>shell</code>，因为我们为<code>git</code>用户指定的<code>git-shell</code>每次一登录就自动退出。</p><h1 id="第六步，克隆远程仓库："><a href="#第六步，克隆远程仓库：" class="headerlink" title="第六步，克隆远程仓库："></a>第六步，克隆远程仓库：</h1><p>现在，可以通过<code>git clone</code>命令克隆远程仓库了，在各自的电脑上运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@server:/srv/sample.git</span><br><span class="line">Cloning into &apos;sample&apos;...</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python3-Mac安装Python3</title>
      <link href="/2019/01/21/python3-Mac%E5%AE%89%E8%A3%85Python3/"/>
      <url>/2019/01/21/python3-Mac%E5%AE%89%E8%A3%85Python3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>因为Python是跨平台的，它可以运行在Windows、Mac和各种Linux/Unix系统上。在Windows上写Python程序，放到Linux上也是能够运行的。<br>要开始学习Python编程，首先就得把Python安装到你的电脑里。安装后，你会得到Python解释器（就是负责运行Python程序的），一个命令行交互环境，还有一个简单的集成开发环境。</p></blockquote><a id="more"></a><h2 id="安装Python3"><a href="#安装Python3" class="headerlink" title="安装Python3"></a>安装Python3</h2><p>系统自带的Python版本是2.7。要安装最新的Python 3.7，有两个方法：</p><p>方法一：从Python官网下载Python 3.7的<a href="https://www.python.org/ftp/python/3.7.0/python-3.7.0-macosx10.9.pkg" target="_blank" rel="noopener">安装程序</a>（网速慢的同学请移步<a href="https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fpython" target="_blank" rel="noopener">国内镜像</a>），双击运行并安装；</p><p>方法二：如果安装了<a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a>，直接通过命令<code>brew install python3</code>安装即可。</p><h2 id="直接运行-py文件"><a href="#直接运行-py文件" class="headerlink" title="直接运行.py文件"></a>直接运行.py文件</h2><p>在文件开头添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br></pre></td></tr></table></figure></p><p>然后通过命令给文件权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x hello.py</span><br></pre></td></tr></table></figure></p><p>就可以通过命令<code>./hello.py</code>直接运行.py文件了。</p>]]></content>
      
      
      <categories>
          
          <category> 后台 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7+Python3+Django</title>
      <link href="/2019/01/21/CentOS7-Python3-Django/"/>
      <url>/2019/01/21/CentOS7-Python3-Django/</url>
      
        <content type="html"><![CDATA[<h1 id="CentOS-7中布置Python3和Django"><a href="#CentOS-7中布置Python3和Django" class="headerlink" title="CentOS 7中布置Python3和Django"></a>CentOS 7中布置Python3和Django</h1><p>Centos7中默认安装了python2.7.5，因为一些命令要用它，比如：yum；它使用的是python2.7.5。当我们在命令行里输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -V</span><br></pre></td></tr></table></figure><p>就可以看到版本为2.7.5。</p><a id="more"></a><p>安装各种依赖包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y groupinstall <span class="string">"Development tools"</span></span><br><span class="line">yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel gcc automake autoconf libtool make wget</span><br></pre></td></tr></table></figure><h2 id="安装python3"><a href="#安装python3" class="headerlink" title="安装python3"></a>安装python3</h2><p>因为我们要安装python3版本，所以python要指向python3才行，目前还没有安装python3，先备份，备份之前先安装相关包，用于下载编译python3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make</span><br></pre></td></tr></table></figure><p>这几个包必须得安装，否则安装python3时可能会出现各种错误。<br>运行下面两个命令，进行备份</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/bin</span><br><span class="line">mv python python.bak</span><br></pre></td></tr></table></figure><p>下载python3.6.3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tar.xz</span><br></pre></td></tr></table></figure><p>解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvJf  Python-3.6.3.tar.xz</span><br></pre></td></tr></table></figure><p>进入解压好的python3.6.3文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Python-3.6.3</span><br></pre></td></tr></table></figure><p>编译安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure prefix=/usr/<span class="built_in">local</span>/python3</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>安装完毕，/usr/local/目录下就会有python3了。</p><h2 id="实现Python3和Python2的共存"><a href="#实现Python3和Python2的共存" class="headerlink" title="实现Python3和Python2的共存"></a>实现Python3和Python2的共存</h2><p>添加Python3的软链</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/python3 /usr/bin/python</span><br></pre></td></tr></table></figure><p>这个时候在执行命令python -V和python2 -V，就能看到python3和python2的版本了。</p><p>添加pip3的软链</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/python3/bin/pip3 /usr/bin/pip</span><br></pre></td></tr></table></figure><p>因为执行yum需要Python2的版本，所以我们还有修改yum的配置，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/bin/yum</span><br></pre></td></tr></table></figure><p>把第一行<code>#! /usr/bin/python</code>修改为<code>#! /usr/bin/python2</code></p><p>同理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/libexec/urlgrabber-ext-down</span><br></pre></td></tr></table></figure><p>文件里面的<code>#! /usr/bin/python</code>也要修改为<code>#! /usr/bin/python2</code></p><h2 id="安装Django项目中需要的python相关包"><a href="#安装Django项目中需要的python相关包" class="headerlink" title="安装Django项目中需要的python相关包"></a>安装Django项目中需要的python相关包</h2><p>安装python相关包需要用到python中的pip命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pip install Django</span><br><span class="line">pip install PyMySQL</span><br><span class="line">pip install Scrapy</span><br><span class="line">pip install beautifulsoup4</span><br><span class="line">pip install bs4</span><br><span class="line">pip install lxml</span><br><span class="line">pip install numpy</span><br><span class="line">pip install requests</span><br><span class="line">pip install simplejson</span><br><span class="line">pip install urllib3</span><br></pre></td></tr></table></figure><p>此时，python所需要的包已经都安装好了。</p><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p>下载MySQL源安装包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm</span><br></pre></td></tr></table></figure><p>安装MySQL源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum localinstall mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line">yum install mysql-devel</span><br></pre></td></tr></table></figure><p>安装MySQL</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql-community-server</span><br></pre></td></tr></table></figure><p>启动MySQL服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure><p>查看MySQL状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status mysqld</span><br></pre></td></tr></table></figure><p>开机启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> mysqld</span><br></pre></td></tr></table></figure><p>修改root本地登录密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">'temporary password'</span> /var/<span class="built_in">log</span>/mysqld.log</span><br><span class="line">mysql -uroot -p</span><br><span class="line"><span class="built_in">set</span> password <span class="keyword">for</span> <span class="string">'root'</span>@<span class="string">'localhost'</span>=password(<span class="string">'!2Qw32sd'</span>);</span><br></pre></td></tr></table></figure><p>注意：mysql5.7默认安装了密码安全检查插件（validate_password），默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于8位。否则会提示ERROR 1819 (HY000): Your password does not satisfy the current policy requirements错误</p><p>配置默认编码为utf8</p><p>修改<code>/etc/my.cnf</code>配置文件，在[mysqld]下添加编码配置，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character_set_server=utf8</span><br><span class="line">init_connect=<span class="string">'SET NAMES utf8'</span></span><br></pre></td></tr></table></figure><h2 id="导入django和mysql数据库"><a href="#导入django和mysql数据库" class="headerlink" title="导入django和mysql数据库"></a>导入django和mysql数据库</h2><h2 id="导入django项目"><a href="#导入django项目" class="headerlink" title="导入django项目"></a>导入django项目</h2><p>由于我项目放在码云上面，然后CentOS又自带git，我的数据库文件也比较小，所以也放在django项目中了，用git下载下来:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo su root</span><br><span class="line">mkdir project</span><br><span class="line"><span class="built_in">cd</span> project</span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/dafeige/django-restframework-demo.git</span><br></pre></td></tr></table></figure><p>此时，我的数据库文件路径是：<code>project/django-restframework-demo/tutorial/test_python.sql</code>，由于需要将此sql文件导入到mysql数据中，需要给此文件加权限:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 project/django-restframework-demo/tutorial/test_python.sql</span><br></pre></td></tr></table></figure><h2 id="导入sql数据库文件"><a href="#导入sql数据库文件" class="headerlink" title="导入sql数据库文件"></a>导入sql数据库文件</h2><p>进入数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>导入sql文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create database test_python;</span><br><span class="line">use test_python;</span><br><span class="line"><span class="built_in">source</span> project/django-restframework-demo/tutorial/test_python.sql;</span><br></pre></td></tr></table></figure><h2 id="部署django工程"><a href="#部署django工程" class="headerlink" title="部署django工程"></a>部署django工程</h2><p>进入到工程中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo su root</span><br><span class="line"><span class="built_in">cd</span> project/django-restframework-demo/tutorial</span><br><span class="line">python manage.py runserver 0.0.0.0:80 &amp;</span><br></pre></td></tr></table></figure><p>最后面的”&amp;”，这符号表示在后台运行该进程。这里的IP地址如果用公网IP</p><p>会运行不了，而用0.0.0.0则外网和127.0.0.1都能够访问。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> Python3 </tag>
            
            <tag> Django </tag>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git标签管理</title>
      <link href="/2019/01/21/Git%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86/"/>
      <url>/2019/01/21/Git%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p></blockquote><a id="more"></a><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure></p><p>然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure></p><p>可以用命令<code>git tag</code>查看所有标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure></p><p>默认标签是打在最新提交的<code>commit</code>上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p><p>方法是找到历史提交的<code>commit id</code>，然后打上就可以了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline --abbrev-commit</span><br><span class="line">12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 101</span><br><span class="line">4c805e2 fix bug 101</span><br><span class="line">e1e9c68 merge with no-ff</span><br><span class="line">f52c633 add merge</span><br><span class="line">cf810e4 conflict fixed</span><br><span class="line">5dc6824 &amp; simple</span><br><span class="line">14096d0 AND simple</span><br><span class="line">b17d20e branch test</span><br><span class="line">d46f35e remove test.txt</span><br><span class="line">b84166e add test.txt</span><br><span class="line">519219b git tracks changes</span><br><span class="line">e43a48b understand how stage works</span><br><span class="line">1094adb append GPL</span><br><span class="line">e475afc add distributed</span><br><span class="line">eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure></p><p>比方说要对<code>add merge</code>这次提交打标签，它对应的<code>commit id</code>是<code>f52c633</code>，敲入命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v0.9 f52c633</span><br></pre></td></tr></table></figure></p><hr><p>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为HEAD，也可以指定一个commit id；</p><p>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</p><p>命令<code>git tag</code>可以查看所有标签。</p><p>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</p><p>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</p><p>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</p><p>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git分支管理</title>
      <link href="/2019/01/21/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
      <url>/2019/01/21/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。<br>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！</p></blockquote><a id="more"></a><h2 id="创建于合并分支"><a href="#创建于合并分支" class="headerlink" title="创建于合并分支"></a>创建于合并分支</h2><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p><p>##解决冲突<br>当两个分支同时做了修改，这个时候合并分支会出现冲突。</p><p>可以查看冲突文件</p><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容</p><p>修改后再提交，用<code>git log --graph --pretty=oneline --abbrev-commit</code>命令查看分支的合并情况。</p><h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure></p><p><code>--no-ff</code>参数，表示禁用<code>Fast forward</code>。</p><p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p><p>合并后，我们用<code>git log</code>查看分支历史。</p><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="./分支策略.png" alt="分支策略"></p><h2 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h2><p>如果当前你正在进行开发工作，这个时候需要fix一个bug，那么可以使用<code>git stash</code>命令先把当前的工作现场保存。</p><p>然后切换到需要修复bug的分支，创建临时分支。</p><p>修复完毕后，将临时分支合并到需要修复的bug分支，完成bug的修复。</p><p>用<code>git stash list</code>命令查看保存的工作现场。</p><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p><p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p><p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了。</p><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>要查看远程库的信息，用<code>git remote</code>或者，用<code>git remote -v</code>显示更详细的信息</p><h3 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h3><p>推送主分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></p><p>推送其他分支，比如<code>dev</code>，就改成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure></p><h3 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h3><p>使用<code>git clone</code>将远程仓库克隆到本地，使用<code>git branch</code>查看分支，会发现只有<code>master</code>分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure></p><p>如果要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，用这个命令创建本地<code>dev</code>分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure></p><p>如果你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，推送的时候也许会发生冲突。</p><p>先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送。</p><p>如果<code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br><span class="line">Branch &apos;dev&apos; set up to track remote branch &apos;dev&apos; from &apos;origin&apos;.</span><br></pre></td></tr></table></figure></p><p><strong>多人协作的工作模式通常是这样：</strong></p><p>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</p><p>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</p><p>如果合并有冲突，则解决冲突，并在本地提交；</p><p>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</p><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>rebase操作可以把本地未push的分叉提交历史整理成直线；</p><p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基础</title>
      <link href="/2019/01/21/Git%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/01/21/Git%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Git是什么？Git是目前世界上最先进的分布式版本控制系统（没有之一）。</p></blockquote><a id="more"></a><h2 id="在Mac上安装Git"><a href="#在Mac上安装Git" class="headerlink" title="在Mac上安装Git"></a>在Mac上安装Git</h2><p>在Mac上安装Git有两种方法：</p><p>第一种：先安装Homebrew，然后通过homebrew来安装Git，详情可以参考homebrew的<a href="https://brew.sh/" target="_blank" rel="noopener">文档</a>。</p><p>第二种：直接安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</p><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>什么是版本库呢？版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><p>所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir MyGitPost</span><br><span class="line">$ cd MyGitPost</span><br><span class="line">$ pwd</span><br><span class="line">/Users/username/Documents/MyGitPost</span><br></pre></td></tr></table></figure></p><p>第二步，通过<code>git init</code>命令b把这个m目录变成Git可管理的仓库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /Users/username/Documents/MyGitPost/.git/</span><br></pre></td></tr></table></figure></p><h2 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h2><p>首先，我们创建一个用于测试的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch readme.txt</span><br></pre></td></tr></table></figure></p><p>然后，打开<code>reademe.txt</code>文件进行编辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi readme.txt</span><br></pre></td></tr></table></figure></p><p>内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个用于测试Git的文档。</span><br></pre></td></tr></table></figure></p><p>然后通过两步来将文件提交到Git仓库：<br>第一步：用命令<code>git add</code>告诉Git，把文件添加到仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure></p><p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p><p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot;</span><br><span class="line">[master (root-commit) 2f26a28] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure></p><p><code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p><code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容）。</p><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><p>现在，我们修改<code>readme.txt</code>的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是修改的内容</span><br></pre></td></tr></table></figure></p><p>运行<code>git status</code>来看看修改后的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure></p><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p><p>使用<code>git diff</code>来查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..75de425 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">这是一个用于测试Git的文档。</span><br><span class="line">+这是修改的内容</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure></p><p>然后就是通过<code>git add</code>和<code>git commit</code>的命令提交修改内容，在执行<code>git commit</code>之前可以使用<code>git status</code>再次查看d当前仓库的状态。</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>在我们多次修改文件，每次<code>commit</code>都会生成一个快照，如果你对文件进行了不正当的操作，或者误删了内容，可以从最近的快照中恢复。</p><p>使用<code>git log</code>来查看每次<code>commit</code>的快照。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 707183727c57ee8fb68199521a9b014e088af091 (HEAD -&gt; master)</span><br><span class="line">Author: Sheldon &lt;ty24089@163.com&gt;</span><br><span class="line">Date:   Sat Jan 19 12:38:28 2019 +0800</span><br><span class="line"></span><br><span class="line">    修改readme文件内容</span><br><span class="line"></span><br><span class="line">commit 2f26a2852751767536b17a2f748c2081847c3578</span><br><span class="line">Author: Sheldon &lt;ty24089@163.com&gt;</span><br><span class="line">Date:   Sat Jan 19 12:04:45 2019 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure></p><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">707183727c57ee8fb68199521a9b014e088af091 (HEAD -&gt; master) 修改readme文件内容</span><br><span class="line">2f26a2852751767536b17a2f748c2081847c3578 wrote a readme file</span><br></pre></td></tr></table></figure></p><p>使用<code>git reset</code>来回退到上一个版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at 2f26a28 wrote a readme file</span><br></pre></td></tr></table></figure></p><p>如果想恢复的新的内容，使用<code>git reflog</code>查看每一次命令的记录，然后在通过<code>git reset --hard commit_id</code>命令来恢复想要的快照。</p><h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><p>工作区就是可以看的到的目录，比如在上边创建的<code>MyGitPost</code>文件夹就是工作区。</p><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为<code>stage</code>（或者叫<code>index</code>）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。<br><img src="./git_stage.jpeg" alt="git_stage"></p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>如果在修改了文件，但还没有<code>git add</code>，这个时候，你不想要这个文件的修改了，想恢复未修改前的内容，那么可以使用<code>git checkout -- file</code>命令丢弃工作区的修改。<br>这里有两种情况：</p><p>一种是文件自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是文件已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p>如果在修改了文件，并且提交到了暂存区，那么可以用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区。</p><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p><p>再用<code>git status</code>查看一下，现在暂存区是干净的，工作区有修改。</p><p>使用<code>git checkout -- file</code>就可以恢复工作区的修改。</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>命令<code>git rm</code>用于删除一个文件。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+next详细配置</title>
      <link href="/2019/01/21/hexo-next%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/01/21/hexo-next%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>hexo安装好后，默认的主题是<a href="https://github.com/hexojs/hexo-theme-landscape" target="_blank" rel="noopener">landscape</a>，如果不喜欢，我们也可以进行更换。本文主要配置Next(<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">GitHub</a>，<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">官方文档</a>)主题。</p></blockquote><a id="more"></a><h2 id="Next安装与启用主题"><a href="#Next安装与启用主题" class="headerlink" title="Next安装与启用主题"></a>Next安装与启用主题</h2><h3 id="安装Next"><a href="#安装Next" class="headerlink" title="安装Next"></a>安装Next</h3><p>切换到Blog主目录文件夹下</p><p>通过git安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd your-hexo-site</span><br><span class="line">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><h3 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h3><p>与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 _config.yml(站点配置文件)， 找到 <code>theme</code> 字段，并将其值更改为 <code>next</code>。</p><h3 id="验证主题"><a href="#验证主题" class="headerlink" title="验证主题"></a>验证主题</h3><p>首先启动 Hexo 本地站点，并开启调试模式（即加上 –debug），整个命令是 <code>hexo s --debug</code>。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure></p><p>此时即可使用浏览器访问 <a href="http://localhost:4000，检查站点是否正确运行。" target="_blank" rel="noopener">http://localhost:4000，检查站点是否正确运行。</a></p><h2 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h2><p>目前 NexT 支持四种 Scheme，他们是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Schemes</span><br><span class="line"># scheme: Muse</span><br><span class="line"># scheme: Mist</span><br><span class="line"># scheme: Pisces</span><br><span class="line"># scheme: Gemini</span><br></pre></td></tr></table></figure></p><p><code>Muse</code> - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</p><p><code>Mist</code> - Muse 的紧凑版本，整洁有序的单栏外观</p><p><code>Pisces</code> - 双栏 Scheme，小家碧玉似的清新</p><p><code>Gemini</code> - 双栏 Scheme，比<code>Pisces</code>略大</p><p>Scheme 的切换通过更改<code>主题配置文件</code>，搜索 <code>scheme</code> 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 <code>#</code> 去除即可。</p><h2 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  # schedule: /schedule/ || calendar</span><br><span class="line">  # sitemap: /sitemap.xml || sitemap</span><br><span class="line">  # commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">键值</th><th style="text-align:center">设定值</th><th style="text-align:center">显示文本</th></tr></thead><tbody><tr><td style="text-align:center">home</td><td style="text-align:center">home: /</td><td style="text-align:center">主页</td></tr><tr><td style="text-align:center">archives</td><td style="text-align:center">archives: /archives</td><td style="text-align:center">归档页</td></tr><tr><td style="text-align:center">categories</td><td style="text-align:center">categories: /categories</td><td style="text-align:center">分类页（需要手动创建页面）</td></tr><tr><td style="text-align:center">tags</td><td style="text-align:center">tags: /tags</td><td style="text-align:center">标签页（需要手动创建页面）</td></tr><tr><td style="text-align:center">about</td><td style="text-align:center">about: /about</td><td style="text-align:center">关于页面（需要手动创建页面）</td></tr><tr><td style="text-align:center">commonweal</td><td style="text-align:center">commonweal: /404.html</td><td style="text-align:center">公益 404（需要手动创建页面）</td></tr></tbody></table><h2 id="设置侧栏"><a href="#设置侧栏" class="headerlink" title="设置侧栏"></a>设置侧栏</h2><p>修改 <code>`主题配置文件</code> 中的 <code>sidebar</code> 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。</p><ul><li><p>设置侧栏的位置，修改 sidebar.position 的值，支持的选项有：</p><ul><li>left - 靠左放置</li><li>right - 靠右放置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">  position: left</span><br></pre></td></tr></table></figure></li></ul></li><li><p>设置侧栏显示的时机，修改 <code>sidebar.display</code> 的值，支持的选项有：</p><ul><li>post - 默认行为，在文章页面（拥有目录列表）时显示</li><li>always - 在所有页面中都显示</li><li>hide - 在所有页面中都隐藏（可以手动展开）</li><li>remove - 完全移除<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">  display: post</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="设置动态背景"><a href="#设置动态背景" class="headerlink" title="设置动态背景"></a>设置动态背景</h2><p><code>主题配置文件</code>中找到<code>canvas_nest</code>，设置成<code>ture</code>就OK啦。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Canvas-nest</span><br><span class="line">canvas_nest: ture</span><br></pre></td></tr></table></figure></p><h2 id="在右上角或者左上角实现fork-me-on-github"><a href="#在右上角或者左上角实现fork-me-on-github" class="headerlink" title="在右上角或者左上角实现fork me on github"></a>在右上角或者左上角实现fork me on github</h2><p><img src="https://upload-images.jianshu.io/upload_images/1879463-67e8c3b4657c24da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>在<a href="https://github.blog/2008-12-19-github-ribbons/" target="_blank" rel="noopener">GitHub Ribbons</a>或<a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">GitHub Corners</a>选择一款你喜欢的挂饰，拷贝方框内的代码<br><img src="https://upload-images.jianshu.io/upload_images/1879463-214a8a6dfcbf6baf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>将刚刚复制的挂饰代码，添加到<code>Blog/themes/next/layout/_layout.swig</code>文件中，添加到<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>的下方。</p><h2 id="设置RSS"><a href="#设置RSS" class="headerlink" title="设置RSS"></a>设置RSS</h2><p>NexT 中 RSS 有三个设置选项，满足特定的使用场景。 更改 <code>主题配置文件</code>，设定 <code>rss</code> 字段的值：</p><ul><li>false：禁用 RSS，不在页面上显示 RSS 连接。</li><li>留空：使用 Hexo 生成的 Feed 链接。 你可以需要先安装 <code>hexo-generator-feed</code> 插件。</li><li>具体的链接地址：适用于已经烧制过 Feed 的情形。</li></ul><h2 id="修改文章内链接文本样式"><a href="#修改文章内链接文本样式" class="headerlink" title="修改文章内链接文本样式"></a>修改文章内链接文本样式</h2><p>修改<code>Blog/themes/next/source/css/_common/components/post/post.styl</code>，在末尾添加CSS样式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 文章内链接文本样式</span><br><span class="line">.post-body p a&#123;</span><br><span class="line">  color: #0593d3; //原始链接颜色</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-bottom: 1px solid #0593d3; //底部分割线颜色</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #fc6423; //鼠标经过颜色</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-bottom: 1px solid #fc6423; //底部分割线颜色</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改底部标签样式"><a href="#修改底部标签样式" class="headerlink" title="修改底部标签样式"></a>修改底部标签样式</h2><p>修改<code>Blog\themes\next\layout\_macro\post.swig</code>中文件，<code>command+f</code>搜索<code>rel=&quot;tag&quot;&gt;#</code>，将<code>#</code>替换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code>。<br><img src="https://upload-images.jianshu.io/upload_images/3072214-36dcbfd6cd83d271.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/386/format/webp" alt></p><h2 id="在文章末尾添加“文章结束”标记"><a href="#在文章末尾添加“文章结束”标记" class="headerlink" title="在文章末尾添加“文章结束”标记"></a>在文章末尾添加“文章结束”标记</h2><ul><li>在路径<code>Blog\themes\next\layout\_macro</code>文件夹中新建<code>passage-end-tag.swig</code>文件。</li><li><p>在<code>passage-end-tag.swig</code>添加以下内容，直接用文本编辑器打开，粘贴以下内容后保存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------感谢您的阅读&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>打开<code>Blog\themes\next\layout\_macro\post.swig</code>，在<code>post-body</code>之后，<code>post-footer</code>之前（<code>post-footer</code>之前两个DIV），添加以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    &#123;% include &apos;passage-end-tag.swig&apos; %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><p>具体添加位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">&#123;% if not is_index %&#125;</span><br><span class="line">    &#123;% include &apos;passage-end-tag.swig&apos; %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&#123;% if (theme.alipay or theme.wechatpay or theme.bitcoin) and not is_index %&#125;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;% include &apos;reward.swig&apos; %&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if theme.post_copyright.enable and not is_index %&#125;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;% include &apos;post-copyright.swig&apos; with &#123; post: post &#125; %&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&lt;footer class=&quot;post-footer&quot;&gt;</span><br></pre></td></tr></table></figure></p><ul><li>修改主题配置文件_config.yml，在末尾添加：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 文章末尾添加“本文结束”标记</span><br><span class="line">passage_end_tag:</span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure><ul><li>显示效果：</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1879463-8629419c5007d532.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="修改作者头像并旋转"><a href="#修改作者头像并旋转" class="headerlink" title="修改作者头像并旋转"></a>修改作者头像并旋转</h2><p>打开<code>\themes\next\source\css\_common\components\sidebar\sidebar-author.styl</code>，在里面添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">.site-author-image &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">  padding: $site-author-image-padding;</span><br><span class="line">  max-width: $site-author-image-width;</span><br><span class="line">  height: $site-author-image-height;</span><br><span class="line">  border: $site-author-image-border-width solid $site-author-image-border-color;</span><br><span class="line">  /* 头像圆形 */</span><br><span class="line">  border-radius: 80px;</span><br><span class="line">  -webkit-border-radius: 80px;</span><br><span class="line">  -moz-border-radius: 80px;</span><br><span class="line">  box-shadow: inset 0 -1px 0 #333sf;</span><br><span class="line">  /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 </span><br><span class="line">    (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/</span><br><span class="line"> </span><br><span class="line">  /* 鼠标经过头像旋转360度 */</span><br><span class="line">  -webkit-transition: -webkit-transform 1.0s ease-out;</span><br><span class="line">  -moz-transition: -moz-transform 1.0s ease-out;</span><br><span class="line">  transition: transform 1.0s ease-out;</span><br><span class="line">&#125;</span><br><span class="line">img:hover &#123;</span><br><span class="line">  /* 鼠标经过停止头像旋转 </span><br><span class="line">  -webkit-animation-play-state:paused;</span><br><span class="line">  animation-play-state:paused;*/</span><br><span class="line">  /* 鼠标经过头像旋转360度 */</span><br><span class="line">  -webkit-transform: rotateZ(360deg);</span><br><span class="line">  -moz-transform: rotateZ(360deg);</span><br><span class="line">  transform: rotateZ(360deg);</span><br><span class="line">&#125;</span><br><span class="line">/* Z 轴旋转动画 */</span><br><span class="line">@-webkit-keyframes play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    -webkit-transform: rotateZ(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    -webkit-transform: rotateZ(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@-moz-keyframes play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    -moz-transform: rotateZ(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    -moz-transform: rotateZ(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    transform: rotateZ(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    transform: rotateZ(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="主页文章添加阴影效果"><a href="#主页文章添加阴影效果" class="headerlink" title="主页文章添加阴影效果"></a>主页文章添加阴影效果</h2><p>效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/1879463-5de81a87bce76925.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>具体实现方法：</p><p>打开<code>\themes\next\source\css\_custom\custom.styl</code>,向里面加入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 主页文章添加阴影效果</span><br><span class="line"> .post &#123;</span><br><span class="line">   margin-top: 60px;</span><br><span class="line">   margin-bottom: 60px;</span><br><span class="line">   padding: 25px;</span><br><span class="line">   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);</span><br><span class="line">   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="设置网站的图标Favicon"><a href="#设置网站的图标Favicon" class="headerlink" title="设置网站的图标Favicon"></a>设置网站的图标Favicon</h2><p>在<a href="https://www.easyicon.net/" target="_blank" rel="noopener">easyicon</a>或者<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">阿里巴巴矢量图标库</a>找一张你喜欢的图标（大：32x32 小：16x16），将下载下来的小图和中图放在Blog/themes/next/source/images，将默认的两张图片替换掉。命名和默认的一样也可以自己定义：<br><img src="https://upload-images.jianshu.io/upload_images/3072214-cf67d50c1502275d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/786/format/webp" alt></p><h2 id="底部隐藏由Hexo强力驱动、主题–NexT-Mist"><a href="#底部隐藏由Hexo强力驱动、主题–NexT-Mist" class="headerlink" title="底部隐藏由Hexo强力驱动、主题–NexT.Mist"></a>底部隐藏由Hexo强力驱动、主题–NexT.Mist</h2><p>打开<code>Blog/themes/next/layout/_partials/footer.swig</code>，注释掉相应代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//用下面的符号注释，注释代码用下面括号括起来</span><br><span class="line">&lt;!-- --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">&lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">&#123;% if theme.footer.powered %&#125;</span><br><span class="line">  &lt;div class=&quot;powered-by&quot;&gt;&#123;#</span><br><span class="line">  #&#125;&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;&#123;#</span><br><span class="line">#&#125;&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if theme.footer.powered and theme.footer.theme.enable %&#125;</span><br><span class="line">  &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if theme.footer.theme.enable %&#125;</span><br><span class="line">  &lt;div class=&quot;theme-info&quot;&gt;&#123;#</span><br><span class="line">  #&#125;&#123;&#123; __(&apos;footer.theme&apos;) &#125;&#125; &amp;mdash; &#123;#</span><br><span class="line">  #&#125;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;&#123;#</span><br><span class="line">    #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;#</span><br><span class="line">  #&#125;&lt;/a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; theme.version &#125;&#125;&#123;% endif %&#125;&#123;#</span><br><span class="line">#&#125;&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if theme.footer.custom_text %&#125;</span><br><span class="line">  &lt;div class=&quot;footer-custom&quot;&gt;&#123;#</span><br><span class="line">  #&#125;&#123;&#123; theme.footer.custom_text &#125;&#125;&#123;#</span><br><span class="line">#&#125;&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></p><h2 id="添加侧栏推荐阅读"><a href="#添加侧栏推荐阅读" class="headerlink" title="添加侧栏推荐阅读"></a>添加侧栏推荐阅读</h2><p>编辑主题配置文件，如下配置即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Blog rolls</span><br><span class="line">links_icon: link</span><br><span class="line">links_title: 推荐阅读</span><br><span class="line">#links_layout: block</span><br><span class="line">links_layout: inline</span><br><span class="line">links:</span><br><span class="line">  Swift 4: https://developer.apple.com/swift/</span><br><span class="line">  Objective-C: https://developer.apple.com/documentation/objectivec</span><br></pre></td></tr></table></figure></p><h2 id="Hexo博客添加站内搜索"><a href="#Hexo博客添加站内搜索" class="headerlink" title="Hexo博客添加站内搜索"></a>Hexo博客添加站内搜索</h2><p><img src="https://upload-images.jianshu.io/upload_images/3072214-aff43f0e07e85647.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/972/format/webp" alt></p><p>NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia。下面介绍Local Search的安装吧。</p><p>切换到根目录</p><p>安装 hexo-generator-search<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure></p><p>安装 hexo-generator-searchdb<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></p><p>编辑<code>站点配置文件</code>，添加以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></p><p>编辑<code>主题配置文件</code>，设置<code>Local searchenable</code>为<code>ture</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line"># Dependencies: https://github.com/flashlab/hexo-generator-search</span><br><span class="line">local_search:</span><br><span class="line">  enable: ture</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">hexo的next主题个性化教程:打造炫酷网站</a></li><li><a href="https://www.jianshu.com/p/9f0e90cc32c2" target="_blank" rel="noopener">Hexo-NexT配置超炫网页效果</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人ss-ssr服务器</title>
      <link href="/2017/10/01/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAss-ssr%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2017/10/01/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAss-ssr%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="获取SSR客户端"><a href="#获取SSR客户端" class="headerlink" title="获取SSR客户端"></a>获取SSR客户端</h1><ul><li>Windows客户端地址 <a href="https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases" target="_blank" rel="noopener">download</a>  <a href="https://nofile.io/f/6Jm7WJCyOVv/ShadowsocksR-4.7.0-win.7z" target="_blank" rel="noopener">备用地址</a> </li><li>Mac客户端地址 <a href="https://github.com/shadowsocksr-backup/ShadowsocksX-NG/releases" target="_blank" rel="noopener">download</a> <a href="https://nofile.io/f/jgMWFwCBonU#ab0d3c3b6ac54482" target="_blank" rel="noopener">备用地址</a></li><li>Linux客户端一键安装配置 <a href="https://github.com/the0demiurge/CharlesScripts/blob/master/charles/bin/ssr" target="_blank" rel="noopener">使用脚本</a> (使用方法见注释) 或者采用图形界面的<a href="https://github.com/erguotou520/electron-ssr/releases" target="_blank" rel="noopener">linux ssr客户端</a></li><li>安卓 SSR客户端 <a href="https://github.com/shadowsocksr-backup/shadowsocksr-android/releases" target="_blank" rel="noopener">下载地址</a> <a href="https://nofile.io/f/GRWw7PbADrc#1c6c32f969e7f5d9" target="_blank" rel="noopener">备用下载地址</a></li></ul><a id="more"></a><h1 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h1><blockquote><p>搭建步骤分为三步：<br>1.购买VPS服务器<br>2.一键部署VPS服务器<br>3.一键加速VPS服务器 （谷歌BBR加速，推荐）</p></blockquote><h2 id="第一步：购买VPS服务器"><a href="#第一步：购买VPS服务器" class="headerlink" title="第一步：购买VPS服务器"></a>第一步：购买VPS服务器</h2><p>VPS服务器需要选择国外的，首选国际知名的vultr，速度不错、稳定且性价比高。</p><p>vultr注册地址： <a href="http://www.vultr.com/?ref=7048874" target="_blank" rel="noopener">http://www.vultr.com/?ref=7048874</a> （全球15个服务器位置可选，KVM框架）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">价格:</span><br><span class="line">2.5美元/月的服务器配置信息：单核 512M内存 20G SSD硬盘 100M带宽 500G流量/月</span><br><span class="line"></span><br><span class="line">5美元/月的服务器配置信息：单核 1G内存 25G SSD硬盘 100M带宽 1000G流量/月</span><br><span class="line"></span><br><span class="line">10美元/月的服务器配置信息：单核 2G内存 40G SSD硬盘 100M带宽 2000G流量/月</span><br><span class="line"></span><br><span class="line">20美元/月的服务器配置信息：2cpu 4G内存 60G SSD硬盘 100M带宽 3000G流量/月</span><br><span class="line"></span><br><span class="line">40美元/月的服务器配置信息：4cpu 8G内存 100G SSD硬盘 100M带宽 4000G流量/月</span><br></pre></td></tr></table></figure><p>vultr实际上是折算成小时来计费的，比如服务器是5美元1个月，那么每小时收费为5/30/24=0.0069美元 会自动从账号中扣费，只要保证账号有钱即可。如果你部署的服务器实测后不理想，你可以把它删掉（destroy），重新换个地区的服务器来部署，很方便。</p><p>计费从你开通服务器开始算的，不管你有没有使用，即使服务器处于关机状态仍然会计费，如果你没有开通服务器就不算。比如你今天早上开通了服务器，但你有事情，晚上才部署，那么这段时间是会计费的。同理，如果你早上删掉服务器，第二天才开通新的服务器，那么这段时间是不会计费的。</p><p>温馨提醒：同样的服务器位置，不同的宽带类型和地区所搭建的账号的翻墙速度会不同，所以最好亲测一下。</p><p><img src="https://raw.githubusercontent.com/Alvin9999/pac2/master/pp100.png" alt="img"><br><img src="https://raw.githubusercontent.com/Alvin9999/pac2/master/pp101.png" alt="img"></p><p>购买vps服务器时，服务器地址优先选择：美国硅谷（Silicon Valley）、美国达拉斯(Dallas)等，近期不推荐用洛杉矶和日本的服务器，因为这两个地区近期能够开到的好ip的可能性很低。推荐选择CentOS 6.X64位的系统（系统版本不要选的太高，不要选centos7！centos7默认的防火墙可能会干扰ssr的正常连接！）。完成购买后，找到系统的密码记下来，部署服务器时需要用到。如图：</p><p><img src="https://raw.githubusercontent.com/Alvin9999/crp_up/master/pac%E6%95%99%E7%A8%8B01.png" alt="img"><br><img src="https://raw.githubusercontent.com/Alvin9999/crp_up/master/pac%E6%95%99%E7%A8%8B02.png" alt="img"><br><img src="https://raw.githubusercontent.com/Alvin9999/crp_up/master/pac%E6%95%99%E7%A8%8B04.png" alt="img"></p><p>默认是centos7系统，点击图中的CentOS几个字，会弹出centos6，然后选中它！vps操作系统不要选cento7，因为选它很可能会影响ssr的正常连接。</p><p><img src="https://raw.githubusercontent.com/Alvin9999/crp_up/master/pac%E6%95%99%E7%A8%8B05.png" alt="img"><br><img src="https://raw.githubusercontent.com/Alvin9999/crp_up/master/pac%E6%95%99%E7%A8%8B06.png" alt="img"></p><h2 id="第二步：远程连接VPS服务器"><a href="#第二步：远程连接VPS服务器" class="headerlink" title="第二步：远程连接VPS服务器"></a>第二步：远程连接VPS服务器</h2><h3 id="Mac连接远程服务器"><a href="#Mac连接远程服务器" class="headerlink" title="Mac连接远程服务器:"></a>Mac连接远程服务器:</h3><ol><li>打开terminal,输入<code>ssh root@ip地址</code>;<code>root</code>为远程服务器的username,<code>ip地址</code>为远程服务器的ip.</li><li>联通后,提示输入密码,然后输入服务器的密码.</li><li>开始部署ssr代码</li></ol><h3 id="Windows连接远程服务器"><a href="#Windows连接远程服务器" class="headerlink" title="Windows连接远程服务器:"></a>Windows连接远程服务器:</h3><p>购买服务器后，需要部署一下。因为你买的是虚拟东西，而且又远在国外，我们需要一个叫Xshell的软件来远程部署。Xshell windows版下载地址：</p><p><a href="http://www.babel.cc/share.do?s=5793540665720793" target="_blank" rel="noopener">巴别鸟云盘下载</a> 提取密码：38693</p><p><a href="https://nofile.io/f/FQaBa7fT3dy#32cbadc45982d2f3" target="_blank" rel="noopener">国外云盘下载</a></p><p><a href="http://rj.baidu.com/soft/detail/15201.html?ald" target="_blank" rel="noopener">百度软件中心</a></p><p>下载xshell软件并安装后，打开软件<br><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/xshell11.png" alt="img"></p><p>选择文件，新建<br><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/xshell12.png" alt="img"></p><p>随便取个名字，然后把你的服务器ip填上<br><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/xshell13.png" alt="img"></p><p>连接国外<code>ip</code>即服务器时，软件会先后提醒你输入用户名和密码，用户名linux系统默认都是<code>root</code>，密码是购买服务器后的cent系统的密码。</p><p><strong>如果开好了服务器，发现xshell死活连不上，多半是开的服务器ip被墙了，遇到这种情况，把服务器删掉，重新开个新的服务器即可，可以是同地区的也可以选择其它地区。</strong><br><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/xshell14.png" alt></p><p><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/xshell15.png" alt></p><p>连接成功后，会出现如上图所示，之后就可以复制粘贴代码部署了。</p><p>分享两个好用的代码，选择其中一个即可。建议两个脚本先大致都看一下功能,然后再选择。</p><h2 id="第三步-部署ssr代码"><a href="#第三步-部署ssr代码" class="headerlink" title="第三步: 部署ssr代码"></a>第三步: 部署ssr代码</h2><h3 id="第1种方式"><a href="#第1种方式" class="headerlink" title="第1种方式:"></a>第1种方式:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget</span><br><span class="line"></span><br><span class="line">wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh</span><br><span class="line"></span><br><span class="line">chmod +x shadowsocksR.sh</span><br><span class="line"></span><br><span class="line">./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log</span><br></pre></td></tr></table></figure><p>上面的代码总共有4行（显示5行），复制时要一起复制下来，以下脚本类似。如果要卸载直接输入命令：<code>./shadowsocks-go.sh uninstall</code></p><p>演示开始：复制代码粘贴到vps服务器里，按回车键，进入部署。</p><p>按照如下提示，输入想设置的密码，按回车键进入下一步 (密码建议用字母，图中的密码只是作为演示用)<br><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/ss/1.png" alt><br>按照如下提示，输入想设置的端口（3～4位即可），按回车键进入下一步<br><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/ss/2.png" alt><br>按照如下提示，选择想设置的加密方式，括号里面是默认的加密方式，想设置默认的话直接按回车键。这里选择数字2（和默认一样）的aes-256-cfb的加密方式<br><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/ss/3.png" alt><br>按照如下提示，选择项设置的协议插件，默然的是origin（支持SS客户端，不推荐），我们选择SSR客户端的协议插件：3<br><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/ss/4.png" alt><br>按照如下提示，选择项设置的混淆插件，默然的是plain（支持SS客户端，不推荐），我们选择SSR客户端的混淆插件：6<br><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/ss/5.png" alt><br>按照如下提示，按任意键进行自动部署<br><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/ss/6.png" alt><br><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/ss/7.png" alt></p><p>上图表示部署成功。从上往下依次为SSR帐号的IP、端口、密码、协议插件、混淆插件和加密方式。</p><p>最后可以重启服务器确保部署生效。重启需要在命令栏里输入<code>reboot</code> ，输入命令后稍微等待一会服务器就会自动重启，一般重启过程需要2～5分钟，重启过程中Xshell会自动断开连接，等VPS重启好后才可以用Xshell软件进行连接。如果部署过程中卡在某个位置超过10分钟，可以用xshell软件断开，然后重新连接你的ip，再复制代码进行部署。</p><p>这个脚本的图文演示就结束了，图中的IP仅作演示用，教程发布后会失效。有人想了，我以后有想修改密码或者端口的需求怎么办？这个脚本修改密码和端口不是很方便，需要把最初的部署代码重新输入一遍，即从头到尾部署一遍即可。</p><p>下面再分享第二个脚本，这个脚本装一遍即可，方便以后想修改密码、端口什么的，而且功能更多。</p><h3 id="第2种方式"><a href="#第2种方式" class="headerlink" title="第2种方式:"></a>第2种方式:</h3><p>CentOS/Debian/Ubuntu ShadowsocksR单/多端口一键管理脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget</span><br><span class="line"></span><br><span class="line">wget -N --no-check-certificate https://softs.fun/Bash/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure><p>备用下载地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget</span><br><span class="line"></span><br><span class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</span><br></pre></td></tr></table></figure><p>复制上面的代码到VPS服务器里，安装脚本后，以后只需要运行这个快捷命令就可以出现下图的界面进行设置，快捷管理命令为：<code>bash ssr.sh</code></p><p><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/ss/8.png" alt></p><p>如上图出现管理界面后，输入数字<code>1</code>来安装SSR服务端。如果输入<code>1</code>后不能进入下一步，那么请退出xshell，重新连接vps服务器，然后输入快捷管理命令<code>bash ssr.sh</code> 再尝试。</p><p><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/ss/9.png" alt></p><p>根据上图提示，依次输入自己想设置的端口和密码 (密码建议用字母，图中的密码只是作为演示用)，回车键用于确认</p><p><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/ss/10.png" alt></p><p>如上图，选择想设置的加密方式，比如10，按回车键确认</p><p>接下来是选择协议插件，如下图：<br><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/ss/11.png" alt><br><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/ss/12.png" alt></p><p>选择并确认后，会出现上图的界面，提示你是否选择兼容原版，这里的原版指的是SS客户端，可以根据需求进行选择，原则上不推荐使用SS客户端，演示选择n</p><p>之后进行混淆插件的设置，如下面</p><p><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/ss/13.png" alt></p><p>进行混淆插件的设置后，会依次提示你对设备数、单线程限速和端口总限速进行设置，默认值是不进行限制，个人使用的话，选择默认即可，即直接敲回车键。</p><p><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/ss/14.png" alt></p><p>之后代码就正式自动部署了，到下图所示的位置，提示你下载文件，输入：y</p><p><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/ss/15.png" alt></p><p>耐心等待一会，出现下面的界面即部署完成：</p><p><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/ss/16.png" alt></p><p><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/ss/17.png" alt></p><p>根据上图就可以看到自己设置的SSR账号信息，包括IP、端口、密码、加密方式、协议插件、混淆插件。如果之后想修改账号信息，直接输入快捷管理命令：bash ssr.sh 进入管理界面，选择相应的数字来进行一键修改。例如：</p><p><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/ss/22.png" alt></p><p><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/ss/23.png" alt></p><p>第2个脚本的演示结束。</p><h2 id="第四步：一键加速VPS服务器"><a href="#第四步：一键加速VPS服务器" class="headerlink" title="第四步：一键加速VPS服务器"></a>第四步：一键加速VPS服务器</h2><p>此加速教程为谷歌BBR加速 ，vultr的服务器可以装谷歌bbr。</p><p>按照第二步的步骤，重新连接服务器ip，登录成功后，在命令栏里粘贴以下代码：</p><p>【谷歌BBR加速教程】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum -y install wget</span><br><span class="line"></span><br><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</span><br><span class="line"></span><br><span class="line">chmod +x bbr.sh</span><br><span class="line"></span><br><span class="line">./bbr.sh</span><br></pre></td></tr></table></figure><p>把上面整个代码复制后粘贴进去，不动的时候按回车，然后耐心等待，最后重启vps服务器即可。</p><p>演示开始，如图：</p><p>复制并粘贴代码后，按回车键确认</p><p><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/ss/18.png" alt></p><p>如下图提示，按任意键继续部署</p><p><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/ss/19.png" alt></p><p><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/ss/20.png" alt></p><p>部署到上图这个位置的时候，等待3～6分钟</p><p><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/ss/21.png" alt></p><p>最后输入y重启服务器或者手动输入代码reboot来确保加速生效。</p><p>购买vps服务器后，ip有了，通过部署，端口、密码、加密方式、协议和混淆也有了，最后将这些信息填入SSR客户端就可以翻墙啦。</p><p>有了账号后，打开SSR客户端，填上信息，这里以windows版的SSR客户端为例子：</p><p><img src="https://raw.githubusercontent.com/Alvin9999/PAC/master/ss/25.png" alt></p><p>在对应的位置，填上服务器ip、服务器端口、密码、加密方式、协议和混淆，最后将浏览器的代理设置为（http）127.0.0.1 1080即可。账号的端口号就是你自己设置的，而要上网的浏览器的端口号是1080，固定的，谷歌浏览器可以通过 SwitchyOmega 插件来设置。</p><p>有问题可以在这个帖子留言，或者自己网上搜索不明白的地方。多实践会更好。第一次部署时会慢一点，熟练了之后，就很快了。</p><hr><h1 id="常见问题参考解决方法："><a href="#常见问题参考解决方法：" class="headerlink" title="常见问题参考解决方法："></a>常见问题参考解决方法：</h1><p>1、用了一段时间发现ssr账号用不了了？</p><p>多半是被墙了，即ip失效。首先ping一下自己的ip，看看能不能ping的通，ping不通那么就是ip被墙了，遇到这种情况重新部署一个新的服务器，新的服务器就是新的ip。关于怎么ping ip的方法，可以自行网上搜索，很简单。vultr服务商开通和删除服务器非常方便（新服务器即新ip。大多数vps服务商都没有这样的服务，一般的vps服务商可能会提供更换1次ip的服务，如果你买的是别家的vps，一定要了解是否能够更换ip，假如不能，那么万一你的ip不幸被墙，钱就打水漂了）。</p><p>2、刚搭建好的ssr账号，ip能ping通，但是还是用不了？</p><p>首选，排除杀毒软件的干扰，尤其是国产杀毒软件，包括但不限于360安全卫生、360杀毒软件、腾讯管家、金山卫生等。这些东西很容易干扰翻墙上网，如果你的电脑安装了这样的东西，建议至少翻墙时别用。其次，检查下SSR信息是否填写正确。浏览器的代理方式是否是ssr代理，即127.0.0.1 1080端口。如果以上条件都排除，还是用不了，那么可以更换端口、加密方式、协议、混淆，或者更换服务器位置。</p><p>3、vps的服务器操作系统不要用的太高，太高可能会因为系统的防火墙问题导致搭建的SSR账号连不上，如果你用的centos系统，建议用centos6，不要用centos7。如果你前面不小心装了centos7系统，那么只能重装系统或者重新部署新的vps服务器。</p><p>4、小知识：vultr服务商提供的vps服务器是单向流量计算，有的vps服务商是双向流量计算，单向流量计算对于用户来说更实惠。因为我们是在vps服务器上部署SSR服务端后，再用SSR客户端翻墙，所以SSR服务端就相当于中转，比如我们看一个视频，必然会产生流量，假如消耗流量80M，那么VPS服务器会产生上传80M和下载80M流量，vultr服务商只计算单向的80M流量。如果是双向计算流量，那么会计算为160M流量。</p><p>5、如果你想把搭建的账号给多人使用，不用额外设置端口，因为一个账号就可以多人使用。一般10美元的服务器可以同时支持100人在线使用。如果你想额外的设置端口，采用第二个部署脚本，在管理界面输入数字9，就可以设置多端口了。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> ssr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发之触摸事件</title>
      <link href="/2016/04/27/iOS%E5%BC%80%E5%8F%91%E4%B9%8B%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6/"/>
      <url>/2016/04/27/iOS%E5%BC%80%E5%8F%91%E4%B9%8B%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文介绍了iOS中使用频率较高的触摸事件，并阐述了事件产生和传递的过程，以及响应者链的事件传递过程</p></blockquote><a id="more"></a><h1 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>在用户使用app过程中，会产生各种各样的事件</li><li>iOS中的事件可以分为3大类型<ul><li>触摸事件</li><li>加速计事件</li><li>远程控制事件 </li></ul></li></ul><h2 id="响应者对象"><a href="#响应者对象" class="headerlink" title="响应者对象"></a>响应者对象</h2><ul><li>在iOS中不是任何对象都能处理事件，只有继承了UIResponder的对象才能接收并处理事件。我们称之为“响应者对象”</li><li>UIApplication、UIViewController、UIView都继承自UIResponder，因此它们都是响应者对象，都能够接收并处理事件</li><li><p>UIResponder</p><ol><li><p>触摸事件</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">-(<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">-(<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">-(<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span> *)touches withEvent (<span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure></li><li><p>加速计事件</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)motionBegan:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">-(<span class="keyword">void</span>)motionEnded:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">-(<span class="keyword">void</span>)motionCancelled:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure></li><li><p>远程控制事件</p></li></ol></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure><h2 id="UIView的触摸事件处理"><a href="#UIView的触摸事件处理" class="headerlink" title="UIView的触摸事件处理"></a>UIView的触摸事件处理</h2><ul><li><p>UIView是UIResponder的子类，可以覆盖下列4个方法处理不同的触摸事件:</p><ol><li><p>一根或者多根手指开始触摸view，系统会自动调用view的下面方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br></pre></td></tr></table></figure></li><li><p>一根或者多根手指在view上移动，系统会自动调用view的下面方法（随着手指的移动，会持续调用该方法）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br></pre></td></tr></table></figure></li><li><p>一根或者多根手指离开view，系统会自动调用view的下面方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br></pre></td></tr></table></figure></li><li><p>触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用view的下面方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br></pre></td></tr></table></figure></li></ol><ul><li><em>提示：touches中存放的都是UITouch对象</em></li></ul></li></ul><h2 id="UITouch"><a href="#UITouch" class="headerlink" title="UITouch"></a>UITouch</h2><h3 id="对象和作用"><a href="#对象和作用" class="headerlink" title="对象和作用"></a>对象和作用</h3><ul><li>当用户用一根手指触摸屏幕时，会创建一个与手指相关联的UITouch对象</li><li>一根手指对应一个UITouch对象</li><li><code>UITouch的作用</code>：保存着跟手指相关的信息，比如触摸的位置、时间、阶段</li><li>当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置</li><li>当手指离开屏幕时，系统会销毁相应的UITouch对象<br><code>*提示：iPhone开发中，要避免使用双击事件！*</code></li></ul><h3 id="UITouch的属性"><a href="#UITouch的属性" class="headerlink" title="UITouch的属性"></a>UITouch的属性</h3><ul><li><p>触摸产生时所处的窗口</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">retain</span>) <span class="built_in">UIWindow</span>    *window;</span><br></pre></td></tr></table></figure></li><li><p>触摸产生时所处的视图</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">retain</span>) <span class="built_in">UIView</span>      *view;</span><br></pre></td></tr></table></figure></li><li><p>短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span>          tapCount;</span><br></pre></td></tr></table></figure></li><li><p>记录了触摸事件产生或变化时的时间，单位是秒</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">NSTimeInterval</span>      timestamp;</span><br></pre></td></tr></table></figure></li><li><p>当前触摸事件所处的状态</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UITouchPhase</span>        phase;</span><br></pre></td></tr></table></figure></li></ul><h3 id="UITouch的方法"><a href="#UITouch的方法" class="headerlink" title="UITouch的方法"></a>UITouch的方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">CGPoint</span>)locationInView:(<span class="built_in">UIView</span> *)view;</span><br></pre></td></tr></table></figure><ul><li>返回值表示触摸在view上的位置</li><li>这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)）</li><li>调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">CGPoint</span>)previousLocationInView:(<span class="built_in">UIView</span> *)view;</span><br></pre></td></tr></table></figure><ul><li>该方法记录了前一个触摸点的位置</li></ul><h2 id="UIEvent"><a href="#UIEvent" class="headerlink" title="UIEvent"></a>UIEvent</h2><ul><li>每产生一个事件，就会产生一个UIEvent对象</li><li>UIEvent：称为事件对象，记录事件产生的时刻和类型</li><li><p>常见属性</p><ul><li><p>事件类型</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UIEventType</span>     type;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UIEventSubtype</span>  subtype;</span><br></pre></td></tr></table></figure></li><li><p>事件产生的时间</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">NSTimeInterval</span>  timestamp;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>UIEvent还提供了相应的方法可以获得在某个view上面的触摸对象（UITouch)</p></li></ul><h2 id="touches和event参数"><a href="#touches和event参数" class="headerlink" title="touches和event参数"></a>touches和event参数</h2><ul><li><p>一次完整的触摸过程，会经历三个状态</p><ol><li><p>触摸开始</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br></pre></td></tr></table></figure></li><li><p>触摸移动</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br></pre></td></tr></table></figure></li><li><p>触摸结束</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br></pre></td></tr></table></figure></li><li><p>触摸取消</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchCancelled:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br></pre></td></tr></table></figure></li></ol></li><li><p>4个触摸事件处理方法中，都有NSSet <em> touches和UIEvent </em> event两个参数</p><ul><li>一次完整的触摸过程中，只会产生一个事件对象，4个触摸方法都是同一个event参数</li><li>如果两根手指同时触摸一个view，那么view只会调用一次touchesBegan:withEvent:方法，touches参数中装着2个UITouch对象</li><li>如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次touchesBegan:withEvent:方法，并且每次调用时的touches参数中只包含一个UITouch对象</li><li>根据touches中UITouch的个数可以判断出是单点触摸还是多点触摸</li></ul></li></ul><h1 id="事件产生和传递"><a href="#事件产生和传递" class="headerlink" title="事件产生和传递"></a>事件产生和传递</h1><hr><ul><li>发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中</li><li>UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）</li><li>主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步</li><li><p>找到合适的视图控件后，就会调用视图控件的touches方法来作具体的事件处理</p><ul><li>touchesBegan…</li><li>touchesMoved…</li><li>touchedEnded…</li></ul></li><li><p><strong>如果父控件不能接收触摸事件，那么子控件就不可能接收到触摸事件</strong></p></li><li><p>UIView不接收触摸事件的三种情况：</p><ol><li><code>不接收用户交互</code> userInteractionEnabled = NO</li><li><code>隐藏</code> hidden = YES</li><li><p><code>透明</code> alpha = 0.0 ~ 0.01</p><p><em>提示：UIImageView的userInteractionEnabled默认就是NO，因此UIImageView以及它的子控件默认是不能接收触摸事件的</em></p></li></ol></li></ul><h1 id="响应者链条"><a href="#响应者链条" class="headerlink" title="响应者链条"></a>响应者链条</h1><hr><ul><li>响应者链条：是由多个响应者对象连接起来的链条</li><li>作用：能很清楚的看见每个响应者之间的联系，并且可以让一个事件多个对象处理。</li><li>响应者对象：能处理事件的对象</li></ul><h2 id="响应者链条示意图"><a href="#响应者链条示意图" class="headerlink" title="响应者链条示意图"></a>响应者链条示意图</h2><p><img src="http://upload-images.jianshu.io/upload_images/1879463-1e597f7a72595802.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="事件传递的完整过程"><a href="#事件传递的完整过程" class="headerlink" title="事件传递的完整过程"></a>事件传递的完整过程</h2><ol><li>先将事件对象由上往下传递(由父控件传递给子控件)，找到最合适的控件来处理这个事件。</li><li>调用最合适控件的touches….方法</li><li>如果调用了[super touches….];就会将事件顺着响应者链条往上传递，传递给上一个响应者</li><li>接着就会调用上一个响应者的touches….方法</li></ol><ul><li><strong>如何判断上一个响应者</strong><ol><li>如果当前这个view是控制器的view,那么控制器就是上一个响应者</li><li>如果当前这个view不是控制器的view,那么父控件就是上一个响应者</li></ol></li></ul><h2 id="响应者链的事件传递过程"><a href="#响应者链的事件传递过程" class="headerlink" title="响应者链的事件传递过程"></a>响应者链的事件传递过程</h2><ol><li>如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图</li><li>在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理</li><li>如果window对象也不处理，则其将事件或消息传递给UIApplication对象</li><li>如果UIApplication也不能处理该事件或消息，则将其丢弃</li></ol><h1 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h1><hr><blockquote><p>为了完成手势识别，必须借助于手势识别器—-UIGestureRecognizer;<br>利用UIGestureRecognizer，能轻松识别用户在某个view上面做的一些常见手势</p></blockquote><ul><li><p>UIGestureRecognizer是一个抽象类，定义了所有手势的基本行为，使用它的子类才能处理具体的手势</p><ul><li>UITapGestureRecognizer(敲击)</li><li>UIPinchGestureRecognizer(捏合，用于缩放)</li><li>UIPanGestureRecognizer(拖拽)</li><li>UISwipeGestureRecognizer(轻扫)</li><li>UIRotationGestureRecognizer(旋转)</li><li>UILongPressGestureRecognizer(长按)</li></ul></li><li><p>每一个手势识别器的用法都差不多，比如UITapGestureRecognizer的使用步骤如下：</p><ul><li><p>创建手势识别器对象</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UITapGestureRecognizer</span> *tap = [[<span class="built_in">UITapGestureRecognizer</span> alloc] init];</span><br></pre></td></tr></table></figure></li><li><p>设置手势识别器对象的具体属性</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连续敲击2次</span></span><br><span class="line">tap.numberOfTapsRequired = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 需要2根手指一起敲击</span></span><br><span class="line">tap.numberOfTouchesRequired = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p>添加手势识别器到对应的view上</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.iconView addGestureRecognizer:tap];</span><br></pre></td></tr></table></figure></li><li><p>监听手势的触发</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tap addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(tapIconView:)];</span><br></pre></td></tr></table></figure></li></ul></li><li><p>手势识别的状态</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIGestureRecognizerState</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有触摸事件发生，所有手势识别的默认状态</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStatePossible</span>,</span><br><span class="line">    <span class="comment">// 一个手势已经开始但尚未改变或者完成时</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateBegan</span>,</span><br><span class="line">    <span class="comment">// 手势状态改变</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateChanged</span>,</span><br><span class="line">    <span class="comment">// 手势完成</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateEnded</span>,</span><br><span class="line">    <span class="comment">// 手势取消，恢复至Possible状态</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateCancelled</span>, </span><br><span class="line">    <span class="comment">// 手势失败，恢复至Possible状态</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateFailed</span>,</span><br><span class="line">    <span class="comment">// 识别到手势识别</span></span><br><span class="line">    <span class="built_in">UIGestureRecognizerStateRecognized</span> = <span class="built_in">UIGestureRecognizerStateEnded</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发之核心动画</title>
      <link href="/2016/04/27/iOS%E5%BC%80%E5%8F%91%E4%B9%8B%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB/"/>
      <url>/2016/04/27/iOS%E5%BC%80%E5%8F%91%E4%B9%8B%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Core Animation,中文翻译为核心动画,它是一组非常强大的动画处理API,使用它能做出非常绚丽的动画效果,而且往往事半功倍.也就是说,使用少量的代码就可以实现非常强大的功能.</p></blockquote><a id="more"></a><ul><li>Core Animation的动画执行过程都是在后台操作的,不会阻塞主线程</li><li>Core Animation是直接作用在CALayer上的,并非UIView</li></ul><p><em>所以在了解Core Animation之前,先要了解什么是CALayer</em></p><h2 id="CALayer"><a href="#CALayer" class="headerlink" title="CALayer"></a>CALayer</h2><blockquote><p>在iOS中,你能看得见摸得着的东西基本上都是UIView,比如:按钮,文本标签等等;其实UIView之所以能显示在屏幕上,完全是因为它内部的一个图层</p></blockquote><ul><li>在创建UIView对象时,UIView内部会自动创建一个图层(即CALayer对象),通过UIView的layer属性可以访问这个层</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">retain</span>) <span class="built_in">CALayer</span> *layer; </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">- 当<span class="built_in">UIView</span>需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了<span class="built_in">UIView</span>的显示;<span class="built_in">UIView</span>本身不具备显示的功能，是它内部的层才有显示功能</span><br><span class="line">- <span class="built_in">CALayer</span>的一些属性</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line"><span class="comment">//宽度和高度</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">CGRect</span> bounds;</span><br><span class="line"><span class="comment">//位置(默认指中点，具体由anchorPoint决定)</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">CGPoint</span> position;</span><br><span class="line"><span class="comment">//锚点(x,y的范围都是0-1)，决定了position的含义</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">CGPoint</span> anchorPoint;</span><br><span class="line"><span class="comment">//背景颜色(CGColorRef类型)</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">CGColorRef</span> backgroundColor;</span><br><span class="line"><span class="comment">//形变属性</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">CATransform3D</span> transform;</span><br><span class="line"><span class="comment">//边框颜色(CGColorRef类型)</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">CGColorRef</span> borderColor;</span><br><span class="line"><span class="comment">//边框宽度</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">CGFloat</span> borderWidth;</span><br><span class="line"><span class="comment">//圆角半径</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">CGColorRef</span> borderColor;</span><br><span class="line"><span class="comment">//内容(比如设置为图片CGImageRef)</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">retain</span>) <span class="keyword">id</span> contents;</span><br></pre></td></tr></table></figure><blockquote><p>UIView和CALayer的选择</p></blockquote><p>通过CALayer，就能做出跟UIImageView一样的界面效果<br>既然CALayer和UIView都能实现相同的显示效果，那究竟该选择谁好呢？<br>其实，对比CALayer，UIView多了一个事件处理的功能。也就是说，CALayer不能处理用户的触摸事件，而UIView可以.<br>所以，如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以.<br>当然，CALayer的性能会高一些，因为它少了事件处理的功能，更加轻量级.</p><blockquote><p>position和anchorPoint</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">CGPoint</span> position;</span><br></pre></td></tr></table></figure><ol><li>用来设置CALayer在父层中的位置</li></ol><ul><li>以父层的左上角为原点(0, 0)</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> <span class="built_in">CGPoint</span> anchorPoint;</span><br></pre></td></tr></table></figure><ol><li>称为“定位点”、“锚点”</li></ol><ul><li>决定着CALayer身上的哪个点会在position属性所指的位置</li><li>以自己的左上角为原点(0, 0)</li><li>它的x、y取值范围都是0~1，默认值为（0.5, 0.5）</li></ul><blockquote><p>隐式动画</p></blockquote><ul><li>每一个UIView内部都默认关联着一个CALayer，我们可用称这个Layer为Root Layer（根层）</li><li>所有的非Root Layer，也就是手动创建的CALayer对象，都存在着隐式动画</li><li>什么是隐式动画？<ul><li>当对非Root Layer的部分属性进行修改时，默认会自动产生一些动画效果</li><li>而这些属性称为Animatable Properties(可动画属性)</li><li>列举几个常见的Animatable Properties：<ol><li>bounds：用于设置CALayer的宽度和高度。修改这个属性会产生缩放动画</li></ol><ul><li>backgroundColor：用于设置CALayer的背景色。修改这个属性会产生背景色的渐变动画</li><li>position：用于设置CALayer的位置。修改这个属性会产生平移动画</li></ul></li><li>可以通过动画事务(CATransaction)关闭默认的隐式动画效果</li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">CATransaction</span> begin];</span><br><span class="line">[<span class="built_in">CATransaction</span> setDisableActions:<span class="literal">YES</span>];</span><br><span class="line"><span class="keyword">self</span>.myview.layer.position = <span class="built_in">CGPointMake</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">[<span class="built_in">CATransaction</span> commit];</span><br></pre></td></tr></table></figure><h2 id="Core-Animation"><a href="#Core-Animation" class="headerlink" title="Core Animation"></a>Core Animation</h2><p><img src="http://7xtfqf.com2.z0.glb.clouddn.com/Snip20160427_1.png" alt="Core Animation结构图"></p><ul><li>核心动画中所有类都遵守CAMediaTiming</li><li>CAAnaimation是个抽象类，不具备动画效果，必须用它的子类才有动画效果</li><li>CAAnimationGroup和CATransition才有动画效果<ul><li>CAAnimationGroup是个动画组，可以同时进行缩放，旋转。</li><li>CATransition是转场动画，界面之间跳转都可以用转场动画。</li></ul></li><li>CAPropertyAnimation也是个抽象类，本身不具备动画效果，只有子类才有<ul><li>CABasicAnimation和CAKeyframeAnimation<ol><li>CABasicAnimation基本动画，做一些简单效果</li></ol><ul><li>CAKeyframeAnimation帧动画，做一些连续的流畅的动画</li></ul></li></ul></li></ul><blockquote><p>开发步骤</p></blockquote><p><em>如果不是xcode5之后的版本，使用它需要先添QuartzCore.framework和引入对应的框架<quartzcore quartzcore.h></quartzcore></em></p><ol><li>首先得有CALayer</li></ol><ul><li>初始化一个CAAnimation对象，并设置一些动画相关属性</li><li>通过调用CALayer的addAnimation:forKey:方法，增加CAAnimation对象到CALayer中，这样就能开始执行动画了</li><li>通过调用CALayer的removeAnimationForKey:方法可以停止CALayer中的动画</li></ul><h3 id="CAAnimation"><a href="#CAAnimation" class="headerlink" title="CAAnimation"></a>CAAnimation</h3><blockquote><p>简介</p></blockquote><ul><li>是所有动画对象的父类，负责控制动画的持续时间和速度，是个抽象类，不能直接使用，应该使用它具体的子类</li><li>属性说明：(红色代表来自CAMediaTiming协议的属性)<ul><li>duration：动画的持续时间</li><li>repeatCount：重复次数，无限循环可以设置HUGE_VALF或者MAXFLOAT</li><li>repeatDuration：重复时间</li><li>removedOnCompletion：默认为YES，代表动画执行完毕后就从图层上移除，图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为NO，不过还要设置fillMode为kCAFillModeForwards</li><li>fillMode：决定当前对象在非active时间段的行为。比如动画开始之前或者动画结束之后</li><li>beginTime：可以用来设置动画延迟执行时间，若想延迟2s，就设置为CACurrentMediaTime()+2，CACurrentMediaTime()为图层的当前时间</li><li>timingFunction：速度控制函数，控制动画运行的节奏</li><li>delegate：动画代理</li></ul></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark 暂停CALayer的动画</span></span><br><span class="line">-(<span class="keyword">void</span>)pauseLayer:(<span class="built_in">CALayer</span>*)layer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CFTimeInterval</span> pausedTime = [layer convertTime:<span class="built_in">CACurrentMediaTime</span>() fromLayer:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让CALayer的时间停止走动</span></span><br><span class="line">      layer.speed = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// 让CALayer的时间停留在pausedTime这个时刻</span></span><br><span class="line">    layer.timeOffset = pausedTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#pragma mark 恢复CALayer的动画</span></span><br><span class="line">-(<span class="keyword">void</span>)resumeLayer:(<span class="built_in">CALayer</span>*)layer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CFTimeInterval</span> pausedTime = layer.timeOffset;</span><br><span class="line">    <span class="comment">// 1. 让CALayer的时间继续行走</span></span><br><span class="line">      layer.speed = <span class="number">1.0</span>;</span><br><span class="line">    <span class="comment">// 2. 取消上次记录的停留时刻</span></span><br><span class="line">      layer.timeOffset = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// 3. 取消上次设置的时间</span></span><br><span class="line">      layer.beginTime = <span class="number">0.0</span>;    </span><br><span class="line">    <span class="comment">// 4. 计算暂停的时间(这里也可以用CACurrentMediaTime()-pausedTime)</span></span><br><span class="line">    <span class="built_in">CFTimeInterval</span> timeSincePause = [layer convertTime:<span class="built_in">CACurrentMediaTime</span>() fromLayer:<span class="literal">nil</span>] - pausedTime;</span><br><span class="line">    <span class="comment">// 5. 设置相对于父坐标系的开始时间(往后退timeSincePause)</span></span><br><span class="line">      layer.beginTime = timeSincePause;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>动画填充模式</p></blockquote><ul><li>fillMode属性值（要想fillMode有效，最好设置removedOnCompletion = NO）</li><li>kCAFillModeRemoved 这个是默认值，也就是说当动画开始前和动画结束后，动画对layer都没有影响，动画结束后，layer会恢复到之前的状态</li><li>kCAFillModeForwards 当动画结束后，layer会一直保持着动画最后的状态 </li><li>kCAFillModeBackwards 在动画开始前，只需要将动画加入了一个layer，layer便立即进入动画的初始状态并等待动画开始。</li><li>kCAFillModeBoth 这个其实就是上面两个的合成.动画加入后开始之前，layer便处于动画初始状态，动画结束后layer保持动画最后的状态</li></ul><blockquote><p>速度控制函数</p></blockquote><ul><li>速度控制函数(CAMediaTimingFunction) <ol><li>kCAMediaTimingFunctionLinear（线性）：匀速，给你一个相对静态的感觉</li></ol><ul><li>kCAMediaTimingFunctionEaseIn（渐进）：动画缓慢进入，然后加速离开</li><li>kCAMediaTimingFunctionEaseOut（渐出）：动画全速进入，然后减速的到达目的地</li><li>kCAMediaTimingFunctionEaseInEaseOut（渐进渐出）：动画缓慢的进入，中间加速，然后减速的到达目的地。这个是默认的动画行为。</li></ul></li></ul><blockquote><p>动画代理方法</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">CAAnimationDelegate</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Called when the animation begins its active duration. */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)animationDidStart:(<span class="built_in">CAAnimation</span> *)anim;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Called when the animation either completes its active duration or</span></span><br><span class="line"><span class="comment"> * is removed from the object it is attached to (i.e. the layer). 'flag'</span></span><br><span class="line"><span class="comment"> * is true if the animation reached the end of its active duration</span></span><br><span class="line"><span class="comment"> * without being removed. */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)animationDidStop:(<span class="built_in">CAAnimation</span> *)anim finished:(<span class="built_in">BOOL</span>)flag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="1-CAPropertyAnimation"><a href="#1-CAPropertyAnimation" class="headerlink" title="1. CAPropertyAnimation"></a>1. CAPropertyAnimation</h4><ul><li><p>是CAAnimation的子类，也是个抽象类，要想创建动画对象，应该使用它的两个子类：</p><ol><li>CABasicAnimation</li></ol><ul><li>CAKeyframeAnimation</li></ul></li><li><p>属性说明：</p><ul><li>keyPath：通过指定CALayer的一个属性名称为keyPath（NSString类型），并且对CALayer的这个属性的值进行修改，达到相应的动画效果。比如，指定@“position”为keyPath，就修改CALayer的position属性的值，以达到平移的动画效果</li></ul></li></ul><blockquote><p>CABasicAnimation</p></blockquote><ul><li><p>基本动画,是CAPropertyAnimation的子类</p></li><li><p>属性说明:</p><ul><li>fromValue：keyPath相应属性的初始值</li><li>toValue：keyPath相应属性的结束值</li></ul></li><li><p>动画过程说明：</p><ul><li>随着动画的进行，在长度为duration的持续时间内，keyPath相应属性的值从fromValue渐渐地变为toValue</li><li>keyPath内容是CALayer的可动画Animatable属性</li><li>如果fillMode=kCAFillModeForwards同时removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。</li></ul></li></ul><blockquote><p>关键帧动画</p></blockquote><ul><li><p>关键帧动画，也是CAPropertyAnimation的子类，与CABasicAnimation的区别是：</p><ul><li>CABasicAnimation只能从一个数值（fromValue）变到另一个数值（toValue），而CAKeyframeAnimation会使用一个NSArray保存这些数值</li></ul></li><li><p>属性说明：</p><ul><li>values：上述的NSArray对象。里面的元素称为“关键帧”(keyframe)。动画对象会在指定的时间（duration）内，依次显示values数组中的每一个关键帧</li><li>path：可以设置一个CGPathRef、CGMutablePathRef，让图层按照路径轨迹移动。path只对CALayer的anchorPoint和position起作用。如果设置了path，那么values将被忽略</li><li>keyTimes：可以为对应的关键帧指定对应的时间点，其取值范围为0到1.0，keyTimes中的每一个时间值都对应values中的每一帧。如果没有设置keyTimes，各个关键帧的时间是平分的</li></ul></li></ul><p><em>CABasicAnimation可看做是只有2个关键帧的CAKeyframeAnimation</em></p><h4 id="2-CAAnimationGroup"><a href="#2-CAAnimationGroup" class="headerlink" title="2. CAAnimationGroup"></a>2. CAAnimationGroup</h4><ul><li><p>动画组，是CAAnimation的子类，可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行</p></li><li><p>属性说明：</p><ul><li>animations：用来保存一组动画对象的NSArray</li><li>默认情况下，一组动画对象是同时运行的，也可以通过设置动画对象的beginTime属性来更改动画的开始时间</li></ul></li></ul><h4 id="3-CATransition"><a href="#3-CATransition" class="headerlink" title="3. CATransition"></a>3. CATransition</h4><ul><li>CATransition是CAAnimation的子类，用于做转场动画，能够为层提供移出屏幕和移入屏幕的动画效果。iOS比Mac OS X的转场动画效果少一点</li><li>UINavigationController就是通过CATransition实现了将控制器的视图推入屏幕的动画效果</li><li>动画属性:<ul><li>type：动画过渡类型</li><li>subtype：动画过渡方向</li><li>startProgress：动画起点(在整体动画的百分比)</li><li>endProgress：动画终点(在整体动画的百分比)</li><li>转场动画过渡效果</li></ul></li></ul><table><thead><tr><th style="text-align:center">类型字符串</th><th style="text-align:center">效果说明</th><th style="text-align:center">关键字</th><th style="text-align:center">方向</th></tr></thead><tbody><tr><td style="text-align:center">fade</td><td style="text-align:center">交叉淡化过渡</td><td style="text-align:center">YES</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">push</td><td style="text-align:center">新视图把旧视图推出去</td><td style="text-align:center">YES</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">moveIn</td><td style="text-align:center">新视图移到旧视图上面</td><td style="text-align:center">YES</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">reveal</td><td style="text-align:center">将旧视图移开,显示下面的新视图</td><td style="text-align:center">YES</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">cube</td><td style="text-align:center">立方体翻滚效果</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">oglFlip</td><td style="text-align:center">上下左右翻转效果</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">suckEffect</td><td style="text-align:center">收缩效果，如一块布被抽走</td><td style="text-align:center"></td><td style="text-align:center">NO</td></tr><tr><td style="text-align:center">rippleEffect</td><td style="text-align:center">水滴效果</td><td style="text-align:center"></td><td style="text-align:center">NO</td></tr><tr><td style="text-align:center">pageCurl</td><td style="text-align:center">向上翻页效果</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">pageUnCurl</td><td style="text-align:center">向下翻页效果</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">facameraIrisHollowOpende</td><td style="text-align:center">相机镜头打开效果</td><td style="text-align:center"></td><td style="text-align:center">NO</td></tr><tr><td style="text-align:center">cameraIrisHollowClose</td><td style="text-align:center">相机镜头关闭效果</td><td style="text-align:center"></td><td style="text-align:center">NO</td></tr></tbody></table><blockquote><p>使用UIView动画函数实现转场动画——单视图</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)transitionWithView:(<span class="built_in">UIView</span> *)view duration:(<span class="built_in">NSTimeInterval</span>)duration options:(<span class="built_in">UIViewAnimationOptions</span>)options animations:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))animations completion:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span> finished))completion;</span><br></pre></td></tr></table></figure><ul><li>参数说明：<ul><li>duration：动画的持续时间</li><li>view：需要进行转场动画的视图</li><li>options：转场动画的类型</li><li>animations：将改变视图属性的代码放在这个block中</li><li>completion：动画结束后，会自动调用这个block</li></ul></li></ul><blockquote><p>使用UIView动画函数实现转场动画——双视图</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)transitionFromView:(<span class="built_in">UIView</span> *)fromView toView:(<span class="built_in">UIView</span> *)toView duration:(<span class="built_in">NSTimeInterval</span>)duration options:(<span class="built_in">UIViewAnimationOptions</span>)options completion:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span> finished))completion;</span><br></pre></td></tr></table></figure><ul><li>参数说明：<ul><li>duration：动画的持续时间</li><li>options：转场动画的类型</li><li>animations：将改变视图属性的代码放在这个block中</li><li>completion：动画结束后，会自动调用这个block</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发之混合开发简单介绍</title>
      <link href="/2016/04/18/iOS%E5%BC%80%E5%8F%91%E4%B9%8B%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
      <url>/2016/04/18/iOS%E5%BC%80%E5%8F%91%E4%B9%8B%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p><em>2014年,历时8年的HTML标准制定完成.利用HTML5编写的UI界面能运行在所有拥有浏览器的平台之上,且开发迅速而简单.这样,混合开发使得iOS开发变得更简单,更快捷</em></p></blockquote><a id="more"></a><h3 id="1-Web开发新时代"><a href="#1-Web开发新时代" class="headerlink" title="1. Web开发新时代"></a>1. Web开发新时代</h3><ul><li><p>Web1.0<br>  主流技术:HTML+CSS</p></li><li><p>Web2.0<br>  主流技术:Ajax(JavaScript/DOM/异步数据请求)</p></li><li><p>Web3.0<br>  主流技术:HTML5+CSS3<br>  HTML5亮点: Canvas\HTML5音视频\Web存储 Geolocation \Workers多线程处理<br>  CSS3亮点: 设计动画\2D变形\N多新特性</p></li></ul><blockquote><p>网页的组成</p></blockquote><ul><li><p>一个有具体功能的完整的网页，一般由3部分组成</p><ul><li>HTML<br>网页的具体内容和结构</li></ul><ul><li><p>CSS<br>网页的样式（美化网页最重要的一块）</p></li><li><p>JavaScript(掌握)<br>网页的交互效果，比如对用户鼠标事件做出响应</p></li></ul></li><li><p>HTML\CSS\JavaScript学习资料：<a href="http://www.w3school.com.cn/" target="_blank" rel="noopener">http://www.w3school.com.cn/</a></p></li></ul><h3 id="2-HTML"><a href="#2-HTML" class="headerlink" title="2. HTML"></a>2. HTML</h3><blockquote><p>什么是HTML</p></blockquote><ul><li>HTML的全称是HyperText Markup Language，超文本标记语言</li><li>其实它就是文本，由浏览器负责将它解析成具体的网页内容</li></ul><blockquote><p>HTML的组成</p></blockquote><ul><li>跟XML类似，HTML由N个标签（节点、元素、标记）组成   </li></ul><blockquote><p>HTML语法非常松散，目前的最新版是5.0，也就是HTML 5</p></blockquote><ul><li>常见的HTML标签<ul><li>标题：h1、h2、h3、h4、h5….</li><li>段落：p</li><li>换行：br</li><li>容器：div、span（用来容纳其他标签）</li><li>表格：table、tr、td</li><li>列表：ul、ol、li</li><li>图片：img</li><li>表单：input</li><li>链接：a</li></ul></li></ul><ul><li><p>HTML标签类型<br>HTML有N多标签，根据显示的类型，主要可以分为3大类</p><ol><li><p>块级标签<br>独占一行的标签<br>能随时设置宽度和高度（比如div、p、h1、h2、ul、li）</p></li><li><p>行内标签（内联标签）<br>多个行内标签能同时显示在一行<br>宽度和高度取决于内容的尺寸（比如span、a、label）</p></li><li><p>行内-块级标签（内联-块级标签）<br>多个行内-块级标签可以显示在同一行<br>能随时设置宽度和高度（比如input、button）</p></li></ol></li><li>CSS中有个display属性，能修改标签的显示类型<ul><li><code>none</code>：隐藏标签</li><li><code>block</code>：让标签变为块级标签</li><li><code>inline</code>：让标签变为行内标签</li><li><code>inline-block</code>：让标签变为行内-块级标签（内联-块级标签）</li></ul></li></ul><blockquote><p>HTML5新增标签</p></blockquote><ul><li><p>HTML5新增了27个标签元素,废弃了16个标签元素,主要包括结构性标签、级块性标签、行内语义性标签、交互性标签</p><ol><li><p>结构性标签<br>负责Web上下文结构的定义，确保HTML文档，包括：</p><pre><code>- article  文章主体内容(一篇博客、一篇论坛帖子、一段用户评论、插件)- header   标记头部区域内容- footer   标记脚部区域内容- section  区域章节表述- nav      菜单导航,链接导航</code></pre></li><li><p>块级性标签<br>完成Web页面区域的划分，确保内容的有效分隔，包括：</p><pre><code>- aside   注记,贴士,侧栏,摘要,插入的引用作为补充主体的内容- figure  对多个元素组合并展示的元素,常与figcaption联合使用- code    表示一段代码块- dialog  人与人之间对话,包含dt和dd两个组合元素（dt用于表示说话者、dd用于表示说话者的内容）</code></pre></li><li><p>行内语义性标签<br>完成Web页面具体内容的引用和表述，丰富展示内容，包括：</p><pre><code>- meter     特定范围内的数值，如工资、数量、百分比- time      时间值- progress  进度条，可用max、min、step进行控制，完成对进度的表示和监听- video     视频元素，用于视频播放，支持缓冲预载和多种视频媒体格式- audio     音频元素，用于音频播放，支持缓冲预载和多种音频媒体格式</code></pre></li><li><p>交互性标签<br>功能性内容的表达，有一定的内容和数据的关联，是各种事件的基础，包括：</p><pre><code>- details   表示一段具体的内容，默认不显示，通过某种方式（单击）与legend交互才会显示- datagrid  控制客户端数据与显示，可用于动态脚本及时更新- menu      用于交互菜单- command   用来处理命令按钮</code></pre></li></ol></li></ul><h3 id="3-CSS"><a href="#3-CSS" class="headerlink" title="3. CSS"></a>3. CSS</h3><blockquote><p>什么是CSS</p></blockquote><ul><li>CSS的全称是Cascading Style Sheets，层叠样式表</li><li>它用来控制HTML标签的样式，在美化网页中起到非常重要的作用</li><li><p>CSS的编写格式是键值对形式的，比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">color: red;</span><br><span class="line">background-color: blue;</span><br><span class="line">font-size: 20px;</span><br><span class="line">```    </span><br><span class="line">  - 冒号:左边的是属性名，冒号:右边的属性值</span><br><span class="line"></span><br><span class="line">&gt;CSS的3种书写形式</span><br><span class="line"></span><br><span class="line">- 行内样式：（内联样式）直接在标签的style属性中书写</span><br></pre></td></tr></table></figure><p>  <body style="color: red;"></body></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 页内样式：在本网页的style标签中书写</span><br></pre></td></tr></table></figure><p>  <style><br>  body {<br>  color: red;<br>  }<br>  </style></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 外部样式：在单独的CSS文件中书写，然后在网页中用link标签引用</span><br></pre></td></tr></table></figure><p>  <link rel="stylesheet" href="index.css"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;CSS的两大重点</span><br><span class="line"></span><br><span class="line">1. 属性</span><br><span class="line">    通过属性的复杂叠加才能做出漂亮的网页</span><br><span class="line">  - CSS有N多属性，根据继承性，主要可以分为2大类</span><br><span class="line">    - 可继承属性</span><br><span class="line">父标签的属性值会传递给子标签</span><br><span class="line">一般是文字控制属性</span><br></pre></td></tr></table></figure></li></ul><p>所有标签可继承<br>visibility、cursor<br>内联标签可继承<br>letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction<br> 块级标签可继承<br>text-indent、text-align<br>列表标签可继承<br>list-style、list-style-type、list-style-position、list-style-image<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - 不可继承属性</span><br><span class="line">父标签的属性值不能传递给子标签</span><br><span class="line">一般是区块控制属性</span><br></pre></td></tr></table></figure></p><p>display、margin、border、padding、background<br>height、min-height、max-height、width、min-width、max-width<br>overflow、position、left、right、top、bottom、z-index<br>float、clear<br>table-layout、vertical-align<br>page-break-after、page-bread-before<br>unicode-bidi<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">2. 选择器</span><br><span class="line">    通过选择器找到对应的标签设置样式*(具体选择器内容和教程请参考:http://www.w3school.com.cn/css/index.asp)*</span><br><span class="line"></span><br><span class="line">&gt; CSS布局</span><br><span class="line"></span><br><span class="line">-  默认情况下，所有的网页标签都在标准流布局中,从上到下，从左到右</span><br><span class="line">- 脱离标准流的方法有</span><br><span class="line">  - float属性</span><br><span class="line">    - float属性的常用取值有:</span><br><span class="line">        `left`：脱离标准流，浮动在父标签的最左边</span><br><span class="line">`right`：脱离标准流，浮动在父标签的最右边</span><br><span class="line">  - position属性</span><br><span class="line"></span><br><span class="line">    ![position属性](http://upload-images.jianshu.io/upload_images/1879463-98d3215b81c3df23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">&gt;CSS3新增特性</span><br><span class="line"></span><br><span class="line">- **RGBA透明度**</span><br><span class="line">   RGB(红色R+绿色G+蓝色B),RGBA则在其基础上增加了Alpha通道，可用于设置透明值</span><br><span class="line"></span><br><span class="line">- **块阴影与圆角阴影**</span><br><span class="line">   box-shadow  text-shadow</span><br><span class="line"></span><br><span class="line">- **圆角**</span><br><span class="line">    border-radius</span><br><span class="line"></span><br><span class="line">- **边框图片**</span><br><span class="line">     border-image</span><br><span class="line"></span><br><span class="line">- **形变**</span><br><span class="line">   transform: none | &lt;transform-function&gt;[&lt;transform-fuction&gt;]</span><br><span class="line"></span><br><span class="line">### 4. 盒子模型</span><br><span class="line"></span><br><span class="line">![盒子模型](http://upload-images.jianshu.io/upload_images/1879463-dcd26e170da66975.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line">- 网页上的每一个标签都是一个盒子</span><br><span class="line">- 每个盒子都有四个属性</span><br><span class="line">  1. 内容（content）</span><br><span class="line"></span><br><span class="line">![内容属性](http://upload-images.jianshu.io/upload_images/1879463-fd9b30c8df171c7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line">  2. 填充（padding，内边距）</span><br><span class="line"></span><br><span class="line">![填充属性](http://upload-images.jianshu.io/upload_images/1879463-5689bf59b9e0f5fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line">  3. 边框（border）：盒子本身</span><br><span class="line">  4. 边界（margin，外边距）</span><br><span class="line"></span><br><span class="line">![边界属性](http://upload-images.jianshu.io/upload_images/1879463-2803e390750974e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">![标准盒子模型](http://upload-images.jianshu.io/upload_images/1879463-7d4bf71b5a129753.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">![IE盒子模型](http://upload-images.jianshu.io/upload_images/1879463-0ad03d90f842a6aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">### 4. JavaScript</span><br><span class="line">&gt;什么是JavaScript</span><br><span class="line"></span><br><span class="line">- JavaScript是一门广泛用于浏览器客户端的脚本语言，由Netspace公司设计，当时跟Sun公司合作，所以名字起得像Java。业内一般简称JS</span><br><span class="line"></span><br><span class="line">&gt;JS的常见用途</span><br><span class="line"></span><br><span class="line">- HTML DOM操作（节点操作，比如添加、修改、删除节点）</span><br><span class="line">- 给HTML网页增加动态功能，比如动画</span><br><span class="line">- 事件处理：比如监听鼠标点击、鼠标滑动、键盘输入</span><br><span class="line"></span><br><span class="line">&gt;JavaScript的书写方式</span><br><span class="line"></span><br><span class="line">- JS常见的书写方式有2种</span><br><span class="line">  - 页内JS：在当前网页的script标签中编写</span><br></pre></td></tr></table></figure></p><p><script type="text/javascript"><br></script><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 外部JS</span><br></pre></td></tr></table></figure></p><p><script src="index.js"></script><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;Canvas</span><br><span class="line"></span><br><span class="line">-  HTML</span><br></pre></td></tr></table></figure></p><pre><code>&lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- JS</span><br></pre></td></tr></table></figure><p>   var canvas = document.getElementById(‘canvas’);<br>   var context = canvas.getContext(‘2d’);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    - `context`是一个绘图的上下文环境</span><br><span class="line">    - `2d`是二维图形</span><br><span class="line"></span><br><span class="line">- Canvas绘制直线</span><br><span class="line">  - 起点</span><br></pre></td></tr></table></figure></p><p>   context.moveTo(100,100);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  - 终点</span><br><span class="line">```  </span><br><span class="line">context.lineTo(400, 400);</span><br></pre></td></tr></table></figure></p><ul><li><p>绘制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    context.stroke();</span><br></pre></td></tr></table></figure></li><li><p>设置线条颜色和宽度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    context.strokeStyle = &apos;red&apos;;</span><br><span class="line">   context.lineWidth = 5;</span><br></pre></td></tr></table></figure></li><li><p>设置填充色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    context.fillStyle = &apos;blue&apos;;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Canvas绘制弧线</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> context.arc(</span><br><span class="line">          centerX, centerY, radius,</span><br><span class="line">          startingAngle, endingAngle, </span><br><span class="line">          anticlockwise=false     </span><br><span class="line">       )</span><br></pre></td></tr></table></figure><ul><li><code>centerX, centerY</code>: 圆心的坐标</li><li><code>radius</code>: 半径</li><li><code>startingAngle</code>, <code>endingAngle</code>: 开始角度,结束角度</li><li><code>anticlockwise</code>: false顺时针 true逆时针</li></ul></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1879463-b56a7746859fd186.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Canvas绘制弧线"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发之数据存储</title>
      <link href="/2016/04/12/iOS%E5%BC%80%E5%8F%91%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
      <url>/2016/04/12/iOS%E5%BC%80%E5%8F%91%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作为移动端开发工程师，所需要的数据几乎全部都是通过网络获取，而且网络请求都有时耗；在网络好的情况下这种时耗虽然不足考虑，但是一旦网络环境不好，会很影响产品体验。网络环境无法控制，但是对于一些数据不经常变动的网络请求或没必要实时更新的数据，我们可以选择将网络数据缓存本地，适时更新。</p></blockquote><a id="more"></a><h2 id="iOS应用数据存储的常用方式"><a href="#iOS应用数据存储的常用方式" class="headerlink" title="iOS应用数据存储的常用方式"></a>iOS应用数据存储的常用方式</h2><ul><li>XML属性列表(plist)归档</li><li>Preference(偏好设置)</li><li>NSKeyedArchiver归档(NSCoding)</li><li>SQLite 3</li><li>Core Data</li></ul><h2 id="应用沙盒"><a href="#应用沙盒" class="headerlink" title="应用沙盒"></a>应用沙盒</h2><p>每个iOS应用都有自己的应用沙盒(应用沙盒就是文件系统目录),与其他文件系统隔离,应用必须待在自己的沙盒里,其他应用不能访问沙盒</p><p>应用沙盒的文件系统目录,如下图所示(假设应用的名称叫Layer)</p><p><img src="http://upload-images.jianshu.io/upload_images/1879463-10f4ca6f7d0712b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="应用沙盒的文件系统目录.png"></p><h3 id="应用沙盒结构分析"><a href="#应用沙盒结构分析" class="headerlink" title="应用沙盒结构分析"></a>应用沙盒结构分析</h3><p><strong>应用程序包:</strong> (上图中的Layer)包含了所有的资源文件和可执行文件<br><strong>Documents:</strong> 保存应用运行时生成的需要持久化的数据,itunes同步设备时会备份该目录,例如:游戏应用可以将游戏存档保存在该目录<br><strong>tmp:</strong> 保存应用运行时所需的临时数据, 使用完毕后再见相应的文件从该目录删除.应用没有运行时,系统也可能会清除该目录下的文件.itunes同步设备的时候不会备份该文件夹<br><strong>Library/Caches:</strong> 保存应用运行时生成的需要持久化的数据,iTunes同步设备的时候不会备份该目录.一般存储体积大,不需要备份的非重要数据<br><strong>Library/Preferences:</strong> 保存应用的所有偏好设置,iOS的settings(设置)应用会在该目录中查找应用的设置信息.iTunes同步设备时会备份该目录</p><h3 id="应用沙盒目录的常见获取方式"><a href="#应用沙盒目录的常见获取方式" class="headerlink" title="应用沙盒目录的常见获取方式"></a>应用沙盒目录的常见获取方式</h3><h4 id="沙盒根目录"><a href="#沙盒根目录" class="headerlink" title="沙盒根目录"></a>沙盒根目录</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * home = <span class="built_in">NSHomeDirectory</span>();</span><br></pre></td></tr></table></figure><h4 id="Documents-2种方式"><a href="#Documents-2种方式" class="headerlink" title="Documents(2种方式)"></a>Documents(2种方式)</h4><ol><li>利用沙盒根目录拼接”Documents”字符串</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">NSString</span> * home = <span class="built_in">NSHomeDirectory</span>();</span><br><span class="line">    <span class="built_in">NSString</span> * documents = [home stringByAppendingPathComponent:<span class="string">@"Documents"</span>];</span><br></pre></td></tr></table></figure><p><em><code>不建议采用,因为新版本的操作系统可能会修改目录名</code></em></p><ol><li>利用NSSearchPathForDirectoriesInDomains函数</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NSUserDomainMask代表从用户文件夹下找</span></span><br><span class="line"><span class="comment">//YES,代表展开路径中的波浪字符"~"</span></span><br><span class="line"><span class="built_in">NSArray</span> * arr = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">NO</span>);</span><br><span class="line"><span class="comment">//在iOS中,只有一个目录跟传入的参数匹配,所以这个集合里面只有一个元素</span></span><br><span class="line"><span class="built_in">NSString</span> * documents = [arr objectAtIndex:<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h4 id="tmp"><a href="#tmp" class="headerlink" title="tmp"></a>tmp</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * tmp = <span class="built_in">NSTemporaryDirectory</span>();</span><br></pre></td></tr></table></figure><h4 id="Library-Caches-跟Documents相似的2种方法"><a href="#Library-Caches-跟Documents相似的2种方法" class="headerlink" title="Library/Caches(跟Documents相似的2种方法)"></a>Library/Caches(跟Documents相似的2种方法)</h4><ol><li>利用沙盒根目录拼接”Caches”字符串</li><li>利用NSSearchPathForDirectoriesInDomains函数 (将函数的第一个参数改为NSCachesDirectory即可)</li></ol><h4 id="Library-Preferences"><a href="#Library-Preferences" class="headerlink" title="Library/Preferences"></a>Library/Preferences</h4><p>通过NSUserDefaults类存取该目录下的设置信息</p><h2 id="属性列表"><a href="#属性列表" class="headerlink" title="属性列表"></a>属性列表</h2><p>属性列表是一种XML格式的文件, 拓展名为plist</p><p>如果对象是NSString\NSDictionary\NSArray\NSData\NSNumber等类型, 就可以使用writeToFile:atomically:方法直接将对象写到属性列表文件中</p><p>属性列表 - 归档NSDictionary</p><p>将一个NSDictionary对象归档到一个plist属性列表中</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将数据封装成字典</span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> * dic = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">[dic setObject:<span class="string">@"小米"</span> forKey:<span class="string">@"name"</span>];</span><br><span class="line">[dic setObject:<span class="string">@"11111111111"</span> forKey:<span class="string">@"phone"</span>];</span><br><span class="line">[dic setObject:<span class="string">@"6"</span> forKey:<span class="string">@"size"</span>];</span><br><span class="line"><span class="comment">//将字典持久化到Documents/phone.plist文件中</span></span><br><span class="line">[dic writeToFile:path atomically:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><p>NSDictionary的存储和读取过程</p><p><img src="http://upload-images.jianshu.io/upload_images/1879463-9397a6736de2278e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NSDictionary的存储和读取过程.png"></p><h2 id="偏好设置"><a href="#偏好设置" class="headerlink" title="偏好设置"></a>偏好设置</h2><p>很多iOS应用都支持偏好设置,比如保存用户名\密码\字体大小等设置, iOS提供了一套标准的解决方案来为应用加入偏好设置功能</p><p>每个应用都有个NSUserDefaults实例，通过它来存取偏好设置</p><p>比如，保存用户名、字体大小、是否自动登录</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSUserDefaults</span> *defaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br><span class="line">[defaults setObject:<span class="string">@"flame"</span> forKey:<span class="string">@"username"</span>];</span><br><span class="line">[defaults setFloat:<span class="number">18.0</span>f forKey:<span class="string">@"text_size"</span>];</span><br><span class="line">[defaults setBool:<span class="literal">YES</span> forKey:<span class="string">@"auto_login"</span>];</span><br></pre></td></tr></table></figure><p>读取上次保存的设置</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSUserDefaults</span> *defaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br><span class="line"><span class="built_in">NSString</span> *username = [defaults stringForKey:<span class="string">@"username"</span>];</span><br><span class="line"><span class="keyword">float</span> textSize = [defaults floatForKey:<span class="string">@"text_size"</span>];</span><br><span class="line"><span class="built_in">BOOL</span> autoLogin = [defaults boolForKey:<span class="string">@"auto_login"</span>];</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：UserDefaults设置数据时，不是立即写入，而是根据时间戳定时地把缓存中的数据写入本地磁盘。所以调用了set方法之后数据有可能还没有写入磁盘应用程序就终止了。出现以上问题，可以通过调用synchornize方法强制写入</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[defaults synchornize];</span><br></pre></td></tr></table></figure><h2 id="NSKeyedArchiver"><a href="#NSKeyedArchiver" class="headerlink" title="NSKeyedArchiver"></a>NSKeyedArchiver</h2><p>如果对象是NSString、NSDictionary、NSArray、NSData、NSNumber等类型，可以直接用NSKeyedArchiver进行归档和恢复</p><p>不是所有的对象都可以直接用这种方法进行归档，只有遵守了NSCoding协议的对象才可以</p><p>NSCoding协议有2个方法：</p><ol><li>encodeWithCoder<br> 每次归档对象时，都会调用这个方法。一般在这个方法里面指定如何归档对象中的每个实例变量，可以使用encodeObject:forKey:方法归档实例变量</li><li>initWithCoder<br> 每次从文件中恢复(解码)对象时，都会调用这个方法。一般在这个方法里面指定如何解码文件中的数据为对象的实例变量，可以使用decodeObject:forKey方法解码实例变量</li></ol><p>归档一个NSArray对象到Documents/array.archive</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects:@”a”,@”b”,<span class="literal">nil</span>];</span><br><span class="line">[<span class="built_in">NSKeyedArchiver</span> archiveRootObject:array toFile:path];</span><br></pre></td></tr></table></figure><p>恢复(解码)NSArray对象</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithFile:path];</span><br></pre></td></tr></table></figure><h2 id="归档对象"><a href="#归档对象" class="headerlink" title="归档对象"></a>归档对象</h2><p>NSKeyedArchiver-归档Person对象（Person.h）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span>&lt;<span class="title">NSCoding</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">float</span> height;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">```  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">NSKeyedArchiver</span>-归档Person对象（Person.m）</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">-(<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)encoder &#123;</span><br><span class="line">     [encoder encodeObject:<span class="keyword">self</span>.name forKey:<span class="string">@"name"</span>];</span><br><span class="line">     [encoder encodeInt:<span class="keyword">self</span>.age forKey:<span class="string">@"age"</span>];</span><br><span class="line">     [encoder encodeFloat:<span class="keyword">self</span>.height forKey:<span class="string">@"height"</span>];</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)decoder &#123;</span><br><span class="line">     <span class="keyword">self</span>.name = [decoder decodeObjectForKey:<span class="string">@"name"</span>];</span><br><span class="line">     <span class="keyword">self</span>.age = [decoder decodeIntForKey:<span class="string">@"age"</span>];</span><br><span class="line">     <span class="keyword">self</span>.height = [decoder decodeFloatForKey:<span class="string">@"height"</span>];</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">     [<span class="keyword">super</span> dealloc];</span><br><span class="line">     [_name release];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>NSKeyedArchiver-归档Person对象（编码和解码）</p><p>归档(编码)</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [[[Person alloc] init] autorelease];</span><br><span class="line">person.name = <span class="string">@"TY"</span>;</span><br><span class="line">person.age = <span class="number">27</span>;</span><br><span class="line">person.height = <span class="number">1.83</span>f;</span><br><span class="line">[<span class="built_in">NSKeyedArchiver</span> archiveRootObject:person toFile:path];</span><br></pre></td></tr></table></figure><p>恢复(解码)</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithFile:path];</span><br></pre></td></tr></table></figure><p>NSKeyedArchiver-归档对象的注意</p><p>如果父类也遵守了NSCoding协议，请注意：</p><ul><li>应该在encodeWithCoder:方法中加上一句</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">super</span> encodeWithCode:encode];</span><br></pre></td></tr></table></figure><p>确保继承的实例变量也能被编码，即也能被归档</p><ul><li>应该在initWithCoder:方法中加上一句</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> initWithCoder:decoder];</span><br></pre></td></tr></table></figure><p>确保继承的实例变量也能被解码，即也能被恢复</p><h2 id="NSData"><a href="#NSData" class="headerlink" title="NSData"></a>NSData</h2><p>使用archiveRootObject:toFile:方法可以将一个对象直接写入到一个文件中，但有时候可能想将多个对象写入到同一个文件中，那么就要使用NSData来进行归档对象<br>NSData可以为一些数据提供临时存储空间，以便随后写入文件，或者存放从磁盘读取的文件内容。可以使用[NSMutableData data]创建可变数据空间</p><p><img src="http://upload-images.jianshu.io/upload_images/1879463-30ccb4ca364a510e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流程图.png"></p><p>NSData-归档2个Person对象到同一文件中</p><p>归档（编码）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一块可变数据区</span></span><br><span class="line"><span class="built_in">NSMutableData</span> *data = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line"><span class="comment">// 将数据区连接到一个NSKeyedArchiver对象</span></span><br><span class="line"><span class="built_in">NSKeyedArchiver</span> *archiver = [[[<span class="built_in">NSKeyedArchiver</span> alloc] initForWritingWithMutableData:data] autorelease];</span><br><span class="line"><span class="comment">// 开始存档对象，存档的数据都会存储到NSMutableData中</span></span><br><span class="line">[archiver encodeObject:person1 forKey:<span class="string">@"person1"</span>];</span><br><span class="line">[archiver encodeObject:person2 forKey:<span class="string">@"person2"</span>];</span><br><span class="line"><span class="comment">// 存档完毕(一定要调用这个方法)</span></span><br><span class="line">[archiver finishEncoding];</span><br><span class="line"><span class="comment">// 将存档的数据写入文件</span></span><br><span class="line">[data writeToFile:path atomically:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><p>恢复（解码）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从文件中读取数据</span></span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:path];</span><br><span class="line"><span class="comment">// 根据数据，解析成一个NSKeyedUnarchiver对象</span></span><br><span class="line"><span class="built_in">NSKeyedUnarchiver</span> *unarchiver = [[<span class="built_in">NSKeyedUnarchiver</span> alloc] initForReadingWithData:data];</span><br><span class="line">Person *person1 = [unarchiver decodeObjectForKey:<span class="string">@"person1"</span>];</span><br><span class="line">Person *person2 = [unarchiver decodeObjectForKey:<span class="string">@"person2"</span>];</span><br><span class="line"><span class="comment">// 恢复完毕</span></span><br><span class="line">[unarchiver finishDecoding];</span><br></pre></td></tr></table></figure><p>利用归档实现深复制</p><p>比如对一个Person对象进行深复制</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 临时存储person1的数据</span></span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSKeyedArchiver</span> archivedDataWithRootObject:person1];</span><br><span class="line"><span class="comment">// 解析data，生成一个新的Person对象</span></span><br><span class="line">Student *person2 = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithData:data];</span><br><span class="line"><span class="comment">// 分别打印内存地址</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"person1:0x%x"</span>, person1); <span class="comment">// person1:0x7177a60</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"person2:0x%x"</span>, person2); <span class="comment">// person2:0x7177cf0</span></span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1879463-69b590233c6a36ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="深复制解析.png"></p><h2 id="SQLite3"><a href="#SQLite3" class="headerlink" title="SQLite3"></a>SQLite3</h2><p>SQLite3是一款开源的嵌入式关系型数据库，可移植性好、易使用、内存开销小<br>SQLite3是无类型的，意味着你可以保存任何类型的数据到任意表的任意字段中。比如下列的创表语句是合法的：</p><p>create table t_person(name, age);<br>为了保证可读性，建议还是把字段类型加上：<br>create table t_person(name text, age integer);</p><p>SQLite3常用的5种数据类型：text、integer、float、boolean、blob</p><p>在iOS中使用SQLite3，首先要添加库文件libsqlite3.dylib和导入主头文件</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;sqlite3.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>创建、打开、关闭数据库</p><p>创建或打开数据库</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// path为：~/Documents/person.db</span></span><br><span class="line">sqlite3 *db;</span><br><span class="line"><span class="keyword">int</span> result = sqlite3_open([path UTF8String], &amp;db);</span><br></pre></td></tr></table></figure><p><strong>代码解析:</strong><br>sqlite3_open()将根据文件路径打开数据库，如果不存在，则会创建一个新的数据库。如果result等于常量SQLITE_OK，则表示成功打开数据库</p><p>sqlite3 *db：一个打开的数据库实例</p><p>数据库文件的路径必须以C字符串(而非NSString)传入</p><p>关闭数据库：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlite3_close(db);</span><br></pre></td></tr></table></figure><p>执行不返回数据的SQL语句</p><p>执行创表语句</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *errorMsg;  <span class="comment">// 用来存储错误信息</span></span><br><span class="line"><span class="keyword">char</span> *sql = <span class="string">"create table if not exists t_person(id integer primary key autoincrement, name text, age integer);"</span>;</span><br><span class="line"><span class="keyword">int</span> result = sqlite3_exec(db, sql, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;errorMsg);</span><br></pre></td></tr></table></figure><p><strong>代码解析：</strong><br>sqlite3_exec()可以执行任何SQL语句，比如创表、更新、插入和删除操作。但是一般不用它执行查询语句，因为它不会返回查询到的数据</p><p>sqlite3_exec()还可以执行的语句：</p><ol><li>开启事务：begin transaction;</li><li>回滚事务：rollback;</li><li>提交事务：commit;</li></ol><p>带占位符插入数据</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *sql = <span class="string">"insert into t_person(name, age) values(?, ?);"</span>;</span><br><span class="line">sqlite3_stmt *stmt;</span><br><span class="line"><span class="keyword">if</span> (sqlite3_prepare_v2(db, sql, <span class="number">-1</span>, &amp;stmt, <span class="literal">NULL</span>) == SQLITE_OK) &#123;</span><br><span class="line">     sqlite3_bind_text(stmt, <span class="number">1</span>, <span class="string">"母鸡"</span>, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">     sqlite3_bind_int(stmt, <span class="number">2</span>, <span class="number">27</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sqlite3_step(stmt) != SQLITE_DONE) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"插入数据错误"</span>);</span><br><span class="line">&#125;</span><br><span class="line">sqlite3_finalize(stmt);</span><br></pre></td></tr></table></figure><p><strong>代码解析：</strong><br>sqlite3_prepare_v2()返回值等于SQLITE_OK，说明SQL语句已经准备成功，没有语法问题</p><p>sqlite3_bind_text()：大部分绑定函数都只有3个参数</p><ol><li>第1个参数是sqlite3_stmt *类型</li><li>第2个参数指占位符的位置，第一个占位符的位置是1，不是0</li><li>第3个参数指占位符要绑定的值</li><li>第4个参数指在第3个参数中所传递数据的长度，对于C字符串，可以传递-1代替字符串的长度</li><li>第5个参数是一个可选的函数回调，一般用于在语句执行后完成内存清理工作</li></ol><p>sqlite_step()：执行SQL语句，返回SQLITE_DONE代表成功执行完毕</p><p>sqlite_finalize()：销毁sqlite3_stmt *对象</p><p>查询数据</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *sql = <span class="string">"select id,name,age from t_person;"</span>;</span><br><span class="line">sqlite3_stmt *stmt;</span><br><span class="line"><span class="keyword">if</span> (sqlite3_prepare_v2(db, sql, <span class="number">-1</span>, &amp;stmt, <span class="literal">NULL</span>) == SQLITE_OK) &#123;</span><br><span class="line">     <span class="keyword">while</span> (sqlite3_step(stmt) == SQLITE_ROW) &#123;</span><br><span class="line">         <span class="keyword">int</span> _<span class="keyword">id</span> = sqlite3_column_int(stmt, <span class="number">0</span>);</span><br><span class="line">         <span class="keyword">char</span> *_name = (<span class="keyword">char</span> *)sqlite3_column_text(stmt, <span class="number">1</span>);</span><br><span class="line">         <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithUTF8String:_name];</span><br><span class="line">         <span class="keyword">int</span> _age = sqlite3_column_int(stmt, <span class="number">2</span>);</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"id=%i, name=%@, age=%i"</span>, _<span class="keyword">id</span>, name, _age);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">sqlite3_finalize(stmt);</span><br></pre></td></tr></table></figure><p><strong>代码解析:</strong></p><p>sqlite3_step()返回SQLITE_ROW代表遍历到一条新记录</p><p>sqlite3<em>column</em>*()用于获取每个字段对应的值，第2个参数是字段的索引，从0开始</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS之文件的压缩和解压缩</title>
      <link href="/2016/04/12/iOS%E4%B9%8B%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9/"/>
      <url>/2016/04/12/iOS%E4%B9%8B%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用ZipArchive来压缩和解压缩文件需要添加依赖库（libz）,使用需要包含Main文件，如果使用cocoaPoads来安装框架，那么会自动的配置框架的使用环境</p></blockquote><a id="more"></a><h2 id="压缩文件的第一种方式"><a href="#压缩文件的第一种方式" class="headerlink" title="压缩文件的第一种方式"></a>压缩文件的第一种方式</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//压缩文件的第一种方式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一个参数：压缩文件要保存的位置</span></span><br><span class="line"><span class="comment">第二个参数：要压缩哪几个文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[Main createZipFileAtPath:fullpath withFilesAtPaths:arrayM];</span><br></pre></td></tr></table></figure><h2 id="压缩文件的第二种方式"><a href="#压缩文件的第二种方式" class="headerlink" title="压缩文件的第二种方式"></a>压缩文件的第二种方式</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//压缩文件的第二种方式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一个参数：文件压缩到哪个地方</span></span><br><span class="line"><span class="comment">第二个参数：要压缩文件的全路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[Main createZipFileAtPath:fullpath withContentsOfDirectory:zipFile];</span><br></pre></td></tr></table></figure><h2 id="如何对压缩文件进行解压"><a href="#如何对压缩文件进行解压" class="headerlink" title="如何对压缩文件进行解压"></a>如何对压缩文件进行解压</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如何对压缩文件进行解压</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一个参数：要解压的文件</span></span><br><span class="line"><span class="comment">第二个参数：要解压到什么地方</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[Main unzipFileAtPath:unZipFile toDestination:fullpath];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发--AFN框架基本使用</title>
      <link href="/2016/04/12/iOS%E5%BC%80%E5%8F%91-AFN%E6%A1%86%E6%9E%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2016/04/12/iOS%E5%BC%80%E5%8F%91-AFN%E6%A1%86%E6%9E%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>AFNetworking is a delightful networking library for iOS, macOS, watchOS, and tvOS. It’s built on top of the <a href="https://developer.apple.com/documentation/foundation/url_loading_system" target="_blank" rel="noopener">Foundation URL Loading System</a>, extending the powerful high-level networking abstractions built into Cocoa. It has a modular architecture with well-designed, feature-rich APIs that are a joy to use.</p></blockquote><a id="more"></a><h2 id="AFN内部结构"><a href="#AFN内部结构" class="headerlink" title="AFN内部结构"></a>AFN内部结构</h2><h3 id="NSURLConnection"><a href="#NSURLConnection" class="headerlink" title="NSURLConnection"></a>NSURLConnection</h3><ul><li>AFURLConnectionOperation </li><li>AFHTTPRequestOperation </li><li>AFHTTPRequestOperationManager(封装了常用的 HTTP 方法) <ul><li>属性 <ul><li>baseURL :AFN建议开发者针对 AFHTTPRequestOperationManager 自定义个一个单例子类，设置 baseURL, 所有的网络访问，都只使用相对路径即可 </li><li>requestSerializer :请求数据格式/默认是二进制的 HTTP </li><li>responseSerializer :响应的数据格式/默认是 JSON 格式 </li><li>operationQueue </li><li>reachabilityManager :网络连接管理器 </li></ul></li><li>方法 <ul><li>manager :方便创建管理器的类方法 </li><li>HTTPRequestOperationWithRequest :在访问服务器时，如果要告诉服务器一些附加信息，都需要在 Request 中设置 </li><li>GET </li><li>POST </li></ul></li></ul></li></ul><h3 id="NSURLSession"><a href="#NSURLSession" class="headerlink" title="NSURLSession"></a>NSURLSession</h3><p>AFURLSessionManager<br>AFHTTPSessionManager(封装了常用的 HTTP 方法) </p><ul><li>GET </li><li>POST </li><li>UIKit + AFNetworking 分类 </li><li>NSProgress :利用KVO </li></ul><p>半自动的序列化&amp;反序列化的功能 </p><ul><li>AFURLRequestSerialization :请求的数据格式/默认是二进制的 </li><li>AFURLResponseSerialization :响应的数据格式/默认是JSON格式 </li></ul><p>附加功能 </p><p>安全策略 </p><ul><li>HTTPS </li><li>AFSecurityPolicy </li></ul><ul><li>网络检测 </li></ul><ul><li>对苹果的网络连接检测做了一个封装 </li><li>AFNetworkReachabilityManager</li></ul><h2 id="AFN的基本使用"><a href="#AFN的基本使用" class="headerlink" title="AFN的基本使用"></a>AFN的基本使用</h2><h3 id="发送GET请求的两种方式（POST同）"><a href="#发送GET请求的两种方式（POST同）" class="headerlink" title="发送GET请求的两种方式（POST同）"></a>发送GET请求的两种方式（POST同）</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)get1&#123; </span><br><span class="line">    <span class="comment">//1.创建AFHTTPRequestOperationManager管理者 </span></span><br><span class="line">    <span class="comment">//AFHTTPRequestOperationManager内部是基于NSURLConnection实现的 </span></span><br><span class="line">    AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager]; </span><br><span class="line">    <span class="comment">//2.发送请求 </span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    http://120.25.226.186:32812/login?username=ee&amp;pwd=ee&amp;type=JSON </span></span><br><span class="line"><span class="comment">    第一个参数：NSString类型的请求路径，AFN内部会自动将该路径包装为一个url并创建请求对象 </span></span><br><span class="line"><span class="comment">    第二个参数：请求参数，以字典的方式传递，AFN内部会判断当前是POST请求还是GET请求，以选择直接拼接还是转换为NSData放到请求体中传递 </span></span><br><span class="line"><span class="comment">    第三个参数：请求成功之后回调Block </span></span><br><span class="line"><span class="comment">    第四个参数：请求失败回调Block </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="built_in">NSDictionary</span> *param = @&#123; <span class="string">@"username"</span>:<span class="string">@"520it"</span>, </span><br><span class="line">                                <span class="string">@"pwd"</span>:<span class="string">@"520it"</span> </span><br><span class="line">                              &#125;; </span><br><span class="line">    <span class="comment">//注意：字符串中不能包含空格 </span></span><br><span class="line">    [manager GET:<span class="string">@"url字符串"</span> parameters:param success:^(AFHTTPRequestOperation * _Nonnull operation, <span class="keyword">id</span> _Nonnull responseObject) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"请求成功---%@"</span>,responseObject); </span><br><span class="line">    &#125; failure:^(AFHTTPRequestOperation * _Nonnull operation, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"失败---%@"</span>,error); </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)get2&#123; </span><br><span class="line">    <span class="comment">//1.创建AFHTTPSessionManager管理者 </span></span><br><span class="line">    <span class="comment">//AFHTTPSessionManager内部是基于NSURLSession实现的 </span></span><br><span class="line">    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; </span><br><span class="line">    <span class="comment">//2.发送请求 </span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *param = @&#123; <span class="string">@"username"</span>:<span class="string">@"520it"</span>,</span><br><span class="line">                                <span class="string">@"pwd"</span>:<span class="string">@"520it"</span> </span><br><span class="line">                              &#125;; </span><br><span class="line">    <span class="comment">//注意：responseObject:请求成功返回的响应结果（AFN内部已经把响应体转换为OC对象，通常是字典或数组） </span></span><br><span class="line">    [manager GET:<span class="string">@"url字符串"</span> parameters:param success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span> _Nonnull responseObject) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"请求成功---%@"</span>,[responseObject <span class="keyword">class</span>]); </span><br><span class="line">    &#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"失败---%@"</span>,error);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用AFN下载文件"><a href="#使用AFN下载文件" class="headerlink" title="使用AFN下载文件"></a>使用AFN下载文件</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)download&#123; </span><br><span class="line">    <span class="comment">//1.创建一个管理者 </span></span><br><span class="line">    AFHTTPSessionManager *manage = [AFHTTPSessionManager manager]; </span><br><span class="line">    <span class="comment">//2.下载文件 </span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    第一个参数：请求对象 </span></span><br><span class="line"><span class="comment">    第二个参数：下载进度 </span></span><br><span class="line"><span class="comment">    第三个参数：block回调，需要返回一个url地址，用来告诉AFN下载文件的目标地址 </span></span><br><span class="line"><span class="comment">    targetPath：AFN内部下载文件存储的地址，tmp文件夹下 </span></span><br><span class="line"><span class="comment">    response：请求的响应头 </span></span><br><span class="line"><span class="comment">    返回值：文件应该剪切到什么地方 </span></span><br><span class="line"><span class="comment">    第四个参数：block回调，当文件下载完成之后调用 </span></span><br><span class="line"><span class="comment">    response：响应头 </span></span><br><span class="line"><span class="comment">    filePath：文件存储在沙盒的地址 == 第三个参数中block的返回值 </span></span><br><span class="line"><span class="comment">    error：错误信息 </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="comment">//2.1 创建请求对象 </span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"url字符串"</span>]];</span><br><span class="line">    <span class="comment">//2.2 创建下载进度，并监听 </span></span><br><span class="line">    <span class="built_in">NSProgress</span> *progress = <span class="literal">nil</span>; </span><br><span class="line">    <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = [manage downloadTaskWithRequest:request progress:&amp;progress destination:^<span class="built_in">NSURL</span> * _Nonnull(<span class="built_in">NSURL</span> * _Nonnull targetPath, <span class="built_in">NSURLResponse</span> * _Nonnull response) &#123; </span><br><span class="line">        <span class="built_in">NSString</span> *caches = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject]; </span><br><span class="line">        <span class="comment">//拼接文件全路径 </span></span><br><span class="line">        <span class="built_in">NSString</span> *fullpath = [caches stringByAppendingPathComponent:response.suggestedFilename]; </span><br><span class="line">        <span class="built_in">NSURL</span> *filePathUrl = [<span class="built_in">NSURL</span> fileURLWithPath:fullpath]; </span><br><span class="line">        <span class="keyword">return</span> filePathUrl; </span><br><span class="line">    &#125; completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="built_in">NSURL</span> * _Nonnull filePath, <span class="built_in">NSError</span> * _Nonnull error) &#123; </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"文件下载完毕---%@"</span>,filePath); </span><br><span class="line">    &#125;]; </span><br><span class="line">    <span class="comment">//2.3 使用KVO监听下载进度 </span></span><br><span class="line">    [progress addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"completedUnitCount"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>]; </span><br><span class="line">    <span class="comment">//3.启动任务 [downloadTask resume];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取并计算当前文件的下载进度</span></span><br><span class="line">-(<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="built_in">NSProgress</span> *)progress change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context&#123; </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%zd--%zd--%f"</span>,progress.completedUnitCount,progress.totalUnitCount,<span class="number">1.0</span> * progress.completedUnitCount/progress.totalUnitCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS网络编程--文件上传</title>
      <link href="/2016/04/12/iOS%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2016/04/12/iOS%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>NSURLConnection实现文件上传</p></blockquote><a id="more"></a><ol><li><p>文件上传步骤<br><code>1.</code>确定请求路径<br><code>2.</code>根据URL创建一个可变的请求对象<br><code>3.</code>设置请求对象，修改请求方式为POST<br><code>4.</code>设置请求头，告诉服务器我们将要上传文件（Content-Type）<br><code>5.</code>设置请求体（在请求体中按照既定的格式拼接要上传的文件参数和非文件参数等数据）</p><ul><li>拼接文件参数</li><li>拼接非文件参数</li><li>添加结尾标记</li></ul><p><code>6.</code>使用NSURLConnection sendAsync发送异步请求上传文件<br><code>7.</code>解析服务器返回的数据</p></li><li><p>文件上传设置请求体的数据格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//请求体拼接格式 </span><br><span class="line">//分隔符：----WebKitFormBoundaryhBDKBUWBHnAgvz9c </span><br><span class="line">//01.文件参数拼接格式 </span><br><span class="line">--分隔符 </span><br><span class="line">Content-Disposition:参数 </span><br><span class="line">Content-Type:参数 </span><br><span class="line">空行 </span><br><span class="line">文件参数 </span><br><span class="line">//02.非文件拼接参数 </span><br><span class="line">--分隔符 </span><br><span class="line">Content-Disposition:参数 </span><br><span class="line">空行 </span><br><span class="line">非文件的二进制数据 </span><br><span class="line">//03.结尾标识 </span><br><span class="line">--分隔符--</span><br></pre></td></tr></table></figure></li><li><p>文件上传相关代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">-(void)upload &#123; </span><br><span class="line">//1.确定请求路径 </span><br><span class="line">NSURL *url = [NSURL URLWithString:@&quot;URL字符串&quot;]; </span><br><span class="line">//2.创建一个可变的请求对象 </span><br><span class="line">NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; </span><br><span class="line">//3.设置请求方式为POST </span><br><span class="line">request.HTTPMethod = @&quot;POST&quot;; </span><br><span class="line">//4.设置请求头 </span><br><span class="line">NSString *filed = [NSString stringWithFormat:@&quot;multipart/form-data; boundary=%@&quot;,Kboundary]; </span><br><span class="line">[request setValue:filed forHTTPHeaderField:@&quot;Content-Type&quot;]; </span><br><span class="line">//5.设置请求体 </span><br><span class="line">NSMutableData *data = [NSMutableData data]; </span><br><span class="line">//5.1 文件参数 </span><br><span class="line">/*</span><br><span class="line"> --分隔符 </span><br><span class="line">Content-Disposition:参数 </span><br><span class="line">Content-Type:参数 </span><br><span class="line">空行 </span><br><span class="line">文件参数 </span><br><span class="line">*/ </span><br><span class="line">[data appendData:[[NSString stringWithFormat:@&quot;--%@&quot;,Kboundary] dataUsingEncoding:NSUTF8StringEncoding]]; </span><br><span class="line">[data appendData:KnewLine]; </span><br><span class="line">[data appendData:[@&quot;Content-Disposition: form-data; name=\&quot;file\&quot;; filename=\&quot;test.png\&quot;&quot; dataUsingEncoding:NSUTF8StringEncoding]];</span><br><span class="line">[data appendData:KnewLine]; </span><br><span class="line">[data appendData:[@&quot;Content-Type: image/png&quot; dataUsingEncoding:NSUTF8StringEncoding]];</span><br><span class="line">[data appendData:KnewLine]; </span><br><span class="line">[data appendData:KnewLine]; </span><br><span class="line">[data appendData:KnewLine]; </span><br><span class="line">UIImage *image = [UIImage imageNamed:@&quot;test&quot;]; </span><br><span class="line">NSData *imageData = UIImagePNGRepresentation(image); </span><br><span class="line">[data appendData:imageData]; </span><br><span class="line">[data appendData:KnewLine]; </span><br><span class="line">//5.2 非文件参数 </span><br><span class="line">/* </span><br><span class="line">--分隔符 </span><br><span class="line">Content-Disposition:参数 </span><br><span class="line">空行 </span><br><span class="line">非文件参数的二进制数据 </span><br><span class="line">*/ </span><br><span class="line">[data appendData:[[NSString stringWithFormat:@&quot;--%@&quot;,Kboundary] dataUsingEncoding:NSUTF8StringEncoding]]; </span><br><span class="line">[data appendData:KnewLine]; </span><br><span class="line">[data appendData:[@&quot;Content-Disposition: form-data;name=\&quot;username\&quot;&quot; dataUsingEncoding:NSUTF8StringEncoding]];</span><br><span class="line">[data appendData:KnewLine]; </span><br><span class="line">[data appendData:KnewLine];</span><br><span class="line"> [data appendData:KnewLine]; </span><br><span class="line">NSData *nameData = [@&quot;wendingding&quot; dataUsingEncoding:NSUTF8StringEncoding]; </span><br><span class="line">[data appendData:nameData]; </span><br><span class="line">[data appendData:KnewLine];</span><br><span class="line">//5.3 结尾标识 </span><br><span class="line">//--分隔符-- </span><br><span class="line">[data appendData:[[NSString stringWithFormat:@&quot;--%@--&quot;,Kboundary] dataUsingEncoding:NSUTF8StringEncoding]]; </span><br><span class="line">[data appendData:KnewLine]; </span><br><span class="line">request.HTTPBody = data; </span><br><span class="line">//6.发送请求 </span><br><span class="line">[NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * __nullable response, NSData * __nullable data, NSError * __nullable connectionError) &#123; </span><br><span class="line">//7.解析服务器返回的数据 </span><br><span class="line">NSLog(@&quot;%@&quot;,[NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil]);</span><br><span class="line"> &#125;];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>如何获得文件的MIMEType类型</p><ol><li><p>直接对该对象发送一个异步网络请求，在响应头中通过response.MIMEType拿到文件的MIMEType类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//如果想要及时拿到该数据，那么可以发送一个同步请求</span><br><span class="line">-(NSString *)getMIMEType&#123; </span><br><span class="line">NSString *filePath = @&quot;文件所在路径&quot;;</span><br><span class="line">NSURLResponse *response = nil; </span><br><span class="line">[NSURLConnection sendSynchronousRequest:[NSURLRequest requestWithURL:[NSURL fileURLWithPath:filePath]] returningResponse:&amp;response error:nil]; </span><br><span class="line">return response.MIMEType;</span><br><span class="line">&#125;</span><br><span class="line">//对该文件发送一个异步请求，拿到文件的MIMEType</span><br><span class="line">-(void)MIMEType&#123; </span><br><span class="line">// NSString *file = @&quot;文件所在路径&quot;; </span><br><span class="line">[NSURLConnection sendAsynchronousRequest:[NSURLRequest requestWithURL:[NSURL fileURLWithPath:@&quot;/Users/文顶顶/Desktop/test.png&quot;]] queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * __nullable response, NSData * __nullable data, NSError * __nullable connectionError) &#123; </span><br><span class="line">// response.MIMEType </span><br><span class="line">NSLog(@&quot;%@&quot;,response.MIMEType);</span><br><span class="line"> &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过UTTypeCopyPreferredTagWithClass方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//注意：需要依赖于框架MobileCoreServices</span><br><span class="line">-(NSString *)mimeTypeForFileAtPath:(NSString *)path&#123;</span><br><span class="line">    if (![[[NSFileManager alloc] init] fileExistsAtPath:path]) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;   </span><br><span class="line">CFStringRef UTI = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, (__bridge CFStringRef)[path pathExtension], NULL);    CFStringRef MIMEType = UTTypeCopyPreferredTagWithClass (UTI, kUTTagClassMIMEType);</span><br><span class="line">    CFRelease(UTI);</span><br><span class="line">    if (!MIMEType) &#123;</span><br><span class="line">        return @&quot;application/octet-stream&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return (__bridge NSString *)(MIMEType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><hr><blockquote><p>NSURLSession实现文件上传</p></blockquote><ol><li><p>实现文件上传的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  /*</span><br><span class="line">第一个参数：请求对象</span><br><span class="line">第二个参数：请求体（要上传的文件数据）</span><br><span class="line">block回调：</span><br><span class="line">NSData:响应体</span><br><span class="line">NSURLResponse：响应头</span><br><span class="line">NSError：请求的错误信息</span><br><span class="line">*/</span><br><span class="line">NSURLSessionUploadTask *uploadTask =  [session uploadTaskWithRequest:request fromData:data completionHandler:^(NSData * __nullable data, NSURLResponse * __nullable response, NSError * __nullable error)</span><br></pre></td></tr></table></figure></li><li><p>设置代理，在代理方法中监听文件上传进度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">调用该方法上传文件数据</span><br><span class="line">如果文件数据很大，那么该方法会被调用多次</span><br><span class="line">参数说明：</span><br><span class="line">    totalBytesSent：已经上传的文件数据的大小</span><br><span class="line">    totalBytesExpectedToSend：文件的总大小</span><br><span class="line">*/</span><br><span class="line">-(void)URLSession:(nonnull NSURLSession *)session task:(nonnull NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%.2f&quot;,1.0 * totalBytesSent/totalBytesExpectedToSend);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关于NSURLSessionConfiguration相关</p><ul><li>作用：可以统一配置NSURLSession,如请求超时等</li><li>创建的方式和使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//创建配置的三种方式</span><br><span class="line">+(NSURLSessionConfiguration *)defaultSessionConfiguration;</span><br><span class="line">+(NSURLSessionConfiguration *)ephemeralSessionConfiguration;</span><br><span class="line">+(NSURLSessionConfiguration *)backgroundSessionConfigurationWithIdentifier:(NSString *)identifier NS_AVAILABLE(10_10, 8_0);</span><br><span class="line">//统一配置NSURLSession</span><br><span class="line">-(NSURLSession *)session</span><br><span class="line">&#123;</span><br><span class="line">    if (_session == nil) &#123;</span><br><span class="line">        //创建NSURLSessionConfiguration</span><br><span class="line">        NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">        //设置请求超时为10秒钟</span><br><span class="line">        config.timeoutIntervalForRequest = 10;</span><br><span class="line">        //在蜂窝网络情况下是否继续请求（上传或下载）</span><br><span class="line">        config.allowsCellularAccess = NO;</span><br><span class="line">        _session = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:[NSOperationQueue mainQueue]];</span><br><span class="line">    &#125;</span><br><span class="line">    return _session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS网络编程--文件下载</title>
      <link href="/2016/04/12/iOS%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"/>
      <url>/2016/04/12/iOS%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用NSURLConnection实现下载</p></blockquote><a id="more"></a><h3 id="1-小文件下载"><a href="#1-小文件下载" class="headerlink" title="1. 小文件下载"></a>1. 小文件下载</h3><ol><li><p>第一种方式（NSData）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//使用NSDta直接加载网络上的url资源（不考虑线程） </span><br><span class="line">-(void)dataDownload &#123; </span><br><span class="line">//1.确定资源路径 </span><br><span class="line">NSURL *url = [NSURL URLWithString:@&quot;http://tupian.qqjay.com/u/2013/1127/19_222949_14.jpg&quot;]; </span><br><span class="line">//2.根据URL加载对应的资源 </span><br><span class="line">NSData *data = [NSData dataWithContentsOfURL:url]; </span><br><span class="line">//3.转换并显示数据 </span><br><span class="line">UIImage *image = [UIImage imageWithData:data]; </span><br><span class="line">self.imageView.image = image; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二种方式（NSURLConnection-sendAsync）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//使用NSURLConnection发送异步请求下载文件资源 </span><br><span class="line">-(void)connectDownload &#123; </span><br><span class="line">//1.确定请求路径 </span><br><span class="line">NSURL *url = [NSURL URLWithString:@&quot;http://tupian.qqjay.com/u/2013/1127/19_222949_14.jpg&quot;]; </span><br><span class="line">//2.创建请求对象 </span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url]; </span><br><span class="line">//3.使用NSURLConnection发送一个异步请求 </span><br><span class="line">[NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) &#123; </span><br><span class="line">//4.拿到并处理数据 </span><br><span class="line">UIImage *image = [UIImage imageWithData:data]; </span><br><span class="line">self.imageView.image = image; </span><br><span class="line">&#125;]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第三种方式（NSURLConnection-delegate）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//使用NSURLConnection设置代理发送异步请求的方式下载文件 </span><br><span class="line">-(void)connectionDelegateDownload &#123; </span><br><span class="line">//1.确定请求路径 </span><br><span class="line">NSURL *url = [NSURL URLWithString:@&quot;下载文件的URL地址&quot;]; </span><br><span class="line">//2.创建请求对象 </span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url]; </span><br><span class="line">//3.使用NSURLConnection设置代理并发送异步请求 </span><br><span class="line">[NSURLConnection connectionWithRequest:request delegate:self]; </span><br><span class="line">&#125;</span><br><span class="line">pragma mark--NSURLConnectionDataDelegate</span><br><span class="line">//当接收到服务器响应的时候调用，该方法只会调用一次</span><br><span class="line">-(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response</span><br><span class="line">&#123;</span><br><span class="line">    //创建一个容器，用来接收服务器返回的数据</span><br><span class="line">    self.fileData = [NSMutableData data];</span><br><span class="line">    //获得当前要下载文件的总大小（通过响应头得到）</span><br><span class="line">    NSHTTPURLResponse *res = (NSHTTPURLResponse *)response;</span><br><span class="line">    self.totalLength = res.expectedContentLength;</span><br><span class="line">    NSLog(@&quot;%zd&quot;,self.totalLength);</span><br><span class="line">    //拿到服务器端推荐的文件名称</span><br><span class="line">    self.fileName = res.suggestedFilename;</span><br><span class="line">&#125;</span><br><span class="line">//当接收到服务器返回的数据时会调用</span><br><span class="line">//该方法可能会被调用多次</span><br><span class="line">-(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data</span><br><span class="line">&#123;</span><br><span class="line">//    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    //拼接每次下载的数据</span><br><span class="line">    [self.fileData appendData:data];</span><br><span class="line">    //计算当前下载进度并刷新UI显示</span><br><span class="line">    self.currentLength = self.fileData.length;</span><br><span class="line">    NSLog(@&quot;%f&quot;,1.0* self.currentLength/self.totalLength);</span><br><span class="line">    self.progressView.progress = 1.0* self.currentLength/self.totalLength;</span><br><span class="line">&#125;</span><br><span class="line">//当网络请求结束之后调用</span><br><span class="line">-(void)connectionDidFinishLoading:(NSURLConnection *)connection</span><br><span class="line">&#123;</span><br><span class="line">    //文件下载完毕把接受到的文件数据写入到沙盒中保存</span><br><span class="line">    //1.确定要保存文件的全路径</span><br><span class="line">    //caches文件夹路径</span><br><span class="line">    NSString *caches = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">    NSString *fullPath = [caches stringByAppendingPathComponent:self.fileName];</span><br><span class="line">    //2.写数据到文件中</span><br><span class="line">    [self.fileData writeToFile:fullPath atomically:YES];</span><br><span class="line">    NSLog(@&quot;%@&quot;,fullPath);</span><br><span class="line">&#125;</span><br><span class="line">//当请求失败的时候调用该方法</span><br><span class="line">-(void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-大文件下载"><a href="#2-大文件下载" class="headerlink" title="2. 大文件下载"></a>2. 大文件下载</h3><ol><li>实现思路<br>边接收数据边写文件以解决内存越来越大的问题</li><li>核心代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//当接收到服务器响应的时候调用，该方法只会调用一次 </span><br><span class="line">-(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response &#123; </span><br><span class="line">//0.获得当前要下载文件的总大小（通过响应头得到） </span><br><span class="line">NSHTTPURLResponse *res = (NSHTTPURLResponse *)response; </span><br><span class="line">self.totalLength = res.expectedContentLength; </span><br><span class="line">NSLog(@&quot;%zd&quot;,self.totalLength); </span><br><span class="line">//创建一个新的文件，用来当接收到服务器返回数据的时候往该文件中写入数据 //1.获取文件管理者 </span><br><span class="line">NSFileManager *manager = [NSFileManager defaultManager]; </span><br><span class="line">//2.拼接文件的全路径 </span><br><span class="line">//caches文件夹路径 </span><br><span class="line">NSString *caches = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]; </span><br><span class="line">NSString *fullPath = [caches stringByAppendingPathComponent:res.suggestedFilename]; </span><br><span class="line">self.fullPath = fullPath; </span><br><span class="line">//3.创建一个空的文件 </span><br><span class="line">[manager createFileAtPath:fullPath contents:nil attributes:nil]; </span><br><span class="line">&#125; </span><br><span class="line">//当接收到服务器返回的数据时会调用 </span><br><span class="line">//该方法可能会被调用多次 </span><br><span class="line">-(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123; </span><br><span class="line">//1.创建一个用来向文件中写数据的文件句柄 </span><br><span class="line">//注意当下载完成之后，该文件句柄需要关闭，调用closeFile方法 </span><br><span class="line">NSFileHandle *handle = [NSFileHandle fileHandleForWritingAtPath:self.fullPath]; </span><br><span class="line">//2.设置写数据的位置(追加) </span><br><span class="line">[handle seekToEndOfFile]; </span><br><span class="line">//3.写数据 [handle writeData:data]; </span><br><span class="line">//4.计算当前文件的下载进度 </span><br><span class="line">self.currentLength += data.length; </span><br><span class="line">NSLog(@&quot;%f&quot;,1.0* self.currentLength/self.totalLength); </span><br><span class="line">self.progressView.progress = 1.0* self.currentLength/self.totalLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-大文件断点续传"><a href="#3-大文件断点续传" class="headerlink" title="3. 大文件断点续传"></a>3. 大文件断点续传</h3><ol><li>实现思路<br>在下载文件的时候不再是整块的从头开始下载，而是看当前文件已经下载到哪个地方，然后从该地方接着往后面下载。可以通过在请求对象中设置请求头实现。</li><li><p>解决方案（设置请求头）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//2.创建请求对象 </span><br><span class="line">NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; </span><br><span class="line">//2.1 设置下载文件的某一部分 </span><br><span class="line">// 只要设置HTTP请求头的Range属性, 就可以实现从指定位置开始下载 </span><br><span class="line">/* </span><br><span class="line">表示头500个字节：Range: bytes=0-499 </span><br><span class="line">表示第二个500字节：Range: bytes=500-999 </span><br><span class="line">表示最后500个字节：Range: bytes=-500 </span><br><span class="line">表示500字节以后的范围：Range: bytes=500- </span><br><span class="line">*/ </span><br><span class="line">NSString *range = [NSString stringWithFormat:@&quot;bytes=%zd-&quot;,self.currentLength]; </span><br><span class="line">[request setValue:range forHTTPHeaderField:@&quot;Range&quot;];</span><br></pre></td></tr></table></figure></li><li><p>注意点（下载进度并判断是否需要重新创建文件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//获得当前要下载文件的总大小（通过响应头得到） </span><br><span class="line">NSHTTPURLResponse *res = (NSHTTPURLResponse *)response; </span><br><span class="line">//注意点：res.expectedContentLength获得是本次请求要下载的文件的大小（并非是完整的文件的大小） </span><br><span class="line">//因此：文件的总大小 == 本次要下载的文件大小+已经下载的文件的大小 </span><br><span class="line">self.totalLength = res.expectedContentLength + self.currentLength; </span><br><span class="line">NSLog(@&quot;----------------------------%zd&quot;,self.totalLength); </span><br><span class="line">//0 判断当前是否已经下载过，如果当前文件已经存在，那么直接返回</span><br><span class="line"> if (self.currentLength &gt;0) &#123; return; &#125;</span><br></pre></td></tr></table></figure></li><li><p>输出流</p><ol><li><p>使用输出流也可以实现和NSFileHandle相同的功能</p></li><li><p>如何使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//1.创建一个数据输出流</span><br><span class="line">/*</span><br><span class="line">第一个参数：二进制的流数据要写入到哪里</span><br><span class="line">第二个参数：采用什么样的方式写入流数据，如果YES则表示追加，如果是NO则表示覆盖</span><br><span class="line">*/</span><br><span class="line">NSOutputStream *stream = [NSOutputStream outputStreamToFileAtPath:fullPath append:YES];</span><br><span class="line">//只要调用了该方法就会往文件中写数据</span><br><span class="line">//如果文件不存在，那么会自动的创建一个</span><br><span class="line">[stream open];</span><br><span class="line">self.stream = stream;</span><br><span class="line">//2.当接收到数据的时候写数据</span><br><span class="line">//使用输出流写数据</span><br><span class="line">/*</span><br><span class="line">第一个参数：要写入的二进制数据</span><br><span class="line">第二个参数：要写入的数据的大小</span><br><span class="line">*/</span><br><span class="line">[self.stream write:data.bytes maxLength:data.length];</span><br><span class="line">//3.当文件下载完毕的时候关闭输出流</span><br><span class="line">//关闭输出流</span><br><span class="line">[self.stream close];</span><br><span class="line">self.stream = nil;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>使用多线程下载文件的思路</p><ul><li>01 开启多条线程，每条线程都只下载文件的一部分（通过设置请求头中的Range来实现）</li><li>02 创建一个和需要下载文件大小一致的文件，判断当前是那个线程，根据当前的线程来判断下载的数据应该写入到文件中的哪个位置。（假设开5条线程来下载10M的文件，那么线程1下载0-2M，线程2下载2-4M一次类推，当接收到服务器返回的数据之后应该先判断当前线程是哪个线程，假如当前线程是线程2，那么在写数据的时候就从文件的2M位置开始写入）</li><li>03 代码相关：使用NSFileHandle这个类的seekToFileOfSet方法，来向文件中特定的位置写入数据。</li><li>04 技术相关<br>a.每个线程通过设置请求头下载文件中的某一个部分<br>b.通过NSFileHandle向文件中的指定位置写数据</li></ul></li></ol><hr><blockquote><p>使用NSURLSession实现下载</p></blockquote><h3 id="1-NSURLSession下载文件-代理"><a href="#1-NSURLSession下载文件-代理" class="headerlink" title="1. NSURLSession下载文件-代理"></a>1. NSURLSession下载文件-代理</h3><ol><li><p>创建NSURLSession对象，设置代理（默认配置）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//1.创建NSURLSession,并设置代理 </span><br><span class="line">/* </span><br><span class="line">第一个参数：session对象的全局配置设置，一般使用默认配置就可以 </span><br><span class="line">第二个参数：谁成为session对象的代理 </span><br><span class="line">第三个参数：代理方法在哪个队列中执行（在哪个线程中调用）,如果是主队列那么在主线程中执行，如果是非主队列，那么在子线程中执行 </span><br><span class="line">*/ </span><br><span class="line">NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];</span><br></pre></td></tr></table></figure></li><li><p>根据Session对象创建一个NSURLSessionDataTask任务（post和get选择）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//创建task</span><br><span class="line">NSURL *url = [NSURL URLWithString:@&quot;http://tupian.qqjay.com/u/2013/1127/19_222949_14.jpg&quot;];</span><br><span class="line">//注意：如果要发送POST请求，那么请使用dataTaskWithRequest,设置一些请求头信息</span><br><span class="line">NSURLSessionDataTask *dataTask = [session dataTaskWithURL:url];</span><br></pre></td></tr></table></figure></li><li><p>执行任务（其它方法，如暂停、取消等）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//启动task</span><br><span class="line">//[dataTask resume];</span><br><span class="line">//其它方法，如取消任务，暂停任务等</span><br><span class="line">//[dataTask cancel];</span><br><span class="line">//[dataTask suspend];</span><br></pre></td></tr></table></figure></li><li><p>遵守代理协议，实现代理方法（3个相关的代理方法）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">1.当接收到服务器响应的时候调用 </span><br><span class="line">session：发送请求的session对象 </span><br><span class="line">dataTask：根据NSURLSession创建的task任务 </span><br><span class="line">response:服务器响应信息（响应头） </span><br><span class="line">completionHandler：通过该block回调，告诉服务器端是否接收返回的数据 </span><br><span class="line">*/</span><br><span class="line">-(void)URLSession:(nonnull NSURLSession *)session dataTask:(nonnull NSURLSessionDataTask *)dataTask didReceiveResponse:(nonnull NSURLResponse *)response completionHandler:(nonnull void (^)(NSURLSessionResponseDisposition))completionHandler</span><br><span class="line">/*</span><br><span class="line">2.当接收到服务器返回的数据时调用 该方法可能会被调用多次 </span><br><span class="line">*/</span><br><span class="line">-(void)URLSession:(nonnull NSURLSession *)session dataTask:(nonnull NSURLSessionDataTask *)dataTask didReceiveData:(nonnull NSData *)data</span><br><span class="line">/* </span><br><span class="line">3.当请求完成之后调用该方法 不论是请求成功还是请求失败都调用该方法，如果请求失败，那么error对象有值，否则那么error对象为空 </span><br><span class="line">*/</span><br><span class="line">-(void)URLSession:(nonnull NSURLSession *)session task:(nonnull NSURLSessionTask *)task didCompleteWithError:(nullable NSError *)error</span><br></pre></td></tr></table></figure></li><li><p>当接收到服务器响应的时候，告诉服务器接收数据（调用block）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//默认情况下，当接收到服务器响应之后，服务器认为客户端不需要接收数据，所以后面的代理方法不会调用 </span><br><span class="line">//如果需要继续接收服务器返回的数据，那么需要调用block,并传入对应的策略 </span><br><span class="line">/* </span><br><span class="line">NSURLSessionResponseCancel = 0, 取消任务 </span><br><span class="line">NSURLSessionResponseAllow = 1, 接收任务 </span><br><span class="line">NSURLSessionResponseBecomeDownload = 2, 转变成下载 </span><br><span class="line">NSURLSessionResponseBecomeStream NS_ENUM_AVAILABLE(10_11, 9_0) = 3, 转变成流 </span><br><span class="line">*/ </span><br><span class="line">completionHandler(NSURLSessionResponseAllow);</span><br></pre></td></tr></table></figure></li></ol><p>###2. NSURLSessionDownloadTask实现大文件下载</p><ol><li><p>使用NSURLSession和NSURLSessionDownload可以很方便的实现文件下载操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    第一个参数：要下载文件的url路径</span><br><span class="line">    第二个参数：当接收完服务器返回的数据之后调用该block</span><br><span class="line">    location:下载的文件的保存地址（默认是存储在沙盒中tmp文件夹下面，随时会被删除）</span><br><span class="line">    response：服务器响应信息，响应头</span><br><span class="line">    error：该请求的错误信息</span><br><span class="line">    */</span><br><span class="line">    //说明：downloadTaskWithURL方法已经实现了在下载文件数据的过程中边下载文件数据，边写入到沙盒文件的操作</span><br><span class="line">    NSURLSessionDownloadTask *downloadTask = [session downloadTaskWithURL:url completionHandler:^(NSURL * __nullable location, NSURLResponse * __nullable response, NSError * __nullable error)</span><br></pre></td></tr></table></figure></li><li><p>downloadTaskWithURL内部默认已经实现了变下载边写入操作，所以不用开发人员担心内存问题</p></li><li>文件下载后默认保存在tmp文件目录，需要开发人员手动的剪切到合适的沙盒目录</li><li>缺点：没有办法监控下载进度</li></ol><p>###3. 使用NSURLSessionDownloadTask实现大文件下载-监听下载进度</p><ol><li><p>创建NSURLSession并设置代理，通过NSURLSessionDownloadTask并以代理的方式来完成大文件的下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//1.创建NSULRSession,设置代理</span><br><span class="line">self.session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];</span><br><span class="line">//2.创建task</span><br><span class="line">NSURL *url = [NSURL URLWithString:@&quot;URL字符串&quot;];</span><br><span class="line">self.downloadTask = [self.session downloadTaskWithURL:url];</span><br><span class="line">//3.执行task</span><br><span class="line">[self.downloadTask resume];</span><br></pre></td></tr></table></figure></li><li><p>常用代理方法的说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">1.当接收到下载数据的时候调用,可以在该方法中监听文件下载的进度 </span><br><span class="line">该方法会被调用多次 </span><br><span class="line">totalBytesWritten:已经写入到文件中的数据大小 </span><br><span class="line">totalBytesExpectedToWrite:目前文件的总大小 </span><br><span class="line">bytesWritten:本次下载的文件数据大小 </span><br><span class="line">*/</span><br><span class="line">-(void)URLSession:(nonnull NSURLSession *)session downloadTask:(nonnull NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</span><br><span class="line">/* </span><br><span class="line">2.恢复下载的时候调用该方法 </span><br><span class="line">fileOffset:恢复之后，要从文件的什么地方开发下载 </span><br><span class="line">expectedTotalBytes：该文件数据的总大小 </span><br><span class="line">*/</span><br><span class="line">-(void)URLSession:(nonnull NSURLSession *)session downloadTask:(nonnull NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes</span><br><span class="line">/* </span><br><span class="line">3.下载完成之后调用该方法 </span><br><span class="line">*/</span><br><span class="line">-(void)URLSession:(nonnull NSURLSession *)session downloadTask:(nonnull NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(nonnull NSURL *)location</span><br><span class="line">/* </span><br><span class="line">4.请求完成之后调用 </span><br><span class="line">如果请求失败，那么error有值 </span><br><span class="line">*/</span><br><span class="line">-(void)URLSession:(nonnull NSURLSession *)session task:(nonnull NSURLSessionTask *)task didCompleteWithError:(nullable NSError *)error</span><br></pre></td></tr></table></figure></li><li><p>实现断点下载相关代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//如果任务，取消了那么以后就不能恢复了</span><br><span class="line">// [self.downloadTask cancel];</span><br><span class="line">//如果采取这种方式来取消任务，那么该方法会通过resumeData保存当前文件的下载信息</span><br><span class="line">//只要有了这份信息，以后就可以通过这些信息来恢复下载</span><br><span class="line">[self.downloadTask cancelByProducingResumeData:^(NSData * __nullable resumeData) &#123; self.resumeData = resumeData;&#125;];</span><br><span class="line">//继续下载</span><br><span class="line">//首先通过之前保存的resumeData信息，创建一个下载任务</span><br><span class="line">self.downloadTask = [self.session downloadTaskWithResumeData:self.resumeData]; </span><br><span class="line">[self.downloadTask resume];</span><br></pre></td></tr></table></figure></li><li><p>计算当前下载进度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//获取文件下载进度</span><br><span class="line">self.progress.progress = 1.0 * totalBytesWritten/totalBytesExpectedToWrite;</span><br></pre></td></tr></table></figure></li><li><p>局限性</p><ul><li>如果用户点击暂停之后退出程序，那么需要把恢复下载的数据写一份到沙盒，代码复杂度更高</li><li>如果用户在下载中途未保存恢复下载数据即退出程序，则不具备可操作性</li></ul></li></ol><p>###4. 使用NSURLSessionDataTask实现大文件离线断点下载（完整）</p><ol><li><p>关于NSOutputStream的使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//1. 创建一个输入流,数据追加到文件的屁股上</span><br><span class="line">//把数据写入到指定的文件地址，如果当前文件不存在，则会自动创建</span><br><span class="line">NSOutputStream *stream = [[NSOutputStream alloc]initWithURL:[NSURL fileURLWithPath:[self fullPath]] append:YES];</span><br><span class="line">//2. 打开流</span><br><span class="line">[stream open];</span><br><span class="line">//3. 写入流数据</span><br><span class="line">[stream write:data.bytes maxLength:data.length];</span><br><span class="line">//4.当不需要的时候应该关闭流</span><br><span class="line">[stream close];</span><br></pre></td></tr></table></figure></li><li><p>关于网络请求请求头的设置（可以设置请求下载文件的某一部分）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//1. 设置请求对象</span><br><span class="line">//1.1 创建请求路径</span><br><span class="line">NSURL *url = [NSURL URLWithString:@&quot;URL字符串&quot;];</span><br><span class="line">//1.2 创建可变请求对象</span><br><span class="line">NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];</span><br><span class="line">//1.3 拿到当前文件的残留数据大小</span><br><span class="line">self.currentContentLength = [self FileSize];</span><br><span class="line">//1.4 告诉服务器从哪个地方开始下载文件数据</span><br><span class="line">NSString *range = [NSString stringWithFormat:@&quot;bytes=%zd-&quot;,self.currentContentLength];</span><br><span class="line">NSLog(@&quot;%@&quot;,range);</span><br><span class="line">//1.5 设置请求头</span><br><span class="line">[request setValue:range forHTTPHeaderField:@&quot;Range&quot;];</span><br></pre></td></tr></table></figure></li><li><p>NSURLSession对象的释放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(void)dealloc&#123; </span><br><span class="line">//在最后的时候应该把session释放，以免造成内存泄露 </span><br><span class="line">// NSURLSession设置过代理后，需要在最后（比如控制器销毁的时候）调用session的invalidateAndCancel或者resetWithCompletionHandler，才不会有内存泄露 </span><br><span class="line">// [self.session invalidateAndCancel];</span><br><span class="line"> [self.session resetWithCompletionHandler:^&#123; NSLog(@&quot;释放---&quot;);</span><br><span class="line"> &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优化部分</p><ul><li>关于文件下载进度的实时更新</li><li>方法的独立与抽取</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS网络编程--基础使用</title>
      <link href="/2016/04/12/iOS%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
      <url>/2016/04/12/iOS%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>iOS中发送http请求的方案 </p></blockquote><a id="more"></a><ul><li>苹果原生 <ul><li>NSURLConnection 03年推出的古老技术</li><li>NSURLSession 13年推出iOS7之后，以取代NSURLConnection   </li><li>CFNetwork 底层技术、C语言的 </li></ul></li><li>第三方框架<ul><li>ASIHttpRequest </li><li>AFNetworking </li><li>MKNetworkKit</li></ul></li></ul><h3 id="NSURLConnection使用"><a href="#NSURLConnection使用" class="headerlink" title="NSURLConnection使用"></a>NSURLConnection使用</h3><ul><li><p>NSURLConnection同步get请求</p><ul><li>步骤<ol><li>设置请求路径</li><li>创建请求对象（默认是GET请求，且已经默认包含了请求头）</li><li>使用NSURLConnection sendsync方法发送网络请求 </li><li>接收到服务器的响应后，解析响应体</li></ol></li><li>代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//1.确定请求路径 </span><br><span class="line">NSURL *url = [NSURL URLWithString:@&quot;URLString(发送请求的地址路径)&quot;]; </span><br><span class="line">//2.创建一个请求对象</span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url];</span><br><span class="line">//3.把请求发送给服务器</span><br><span class="line">//sendSynchronousRequest 阻塞式的方法，会卡住线程</span><br><span class="line">NSHTTPURLResponse *response = nil;NSError *error = nil;</span><br><span class="line">/* </span><br><span class="line">第一个参数：请求对象 </span><br><span class="line">第二个参数：响应头信息，当该方法执行完毕之后，该参数被赋值 </span><br><span class="line">第三个参数：错误信息，如果请求失败，则error有值 </span><br><span class="line">*/ </span><br><span class="line">//该方法是阻塞式的，会卡住线程</span><br><span class="line">NSData *data = [NSURLConnection sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error];</span><br><span class="line">//4.解析服务器返回的数据</span><br><span class="line">NSString *str = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];</span><br></pre></td></tr></table></figure></li></ul></li><li><p>NSURLConnection异步请求（get-sendAsync）<br>该方法不会卡住线程，网络请求任务是异步执行的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//1.确定请求路径 </span><br><span class="line">NSURL *url = [NSURL URLWithString:@&quot;URLString(发送请求的地址路径)&quot;]; </span><br><span class="line">//2.创建一个请求对象 </span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url]; </span><br><span class="line">//3.把请求发送给服务器,发送一个异步请求 </span><br><span class="line">/* </span><br><span class="line">第一个参数：请求对象 </span><br><span class="line">第二个参数：回调方法在哪个线程中执行，如果是主队列则block在主线程中执行，非主队列则在子线程中执行 </span><br><span class="line">第三个参数：completionHandlerBlock块：接受到响应的时候执行该block中的代码 response：响应头信息 data：响应体 connectionError：错误信息，如果请求失败，那么该参数有值 </span><br><span class="line">*/ </span><br><span class="line">[NSURLConnection sendAsynchronousRequest:request queue:[[NSOperationQueue alloc]init] completionHandler:^(NSURLResponse * __nullable response, NSData * __nullable data, NSError * __nullable connectionError) &#123; </span><br><span class="line">      //4.解析服务器返回的数据 </span><br><span class="line">      NSString *str = [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]; </span><br><span class="line">      //转换并打印响应头信息 </span><br><span class="line">      NSHTTPURLResponse *r = (NSHTTPURLResponse *)response; </span><br><span class="line">      NSLog(@&quot;--%zd---%@--&quot;,r.statusCode,r.allHeaderFields); </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li><li><p>NSURLConnection异步请求（get-代理）</p><ul><li>步骤<ol><li>确定请求路径</li><li>创建请求对象</li><li>创建NSURLConnection对象并设置代理</li><li>遵守NSURLConnectionDataDelegate协议，并实现相应的代理方法</li><li>在代理方法中监听网络请求的响应</li></ol></li><li><p>设置代理的几种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">设置代理的第一种方式：自动发送网络请求 </span><br><span class="line">[[NSURLConnection alloc]initWithRequest:request delegate:self]; </span><br><span class="line">*/</span><br><span class="line">/* </span><br><span class="line">设置代理的第二种方式： </span><br><span class="line">第一个参数：请求对象 </span><br><span class="line">第二个参数：谁成为NSURLConnetion对象的代理</span><br><span class="line">第三个参数：是否马上发送网络请求，如果该值为YES则立刻发送，如果为NO则不会发送网路请求 </span><br><span class="line">NSURLConnection *conn = [[NSURLConnection alloc]initWithRequest:request delegate:self startImmediately:NO]; </span><br><span class="line">//调用该方法控制网络请求的发送 </span><br><span class="line">//注意该方法内部会自动的把connect添加到当前线程的RunLoop中在默认模式下执行</span><br><span class="line">[conn start]; </span><br><span class="line">*/</span><br><span class="line">//设置代理的第三种方式：使用类方法设置代理，会自动发送网络请求</span><br><span class="line">NSURLConnection *conn = [NSURLConnection connectionWithRequest:request delegate:self];</span><br><span class="line">//取消网络请求</span><br><span class="line">//[conn cancel];</span><br></pre></td></tr></table></figure></li><li><p>相关代理方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">1.当接收到服务器响应的时候调用 </span><br><span class="line">第一个参数connection：监听的是哪个NSURLConnection对象 </span><br><span class="line">第二个参数response：接收到的服务器返回的响应头信息 </span><br><span class="line">*/ </span><br><span class="line">-(void)connection:(nonnull NSURLConnection *)connection didReceiveResponse:(nonnull NSURLResponse *)response </span><br><span class="line">/* </span><br><span class="line">2.当接收到数据的时候调用，该方法会被调用多次 </span><br><span class="line">第一个参数connection：监听的是哪个NSURLConnection对象 </span><br><span class="line">第二个参数data：本次接收到的服务端返回的二进制数据（可能是片段） </span><br><span class="line">*/ </span><br><span class="line">-(void)connection:(nonnull NSURLConnection *)connection didReceiveData:(nonnull NSData *)data </span><br><span class="line">/* </span><br><span class="line">3.当服务端返回的数据接收完毕之后会调用 通常在该方法中解析服务器返回的数据 */</span><br><span class="line"> -(void)connectionDidFinishLoading:(nonnull NSURLConnection *)connection </span><br><span class="line">/*</span><br><span class="line">4.当请求错误的时候调用（比如请求超时） </span><br><span class="line">第一个参数connection：NSURLConnection对象 </span><br><span class="line">第二个参数：网络请求的错误信息，如果请求失败，则error有值 </span><br><span class="line">*/ </span><br><span class="line">-(void)connection:(nonnull NSURLConnection *)connection didFailWithError:(nonnull NSError *)error</span><br></pre></td></tr></table></figure></li><li><p>如何控制代理方法在哪个线程调用<strong>*</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//说明：默认情况下，代理方法会在主线程中进行调用（为了方便开发者拿到数据后处理一些刷新UI的操作不需要考虑到线程间通信） </span><br><span class="line">//设置代理方法的执行队列 </span><br><span class="line">[connect setDelegateQueue:[[NSOperationQueue alloc]init]];</span><br></pre></td></tr></table></figure></li><li><p>开子线程发送网络请求的注意点，适用于自动发送网络请求模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//使用GCD开启一个子线程来发送网络请求 </span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; </span><br><span class="line">//使用非自动发送网络请求模式,发送请求OK </span><br><span class="line">/* </span><br><span class="line">//创建NSURLConnection对象，设置代理，暂不发送 </span><br><span class="line">NSURLConnection *connect = [[NSURLConnection alloc]initWithRequest:request delegate:self startImmediately:NO]; </span><br><span class="line">//设置代理方法的执行队列 [connect setDelegateQueue:[[NSOperationQueue alloc]init]]; </span><br><span class="line">//调用start发送网络请求 </span><br><span class="line">[connect start]; </span><br><span class="line">*/ </span><br><span class="line">//使用自动发送网络请求模式，发送请求失败（需要改造代码） </span><br><span class="line">//WHY? </span><br><span class="line">/*</span><br><span class="line">01 网络请求发送和数据接收是否成功，和一些因素相关，比如客户端的网速、服务器端的查询速度等等。 </span><br><span class="line">02 而在子线程中创建的NSURLConnection对象是一个临时变量，当请求发送完成之后就被释放了，所以这个时候它的代理方法不会调用用。 </span><br><span class="line">03 为什么使用非自动发送网络请求模式是OK的。 因为在该模式中，调用了start来开始发送网络请求，该方法内部会自动将当前的connect作为一个Source添加到当前线程所在的Runloop中,如果当前线程是子线程（即当前线程的runloop并未创建），那么该方法内部会默认先创建当前线程的Runloop,设置在runloop的默认模式下运行。 此时runloop会对这个Connect对象进行强引用，保证了代理方法被调用的前提 </span><br><span class="line">*/ </span><br><span class="line">NSURLConnection *connect = [[NSURLConnection alloc]initWithRequest:request delegate:self]; </span><br><span class="line">[connect setDelegateQueue:[[NSOperationQueue alloc]init]]; </span><br><span class="line">//创建当前线程的runloop，并开启runloop </span><br><span class="line">[[NSRunLoop currentRunLoop] run]; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>其他知识</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">01 关于消息弹窗第三方框架的使用 </span><br><span class="line">SVProgressHUD </span><br><span class="line">02 字符串截取相关方法 </span><br><span class="line">-(NSRange)rangeOfString:(NSString *)searchString; </span><br><span class="line">-(NSString *)substringWithRange:(NSRange)range;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>NSURLConnection发送POST请求</p><ul><li>发送POST请求步骤<ol><li>确定URL路径</li><li>创建请求对象（可变对象）</li><li>修改请求对象的方法为POST，设置请求体（Data）</li><li>发送一个异步请求</li><li>补充：设置请求超时，处理错误信息，设置请求头（如获取客户端的版本等等,请求头是可设置可不设置的）</li></ol></li><li>代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//1.确定请求路径 </span><br><span class="line">NSURL *url = [NSURL URLWithString:@&quot;请求路径字符串&quot;];</span><br><span class="line">//2.创建请求对象</span><br><span class="line">NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];</span><br><span class="line">//2.1更改请求方法</span><br><span class="line">request.HTTPMethod = @&quot;POST&quot;;</span><br><span class="line">//2.2设置请求体</span><br><span class="line">request.HTTPBody = [@&quot;username=111&amp;pwd=222&quot; dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">//2.3请求超时</span><br><span class="line">request.timeoutInterval = 5;</span><br><span class="line">//2.4设置请求头</span><br><span class="line">[request setValue:@&quot;ios 9.0&quot; forHTTPHeaderField:@&quot;User-Agent&quot;];</span><br><span class="line">//3.发送请求</span><br><span class="line">[NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * __nullable response, NSData * __nullable data, NSError * __nullable connectionError) </span><br><span class="line">&#123; </span><br><span class="line">          //4.解析服务器返回的数据 </span><br><span class="line">          if (connectionError) &#123; </span><br><span class="line">              NSLog(@&quot;--请求失败-&quot;); </span><br><span class="line">          &#125;else &#123; </span><br><span class="line">              NSLog(@&quot;%@&quot;,[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]);</span><br><span class="line">          &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="NSURLSession使用"><a href="#NSURLSession使用" class="headerlink" title="NSURLSession使用"></a>NSURLSession使用</h3><ul><li>使用步骤<ul><li>使用NSURLSession创建task，然后执行task</li></ul></li><li>关于task<ul><li>NSURLSessionTask是一个抽象类，本身不能使用，只能使用它的子类</li><li>NSURLSessionDataTask\NSURLSessionUploadTask\NSURLSessionDownloadTask</li></ul></li><li><p>发送get请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//1.创建NSURLSession对象（可以获取单例对象） </span><br><span class="line">NSURLSession *session = [NSURLSession sharedSession]; </span><br><span class="line">//2.根据NSURLSession对象创建一个Task </span><br><span class="line">NSURL *url = [NSURL URLWithString:@&quot;URL字符串&quot;]; </span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url]; </span><br><span class="line">//方法参数说明 </span><br><span class="line">/* </span><br><span class="line">注意：该block是在子线程中调用的，如果拿到数据之后要做一些UI刷新操作，那么需要回到主线程刷新 </span><br><span class="line">第一个参数：需要发送的请求对象 </span><br><span class="line">block:当请求结束拿到服务器响应的数据时调用block </span><br><span class="line">block-NSData:该请求的响应体 </span><br><span class="line">block-NSURLResponse:存放本次请求的响应信息，响应头，真实类型为NSHTTPURLResponse </span><br><span class="line">block-NSErroe:请求错误信息 </span><br><span class="line">*/ </span><br><span class="line">NSURLSessionDataTask * dataTask = [session dataTaskWithRequest:request completionHandler:^(NSData * __nullable data, NSURLResponse * __nullable response, NSError * __nullable error) &#123; </span><br><span class="line">//拿到响应头信息 </span><br><span class="line">NSHTTPURLResponse *res = (NSHTTPURLResponse *)response; </span><br><span class="line">//4.解析拿到的响应数据 </span><br><span class="line">NSLog(@&quot;%@\n%@&quot;,[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding],res.allHeaderFields); </span><br><span class="line">&#125;]; </span><br><span class="line">//3.执行Task </span><br><span class="line">//注意：刚创建出来的task默认是挂起状态的，需要调用该方法来启动任务（执行任务） </span><br><span class="line">[dataTask resume];</span><br></pre></td></tr></table></figure></li><li><p>发送get请求的第二种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//注意：该方法内部默认会把URL对象包装成一个NSURLRequest对象（默认是GET请求） </span><br><span class="line">//方法参数说明 </span><br><span class="line">/* </span><br><span class="line">//第一个参数：发送请求的URL地址 </span><br><span class="line">//block:当请求结束拿到服务器响应的数据时调用block </span><br><span class="line">//block-NSData:该请求的响应体 </span><br><span class="line">//block-NSURLResponse:存放本次请求的响应信息，响应头，真实类型为NSHTTPURLResponse </span><br><span class="line">//block-NSErroe:请求错误信息 </span><br><span class="line">*/ </span><br><span class="line">-(nullable NSURLSessionDataTask *)dataTaskWithURL:(NSURL *)url completionHandler:(void (^)(NSData * __nullable data, NSURLResponse * __nullable response, NSError * __nullable error))completionHandler;</span><br></pre></td></tr></table></figure></li><li><p>发送post请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//1.创建NSURLSession对象（可以获取单例对象） </span><br><span class="line">NSURLSession *session = [NSURLSession sharedSession]; </span><br><span class="line">//2.根据NSURLSession对象创建一个Task </span><br><span class="line">NSURL *url = [NSURL URLWithString:@&quot;URL字符串&quot;]; </span><br><span class="line">//创建一个请求对象，并这是请求方法为POST，把参数放在请求体中传递 NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; </span><br><span class="line">request.HTTPMethod = @&quot;POST&quot;; </span><br><span class="line">request.HTTPBody = [@&quot;username=111&amp;pwd=222&amp;type=JSON&quot; dataUsingEncoding:NSUTF8StringEncoding]; </span><br><span class="line">NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request completionHandler:^(NSData * __nullable data, NSURLResponse * __nullable response, NSError * __nullable error) &#123; </span><br><span class="line">//拿到响应头信息 </span><br><span class="line">NSHTTPURLResponse *res = (NSHTTPURLResponse *)response; </span><br><span class="line">//解析拿到的响应数据 </span><br><span class="line">NSLog(@&quot;%@\n%@&quot;,[[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding],res.allHeaderFields); </span><br><span class="line">&#125;]; </span><br><span class="line">//3.执行Task </span><br><span class="line">//注意：刚创建出来的task默认是挂起状态的，需要调用该方法来启动任务（执行任务） </span><br><span class="line">[dataTask resume];</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS之数据解析</title>
      <link href="/2016/04/12/iOS%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/"/>
      <url>/2016/04/12/iOS%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>iOS开发中，几乎只要是与网络相关的应用，都离不开对网络数据的解析与应用。一般来讲，我们会从网络获取XML或者Json格式的数据，这些数据有着特定的数据结构，必须对其进行解析，得到我们可以处理的数据。所谓“解析”，就是从事先规定好的格式串中提取数据。解析的前提是数据的提供方与获取方提前约定好格式，数据提供方按照格式提供数据，数据获取方按照格式获取数据。</p></blockquote><a id="more"></a><h2 id="JSON解析"><a href="#JSON解析" class="headerlink" title="JSON解析"></a>JSON解析</h2><p>JSON是一种轻量级的数据格式，一般用于数据交互。服务器返回给客户端的数据，一般都是JSON格式或者XML格式（文件下载除外）</p><h3 id="相关说明"><a href="#相关说明" class="headerlink" title="相关说明"></a>相关说明</h3><ol><li>JSON的格式很像OC中的字典和数组</li><li>标准JSON格式key必须是双引号</li></ol><h3 id="JSON解析方案"><a href="#JSON解析方案" class="headerlink" title="JSON解析方案"></a>JSON解析方案</h3><ol><li>第三方框架 JSONKit\SBJSON\TouchJSON</li><li>苹果原生（NSJSONSerialization）</li></ol><h3 id="JSON解析相关代码"><a href="#JSON解析相关代码" class="headerlink" title="JSON解析相关代码"></a>JSON解析相关代码</h3><h4 id="json数据-gt-OC对象"><a href="#json数据-gt-OC对象" class="headerlink" title="json数据-&gt;OC对象"></a>json数据-&gt;OC对象</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把json数据转换为OC对象 </span></span><br><span class="line">-(<span class="keyword">void</span>)jsonToOC &#123; </span><br><span class="line">    <span class="comment">//1. 确定url路径</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"URL字符串"</span>];</span><br><span class="line">    <span class="comment">//2.创建一个请求对象</span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url];</span><br><span class="line">    <span class="comment">//3.使用NSURLConnection发送一个异步请求</span></span><br><span class="line">    [<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:[<span class="built_in">NSOperationQueue</span> mainQueue] completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSError</span> * _Nullable connectionError) &#123;</span><br><span class="line">        <span class="comment">//4.当接收到服务器响应的数据后，解析数据(JSON---&gt;OC)</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        第一个参数：要解析的JSON数据，是NSData类型也就是二进制数据 </span></span><br><span class="line"><span class="comment">        第二个参数: 解析JSON的可选配置参数 </span></span><br><span class="line"><span class="comment">        NSJSONReadingMutableContainers 解析出来的字典和数组是可变的 </span></span><br><span class="line"><span class="comment">        NSJSONReadingMutableLeaves 解析出来的对象中的字符串是可变的 iOS7以后有问题 </span></span><br><span class="line"><span class="comment">        NSJSONReadingAllowFragments 被解析的JSON数据如果既不是字典也不是数组, 那么就必须使用这个 </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        <span class="built_in">NSDictionary</span> *dict = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:<span class="literal">nil</span>]; </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,dict);</span><br><span class="line">      &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="OC对象-gt-JSON对象"><a href="#OC对象-gt-JSON对象" class="headerlink" title="OC对象-&gt;JSON对象"></a>OC对象-&gt;JSON对象</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.要转换成JSON数据的OC对象*这里是一个字典</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *dictM = @&#123;<span class="string">@"name"</span>:<span class="string">@"flame"</span>, </span><br><span class="line">                        <span class="string">@"age"</span>:@<span class="number">20</span>, </span><br><span class="line">                        <span class="string">@"height"</span>:@<span class="number">1.80</span> </span><br><span class="line">                      &#125;;</span><br><span class="line"><span class="comment">//2.OC-&gt;JSON</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">注意：可以通过+ (BOOL)isValidJSONObject:(id)obj;方法判断当前OC对象能否转换为JSON数据 </span></span><br><span class="line"><span class="comment">具体限制： </span></span><br><span class="line"><span class="comment">1.obj 是NSArray 或 NSDictionay 以及他们派生出来的子类 </span></span><br><span class="line"><span class="comment">2.obj 包含的所有对象是NSString,NSNumber,NSArray,NSDictionary 或NSNull </span></span><br><span class="line"><span class="comment">3.字典中所有的key必须是NSString类型的 </span></span><br><span class="line"><span class="comment">4.NSNumber的对象不能是NaN或无穷大 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">第一个参数：要转换成JSON数据的OC对象，这里为一个字典 </span></span><br><span class="line"><span class="comment">第二个参数：NSJSONWritingPrettyPrinted对转换之后的JSON对象进行排版，无意义 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSJSONSerialization</span> dataWithJSONObject:dictM options:<span class="built_in">NSJSONWritingPrettyPrinted</span> error:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//3.打印查看Data是否有值</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">第一个参数：要转换为String的二进制数据 </span></span><br><span class="line"><span class="comment">第二个参数：编码方式，通常采用NSUTF8StringEncoding </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">NSString</span> *strM = [[<span class="built_in">NSString</span> alloc]initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,strM);</span><br></pre></td></tr></table></figure><h4 id="OC对象和JSON数据格式之间的一一对应关系"><a href="#OC对象和JSON数据格式之间的一一对应关系" class="headerlink" title="OC对象和JSON数据格式之间的一一对应关系"></a>OC对象和JSON数据格式之间的一一对应关系</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OC对象和JSON数据之间的一一对应关系</span></span><br><span class="line">-(<span class="keyword">void</span>)oCWithJSON&#123; </span><br><span class="line">    <span class="comment">//JSON的各种数据格式 </span></span><br><span class="line">    <span class="comment">//NSString *test = @"\"flame\""; </span></span><br><span class="line">    <span class="comment">//NSString *test = @"true"; </span></span><br><span class="line">    <span class="built_in">NSString</span> *test = <span class="string">@"&#123;\"name\":\"flame\"&#125;"</span>; </span><br><span class="line">    <span class="comment">//把JSON数据-&gt;OC对象,以便查看他们之间的一一对应关系 </span></span><br><span class="line">    <span class="comment">//注意点：被解析的JSON数据如果既不是字典也不是数组（比如是NSString）, 那么就必须使用这 NSJSONReadingAllowFragments </span></span><br><span class="line">    <span class="keyword">id</span> obj = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:[test dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>] options:<span class="built_in">NSJSONReadingAllowFragments</span> error:<span class="literal">nil</span>]; </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [obj <span class="keyword">class</span>]); </span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    JSON数据格式和OC对象的一一对应关系 </span></span><br><span class="line"><span class="comment">    &#123;&#125; -&gt; 字典 </span></span><br><span class="line"><span class="comment">    [] -&gt; 数组 </span></span><br><span class="line"><span class="comment">    "" -&gt; 字符串 </span></span><br><span class="line"><span class="comment">    10/10.1 -&gt; NSNumber </span></span><br><span class="line"><span class="comment">    true/false -&gt; NSNumber </span></span><br><span class="line"><span class="comment">    null -&gt; NSNull </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何查看复杂的JSON数据"><a href="#如何查看复杂的JSON数据" class="headerlink" title="如何查看复杂的JSON数据"></a>如何查看复杂的JSON数据</h4><p>方法一： 在线格式化<a href="http://tool.oschina.net/codeformat/json" target="_blank" rel="noopener">http://tool.oschina.net/codeformat/json</a><br>方法二： 把解析后的数据写plist文件，通过plist文件可以直观的查看JSON的层次结构。<br>[dictM writeToFile:@”文件路径/文件名.plist” atomically:YES];</p><h4 id="字典转模型框架"><a href="#字典转模型框架" class="headerlink" title="字典转模型框架"></a>字典转模型框架</h4><ol><li>相关框架<ul><li>Mantle 需要继承自MTModel</li><li>JSONModel 需要继承自JSONModel</li><li>MJExtension 不需要继承，无代码侵入性</li></ul></li><li>自己设计和选择框架时需要注意的问题<ul><li>侵入性</li><li>易用性，是否容易上手</li><li>扩展性，很容易给这个框架增加新的功能</li></ul></li></ol><h2 id="XML解析"><a href="#XML解析" class="headerlink" title="XML解析"></a>XML解析</h2><h3 id="XML简单介绍"><a href="#XML简单介绍" class="headerlink" title="XML简单介绍"></a>XML简单介绍</h3><p>XML：可扩展标记语言<br><a href="http://baike.baidu.com/link?url=TbqIa8egIx6fbzxIPnajB253ae80Nli9O7sLob2LW9zt-lN1WKxuhfV5srC-lyaJpBgQXezNbHN8-QDmMY46dqQSI9SfOrzgKxB8GXCuhtmmoC1gpkqmJ1Z1PhWgV_TD" target="_blank" rel="noopener">http://baike.baidu.com/link?url=TbqIa8egIx6fbzxIPnajB253ae80Nli9O7sLob2LW9zt-lN1WKxuhfV5srC-lyaJpBgQXezNbHN8-QDmMY46dqQSI9SfOrzgKxB8GXCuhtmmoC1gpkqmJ1Z1PhWgV_TD</a></p><h3 id="XML解析-1"><a href="#XML解析-1" class="headerlink" title="XML解析"></a>XML解析</h3><p>XML解析的两种方式 </p><ol><li>SAX:从根元素开始，按顺序一个元素一个元素的往下解析，可用于解析大、小文件 </li><li>DOM:一次性将整个XML文档加载到内存中，适合较小的文件 </li></ol><p>解析XML的工具 </p><ol><li>苹果原生NSXMLParser:使用SAX方式解析，使用简单 </li><li>第三方框架 </li></ol><p>libxml2:纯C语言的，默认包含在iOS SDK中，同时支持DOM和SAX的方式解析 GDataXML:采用DOM方式解析，该框架由Google开发，是基于xml2的</p><h3 id="XML解析代码"><a href="#XML解析代码" class="headerlink" title="XML解析代码"></a>XML解析代码</h3><p>使用NSXMLParser解析XML步骤和代理方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析步骤：</span></span><br><span class="line"><span class="comment">//4.1 创建一个解析器</span></span><br><span class="line"><span class="built_in">NSXMLParser</span> *parser = [[<span class="built_in">NSXMLParser</span> alloc]initWithData:data];</span><br><span class="line"><span class="comment">//4.2 设置代理</span></span><br><span class="line">parser.delegate = <span class="keyword">self</span>;</span><br><span class="line"><span class="comment">//4.3 开始解析</span></span><br><span class="line">[parser parse];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.开始解析XML文档</span></span><br><span class="line">-(<span class="keyword">void</span>)parserDidStartDocument:(<span class="keyword">nonnull</span> <span class="built_in">NSXMLParser</span> *)parser</span><br><span class="line"><span class="comment">//2.开始解析XML中某个元素的时候调用，比如&lt;video&gt;</span></span><br><span class="line">-(<span class="keyword">void</span>)parser:(<span class="keyword">nonnull</span> <span class="built_in">NSXMLParser</span> *)parser didStartElement:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)elementName namespaceURI:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)namespaceURI qualifiedName:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)qName attributes:(<span class="keyword">nonnull</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="built_in">NSString</span> *&gt; *)attributeDict&#123; </span><br><span class="line">    <span class="keyword">if</span> ([elementName isEqualToString:<span class="string">@"videos"</span>]) &#123; <span class="keyword">return</span>; &#125; </span><br><span class="line">    <span class="comment">//字典转模型 </span></span><br><span class="line">    TYVideo *video = [TYVideo objectWithKeyValues:attributeDict];   </span><br><span class="line">    [<span class="keyword">self</span>.videos addObject:video];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.当某个元素解析完成之后调用，比如&lt;/video&gt;</span></span><br><span class="line">-(<span class="keyword">void</span>)parser:(<span class="keyword">nonnull</span> <span class="built_in">NSXMLParser</span> *)parser didEndElement:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)elementName namespaceURI:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)namespaceURI qualifiedName:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)qName</span><br><span class="line"><span class="comment">//4.XML文档解析结束</span></span><br><span class="line">-(<span class="keyword">void</span>)parserDidEndDocument:(<span class="keyword">nonnull</span> <span class="built_in">NSXMLParser</span> *)parser</span><br></pre></td></tr></table></figure><p>使用GDataParser解析XML的步骤和方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置环境</span></span><br><span class="line"><span class="comment">// 1 先导入框架，然后按照框架使用注释配置环境</span></span><br><span class="line"><span class="comment">// 2 GDataXML框架是MRC的，所以还需要告诉编译器以MRC的方式处理GDataXML的代码</span></span><br><span class="line"><span class="comment">//加载XML文档（使用的是DOM的方式一口气把整个XML文档都吞下）</span></span><br><span class="line">GDataXMLDocument *doc = [[GDataXMLDocument alloc]initWithData:data options:kNilOptions error:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//获取XML文档的根元素，根据根元素取出XML中的每个子元素 </span></span><br><span class="line"><span class="built_in">NSArray</span> * elements = [doc.rootElement elementsForName:<span class="string">@"video"</span>];</span><br><span class="line"><span class="comment">//取出每个子元素的属性并转换为模型</span></span><br><span class="line"><span class="keyword">for</span> (GDataXMLElement *ele <span class="keyword">in</span> elements) &#123; </span><br><span class="line">    TYVideo *video = [[TYVideo alloc]init]; </span><br><span class="line">    video.name = [ele attributeForName:<span class="string">@"name"</span>].stringValue; </span><br><span class="line">    video.length = [ele attributeForName:<span class="string">@"length"</span>].stringValue.integerValue; </span><br><span class="line">    video.url = [ele attributeForName:<span class="string">@"url"</span>].stringValue;</span><br><span class="line">    video.image = [ele attributeForName:<span class="string">@"image"</span>].stringValue; </span><br><span class="line">    video.ID = [ele attributeForName:<span class="string">@"id"</span>].stringValue; </span><br><span class="line">    <span class="comment">//把转换好的模型添加到tableView的数据源self.videos数组中 </span></span><br><span class="line">    [<span class="keyword">self</span>.videos addObject:video];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多值参数和中文输出问题"><a href="#多值参数和中文输出问题" class="headerlink" title="多值参数和中文输出问题"></a>多值参数和中文输出问题</h2><h3 id="多值参数如何设置请求路径"><a href="#多值参数如何设置请求路径" class="headerlink" title="多值参数如何设置请求路径"></a>多值参数如何设置请求路径</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果一个参数对应着多个值，那么直接按照"参数=值&amp;参数=值"的方式拼接 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">-(<span class="keyword">void</span>)test&#123; </span><br><span class="line">    <span class="comment">//1.确定</span></span><br><span class="line">    URL <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"URL字符串"</span>]; </span><br><span class="line">    <span class="comment">//2.创建请求对象 </span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url]; </span><br><span class="line">    <span class="comment">//3.发送请求 </span></span><br><span class="line">    [<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:[<span class="built_in">NSOperationQueue</span> mainQueue] completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSError</span> * _Nullable connectionError) &#123; </span><br><span class="line">        <span class="comment">//4.解析 </span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:kNilOptions error:<span class="literal">nil</span>]); </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何解决字典和数组中输出乱码的问题"><a href="#如何解决字典和数组中输出乱码的问题" class="headerlink" title="如何解决字典和数组中输出乱码的问题"></a>如何解决字典和数组中输出乱码的问题</h3><p>给字典和数组添加一个分类，重写descriptionWithLocale方法，在该方法中拼接元素格式化输出。 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)descriptionWithLocale:(<span class="keyword">nullable</span> <span class="keyword">id</span>)locale</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS之Runloop</title>
      <link href="/2016/04/11/iOS%E4%B9%8BRunloop/"/>
      <url>/2016/04/11/iOS%E4%B9%8BRunloop/</url>
      
        <content type="html"><![CDATA[<p>Runloop，正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。如果没有Runloop,那么程序一启动就会退出，什么事情都做不了；如果有了Runloop，那么相当于在内部有一个死循环，能够保证程序的持续运行。</p><a id="more"></a><h2 id="Runloop的作用"><a href="#Runloop的作用" class="headerlink" title="Runloop的作用"></a>Runloop的作用</h2><p>保持程序的持续运行(ios程序为什么能一直活着不会死)</p><p>处理app中的各种事件（比如触摸事件、定时器事件【NSTimer】、selector事件【选择器·performSelector···】）</p><p>节省CPU资源，提高程序性能，有事情就做事情，没事情就休息</p><p>main函数中的Runloop ：</p><ol><li>在UIApplication函数内部就启动了一个Runloop 该函数返回一个int类型的值 </li><li>这个默认启动的Runloop是跟主线程相关联的</li></ol><h2 id="Runloop对象"><a href="#Runloop对象" class="headerlink" title="Runloop对象"></a>Runloop对象</h2><p>在iOS开发中有两套api来访问Runloop </p><ul><li>foundation框架【NSRunloop】</li><li>core foundation框架【CFRunloopRef】</li></ul><p>NSRunLoop和CFRunLoopRef都代表着RunLoop对象,它们是等价的，可以互相转换 </p><p>NSRunLoop是基于CFRunLoopRef的一层OC包装，所以要了解RunLoop内部结构，需要多研究CFRunLoopRef层面的API（Core Foundation层面）</p><h2 id="Runloop与线程"><a href="#Runloop与线程" class="headerlink" title="Runloop与线程"></a>Runloop与线程</h2><p>Runloop和线程的关系：一个Runloop对应着一条唯一的线程。为了让子线程不死，可以给这条子线程开启一个Runloop </p><p>Runloop的创建：主线程Runloop已经创建好了，子线程的runloop需要手动创建 </p><p>Runloop的生命周期：在第一次获取时创建，在线程结束时销毁</p><h2 id="如何获取Runloop对象"><a href="#如何获取Runloop对象" class="headerlink" title="如何获取Runloop对象"></a>如何获取Runloop对象</h2><p>获得当前Runloop对象 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//01 NSRunloop </span></span><br><span class="line"><span class="built_in">NSRunLoop</span> * runloop1 = [<span class="built_in">NSRunLoop</span> currentRunLoop]; </span><br><span class="line"><span class="comment">//02 CFRunLoopRef </span></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> runloop2 = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br></pre></td></tr></table></figure><p>拿到当前应用程序的主Runloop（主线程对应的Runloop） </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//01 NSRunloop </span></span><br><span class="line"><span class="built_in">NSRunLoop</span> * runloop1 = [<span class="built_in">NSRunLoop</span> mainRunLoop]; </span><br><span class="line"><span class="comment">//02 CFRunLoopRef</span></span><br><span class="line"> <span class="built_in">CFRunLoopRef</span> runloop2 = <span class="built_in">CFRunLoopGetMain</span>();</span><br></pre></td></tr></table></figure><p><strong>注意点</strong>：开一个子线程创建runloop,不是通过alloc init方法创建，而是直接通过调用currentRunLoop方法来创建，它本身是一个懒加载的。 </p><p>在子线程中，如果不主动获取Runloop的话，那么子线程内部是不会创建Runloop的。可以下载CFRunloopRef的源码，搜索_CFRunloopGet0,查看代码。</p><p>Runloop对象是利用字典来进行存储，而且key是对应的线程Value为该线程对应的Runloop。</p><h2 id="Runloop相关类"><a href="#Runloop相关类" class="headerlink" title="Runloop相关类"></a>Runloop相关类</h2><p>Runloop运行图</p><p><img src="http://upload-images.jianshu.io/upload_images/1879463-dbb689a6a20153f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Runloop运行图"></p><p>五个相关的类：</p><ol><li>CFRunloopRef</li><li>CFRunloopModeRef【Runloop的运行模式】</li><li>CFRunloopSourceRef【Runloop要处理的事件源】</li><li>CFRunloopTimerRef【Timer事件】</li><li>CFRunloopObserverRef【Runloop的观察者（监听者）】</li></ol><h2 id="Runloop和相关类之间的关系图"><a href="#Runloop和相关类之间的关系图" class="headerlink" title="Runloop和相关类之间的关系图"></a>Runloop和相关类之间的关系图</h2><p><img src="http://upload-images.jianshu.io/upload_images/1879463-42827b80dec71711.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Runloop和相关类之间的关系图"></p><p>Runloop要想跑起来，它的内部必须要有一个mode,这个mode里面必须有source\observer\timer，至少要有其中的一个。</p><h3 id="CFRunloopModeRef"><a href="#CFRunloopModeRef" class="headerlink" title="CFRunloopModeRef"></a>CFRunloopModeRef</h3><ol><li>CFRunloopModeRef代表着Runloop的运行模式 </li><li>一个Runloop中可以有多个mode,一个mode里面又可以有多个source\observer\timer等等 </li><li>每次runloop启动的时候，只能指定一个mode,这个mode被称为该Runloop的当前mode </li><li>如果需要切换mode,只能先退出当前Runloop,再重新指定一个mode进入 </li><li>这样做主要是为了分割不同组的定时器等，让他们相互之间不受影响 </li><li>系统默认注册了5个mode <ul><li>kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行 </li><li>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响 </li><li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用 </li><li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到 </li><li>kCFRunLoopCommonModes: 这是一个占位用的Mode，不是一种真正的Mode</li></ul></li></ol><h3 id="CFRunloopTimerRef"><a href="#CFRunloopTimerRef" class="headerlink" title="CFRunloopTimerRef"></a>CFRunloopTimerRef</h3><ol><li>runloop一启动就会选中一种模式，当选中了一种模式之后其它的模式就都不管用。一个mode里面可以添加多个NSTimer,也就是说以后当创建NSTimer的时候，可以指定它是在什么模式下运行的。</li><li>它是基于时间的触发器，说直白点那就是时间到了我就触发一个事件，触发一个操作。基本上说的就是NSTimer</li><li>相关代码：</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NSTimer 调用了scheduledTimer方法，那么会自动添加到当前的runloop里面去，而且runloop的运行模式kCFRunLoopDefaultMode</span></span><br><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">//更改模式</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"><span class="comment">//定时器添加到UITrackingRunLoopMode模式，一旦runloop切换模式，那么定时器就不工作</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">UITrackingRunLoopMode</span>];</span><br><span class="line"><span class="comment">//定时器添加到NSDefaultRunLoopMode模式，一旦runloop切换模式，那么定时器就不工作</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"><span class="comment">//占位模式：common modes标记</span></span><br><span class="line"><span class="comment">//被标记为common modes的模式 kCFRunLoopDefaultMode  UITrackingRunLoopMode</span></span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure><h2 id="GCD中的定时器"><a href="#GCD中的定时器" class="headerlink" title="GCD中的定时器"></a>GCD中的定时器</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0.创建一个队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//1.创建一个GCD的定时器</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一个参数：说明这是一个定时器</span></span><br><span class="line"><span class="comment">第四个参数：GCD的回调任务添加到那个队列中执行，如果是主队列则在主线程执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line"><span class="comment">//2.设置定时器的开始时间，间隔时间以及精准度</span></span><br><span class="line"><span class="comment">//设置开始时间，三秒钟之后调用</span></span><br><span class="line">dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW,<span class="number">3.0</span> *<span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line"><span class="comment">//设置定时器工作的间隔时间</span></span><br><span class="line">uint64_t intevel = <span class="number">1.0</span> * <span class="built_in">NSEC_PER_SEC</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一个参数：要给哪个定时器设置</span></span><br><span class="line"><span class="comment">第二个参数：定时器的开始时间DISPATCH_TIME_NOW表示从当前开始</span></span><br><span class="line"><span class="comment">第三个参数：定时器调用方法的间隔时间</span></span><br><span class="line"><span class="comment">第四个参数：定时器的精准度，如果传0则表示采用最精准的方式计算，如果传大于0的数值，则表示该定时切换i可以接收该值范围内的误差，通常传0</span></span><br><span class="line"><span class="comment">该参数的意义：可以适当的提高程序的性能</span></span><br><span class="line"><span class="comment">注意点：GCD定时器中的时间以纳秒为单位（面试）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">dispatch_source_set_timer(timer, start, intevel, <span class="number">0</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line"><span class="comment">//3.设置定时器开启后回调的方法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一个参数：要给哪个定时器设置</span></span><br><span class="line"><span class="comment">第二个参数：回调block</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"------%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//4.执行定时器</span></span><br><span class="line">dispatch_resume(timer);</span><br><span class="line"><span class="comment">//注意：dispatch_source_t本质上是OC类，在这里是个局部变量，需要强引用</span></span><br><span class="line"><span class="keyword">self</span>.timer = timer;</span><br></pre></td></tr></table></figure><h3 id="CFRunloopSourceRef"><a href="#CFRunloopSourceRef" class="headerlink" title="CFRunloopSourceRef"></a>CFRunloopSourceRef</h3><ol><li>是事件源也就是输入源，有两种分类模式；<ul><li>一种是按照苹果官方文档进行划分的</li><li>另一种是基于函数的调用栈来进行划分的（source0和source1）。</li></ul></li><li>具体的分类情况<ul><li>以前的分法<pre><code>Port-Based SourcesCustom Input SourcesCocoa Perform Selector Sources</code></pre></li><li>现在的分法<pre><code>Source0：非基于Port的Source1：基于Port的</code></pre></li></ul></li><li>可以通过打断点的方式查看一个方法的函数调用栈</li></ol><h3 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h3><ul><li>CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变</li><li>如何监听:</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个runloop监听者</span></span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(<span class="built_in">CFAllocatorGetDefault</span>(),kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"监听runloop状态改变---%zd"</span>,activity);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//为runloop添加一个监听者</span></span><br><span class="line">    <span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), observer, kCFRunLoopDefaultMode);</span><br><span class="line">    <span class="built_in">CFRelease</span>(observer);</span><br></pre></td></tr></table></figure><ul><li>监听的状态</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</span><br><span class="line">        kCFRunLoopEntry = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>),   <span class="comment">//即将进入Runloop</span></span><br><span class="line">        kCFRunLoopBeforeTimers = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>),    <span class="comment">//即将处理NSTimer</span></span><br><span class="line">        kCFRunLoopBeforeSources = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>),   <span class="comment">//即将处理Sources</span></span><br><span class="line">        kCFRunLoopBeforeWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>),   <span class="comment">//即将进入休眠</span></span><br><span class="line">        kCFRunLoopAfterWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>),    <span class="comment">//刚从休眠中唤醒</span></span><br><span class="line">        kCFRunLoopExit = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>),            <span class="comment">//即将退出runloop</span></span><br><span class="line">        kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U   <span class="comment">//所有状态改变</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Runloop运行逻辑"><a href="#Runloop运行逻辑" class="headerlink" title="Runloop运行逻辑"></a>Runloop运行逻辑</h2><p>每次运行runloop，你线程的runloop对象会自动处理之前未处理的消息，并通知相关的观察者，具体顺序如下：</p><ol><li>通知观察者runloop已经启动</li><li>通知观察者任何即将要开始的定时器</li><li>通知观察者任何即将启动的非基于端口的源</li><li>启动任何准备好的非基于端口的源</li><li>如果基于端口的源准备好并处于等待状态，立即启动；并进入步骤9</li><li>通知观察者线程进入休眠</li><li>将线程置于休眠知道任一下面的事件发生：<ul><li>某一事件到达基于端口的源</li><li>定时器启动</li><li>runloop设置的时间已经超时</li><li>runloop被显式唤醒</li></ul></li><li>通知观察者线程将被唤醒</li><li>处理未处理的事件<ul><li>如果用户定义的定时器启动，处理定时器事件并重启runloop，进入步骤2</li><li>如果输入源启动，传递相应的消息</li><li>如果runloop被显式唤醒而且时间还没超时，重启runloop，进入步骤2</li></ul></li><li>通知观察者runloop结束</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/1879463-f1e203b5a8358729.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Runloop运行逻辑"></p><h2 id="Runloop应用"><a href="#Runloop应用" class="headerlink" title="Runloop应用"></a>Runloop应用</h2><ul><li>NSTimer</li><li>ImageView显示</li><li>PerformSelector</li><li>常驻线程</li><li>自动释放池</li></ul><h2 id="Runloop参考资料"><a href="#Runloop参考资料" class="headerlink" title="Runloop参考资料"></a>Runloop参考资料</h2><ul><li><p>苹果官方文档<br><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html" target="_blank" rel="noopener">https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html</a></p></li><li><p>CFRunLoopRef开源代码下载地址：<br><a href="http://opensource.apple.com/source/CF/CF-1151.16/" target="_blank" rel="noopener">http://opensource.apple.com/source/CF/CF-1151.16/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS之Runtime</title>
      <link href="/2016/04/10/iOS%E4%B9%8Bruntime/"/>
      <url>/2016/04/10/iOS%E4%B9%8Bruntime/</url>
      
        <content type="html"><![CDATA[<blockquote><p>RunTime简称运行时。它是一套纯C语言API,属于一个C语言库,包含了很多底层的C语言API。OC就是运行时机制，我们平时写的OC代码在运行的时候都会转换成runtime的C语言代码。</p></blockquote><a id="more"></a><p>对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。事实证明：在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错。在编译阶段，C语言调用未实现的函数就会报错。</p><h2 id="Runtime有什么作用"><a href="#Runtime有什么作用" class="headerlink" title="Runtime有什么作用"></a>Runtime有什么作用</h2><p>在没有了解runtime之前，你会觉得它没有什么用，但当你深入的了解了OC的运行机制后，你就会觉的其实它的作用非常之大。</p><h4 id="1-发送消息"><a href="#1-发送消息" class="headerlink" title="1. 发送消息"></a>1. 发送消息</h4><ul><li>方法调用的本质就是让对象发送消息</li><li>objc_msgSend,只有对象才能发送消息，因此以objc开头</li><li>使用消息机制的前提，必须导入#import <objc message.h></objc></li><li>消息机制原理:对象根据方法编号SEL去映射表查找对应的方法实现</li><li><p>消息机制代码说明：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建person对象 </span></span><br><span class="line">Person *p = [[Person alloc] init]; </span><br><span class="line"><span class="comment">// 调用对象方法 </span></span><br><span class="line">[p eat]; </span><br><span class="line"><span class="comment">// 本质：让对象发送消息 </span></span><br><span class="line">objc_msgSend(p, <span class="keyword">@selector</span>(eat)); </span><br><span class="line"><span class="comment">// 调用类方法的方式：两种 </span></span><br><span class="line"><span class="comment">// 第一种通过类名调用 </span></span><br><span class="line">[Person eat]; </span><br><span class="line"><span class="comment">// 第二种通过类对象调用 </span></span><br><span class="line">[[Person <span class="keyword">class</span>] eat]; </span><br><span class="line"><span class="comment">// 用类名调用类方法，底层会自动把类名转换成类对象调用 </span></span><br><span class="line"><span class="comment">// 本质：让类对象发送消息 </span></span><br><span class="line">objc_msgSend([Person <span class="keyword">class</span>], <span class="keyword">@selector</span>(eat));</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-交换方法"><a href="#2-交换方法" class="headerlink" title="2.交换方法"></a>2.交换方法</h4><p>如果系统自带的方法功能不够，可以给系统自带的方法扩展一些功能，并且保持原有的功能，有两种实现方式：</p><ol><li>继承系统的类，重写方法</li><li>使用runtime,交换方法</li></ol><p>使用Runtime实现方法交换：</p><ul><li>在分类中交换方法地址，并实现方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIImage</span> (<span class="title">Image</span>)</span></span><br><span class="line"><span class="comment">//加载分类到内存中的时候调用</span></span><br><span class="line">+(<span class="keyword">void</span>)load&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取imageNamed方法地址</span></span><br><span class="line">    Method imageName = class_getClassMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(imageNamed:));</span><br><span class="line">    <span class="comment">//获取imageWithName方法地址</span></span><br><span class="line">    Method imageWithName = class_getClassMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(imageWithName:));</span><br><span class="line">    <span class="comment">//交换两个方法的地址</span></span><br><span class="line">    method_exchangeImplementations(imageName, imageWithName);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不能在分类中重写系统方法imageNamed，因为会把系统的功能给覆盖掉，而且分类中不能调用super.</span></span><br><span class="line">+(<span class="keyword">instancetype</span>)imageWithName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    <span class="comment">// 这里调用imageWithName，相当于调用imageName</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageWithName:name];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (image == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"图片加载为空"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">  * 调用系统方法，其实调用的是自己创建的方法</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当图片不存在的时候会打印"图片加载为空"</span></span><br><span class="line">    <span class="built_in">UIImage</span> * image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"222"</span>];</span><br><span class="line">    <span class="keyword">self</span>.pageView.image = image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-动态添加方法"><a href="#3-动态添加方法" class="headerlink" title="3. 动态添加方法"></a>3. 动态添加方法</h4><p>如果一个类方法非常多，加载类到内存的时候也比较耗费资源，需要给每个方法生成映射表，可以使用动态给某个类添加方法解决。</p><p>调用未实现的方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person * p = [[Person alloc] init];</span><br><span class="line"><span class="comment">// 默认Person没有实现eat方法，通过performSelector方法调用会报错，但是动态添加方法就不会报错</span></span><br><span class="line">[p performSelector:<span class="keyword">@selector</span>(eat)];</span><br></pre></td></tr></table></figure><p>动态的添加方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"><span class="comment">//默认方法都有两个隐式参数</span></span><br><span class="line"><span class="keyword">void</span> eat (<span class="keyword">id</span> <span class="keyword">self</span>, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@, %@"</span>, <span class="keyword">self</span>, <span class="built_in">NSStringFromSelector</span>(sel));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当一个对象调用未实现的方法时，系统会调用这个方法处理，并且会把对应的方法列表传过来</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(eat)) &#123;</span><br><span class="line">        <span class="comment">//动态添加eat方法</span></span><br><span class="line">        <span class="comment">// 第一个参数：给哪个类添加方法</span></span><br><span class="line">        <span class="comment">// 第二个参数：添加方法的方法编号</span></span><br><span class="line">        <span class="comment">// 第三个参数：添加方法的函数实现（函数地址）</span></span><br><span class="line">        <span class="comment">// 第四个参数：函数的类型，(返回值+参数类型) v:void @:对象-&gt;self :表示SEL-&gt;_cmd</span></span><br><span class="line">        class_addMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(eat), eat, <span class="string">"v@:"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"当一个对象调用未实现的方法时，会调用这个函数"</span>);</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="4-给分类添加属性"><a href="#4-给分类添加属性" class="headerlink" title="4. 给分类添加属性"></a>4. 给分类添加属性</h4><p>给一个类声明属性，其实本质就是给这个类添加关联，并不是直接把这个值的内存空间添加到类存空间。所以即便分类不能添加属性，但是可以使用runtime实现这一功能。</p><p>在分类中声明属性</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">AddName</span>)</span></span><br><span class="line"><span class="comment">// @property在分类中，只会生成get,set方法的声明，不会生成下划线成员属性，和get,set方法的实现</span></span><br><span class="line"><span class="comment">// 因此需要自己实现</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在分类中实现属性的get，set方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个关联的key</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *key = <span class="string">"name"</span>;</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">AddName</span>)</span></span><br><span class="line"><span class="comment">//get方法</span></span><br><span class="line">-(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//根据关联的key获取关联的值</span></span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//set方法</span></span><br><span class="line">-(<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 第一个参数：给哪个对象添加关联</span></span><br><span class="line">    <span class="comment">// 第二个参数：关联的key，通过这个key获取</span></span><br><span class="line">    <span class="comment">// 第三个参数：关联的value</span></span><br><span class="line">    <span class="comment">// 第四个参数:关联的策略</span></span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>为属性赋值</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给系统NSObject类动态添加属性name</span></span><br><span class="line"><span class="built_in">NSObject</span> *objc = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">objc.name = <span class="string">@"flame"</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,objc.name);</span><br></pre></td></tr></table></figure><h4 id="5-使用runtime字典转模型"><a href="#5-使用runtime字典转模型" class="headerlink" title="5. 使用runtime字典转模型"></a>5. 使用runtime字典转模型</h4><p>提供一个分类，专门根据字典生成模型对应的属性字符串。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动打印属性字符串</span></span><br><span class="line">+ (<span class="keyword">void</span>)resolveDict:(<span class="built_in">NSDictionary</span> *)dict&#123;</span><br><span class="line">    <span class="comment">// 拼接属性字符串代码</span></span><br><span class="line">    <span class="built_in">NSMutableString</span> *strM = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    <span class="comment">// 1.遍历字典，把字典中的所有key取出来，生成对应的属性代码</span></span><br><span class="line">    [dict enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull key, <span class="keyword">id</span>  _Nonnull obj, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">         <span class="built_in">NSString</span> *type;</span><br><span class="line">        <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFString"</span>)]) &#123;</span><br><span class="line">            type = <span class="string">@"NSString"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFArray"</span>)])&#123;</span><br><span class="line">            type = <span class="string">@"NSArray"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFNumber"</span>)])&#123;</span><br><span class="line">            type = <span class="string">@"int"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFDictionary"</span>)])&#123;</span><br><span class="line">            type = <span class="string">@"NSDictionary"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([obj isKindOfClass:<span class="built_in">NSClassFromString</span>(<span class="string">@"__NSCFBoolean"</span>)])&#123;</span><br><span class="line">            type = <span class="string">@"Bool"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 属性字符串</span></span><br><span class="line">        <span class="built_in">NSString</span> *str;</span><br><span class="line">        <span class="keyword">if</span> ([type containsString:<span class="string">@"NS"</span>]) &#123;</span><br><span class="line">            str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"@property (nonatomic, strong) %@ *%@;"</span>,type,key];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"@property (nonatomic, assign) %@ %@;"</span>,type,key];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每生成属性字符串，就自动换行。</span></span><br><span class="line">        [strM appendFormat:<span class="string">@"\n%@\n"</span>,str];</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 把拼接好的字符串打印出来，就好了。</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,strM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用runtime字典转模型</p><p>思路：利用运行时，遍历模型中所有属性，根据模型的属性名，去字典中查找key，取出对应的值，给模型的属性赋值。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Model</span>)</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)modelWithDict:(<span class="built_in">NSDictionary</span> *)dict</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 思路：遍历模型中所有属性-》使用运行</span></span><br><span class="line">    <span class="comment">// 0.创建对应的对象</span></span><br><span class="line">    <span class="keyword">id</span> objc = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    <span class="comment">// 1.利用runtime给对象中的成员属性赋值  </span></span><br><span class="line">    <span class="comment">// class_copyIvarList:获取类中的所有成员属性</span></span><br><span class="line">    <span class="comment">// Ivar：成员属性的意思</span></span><br><span class="line">    <span class="comment">// 第一个参数：表示获取哪个类中的成员属性</span></span><br><span class="line">    <span class="comment">// 第二个参数：表示这个类有多少成员属性，传入一个Int变量地址，会自动给这个变量赋值</span></span><br><span class="line">    <span class="comment">// 返回值Ivar *：指的是一个ivar数组，会把所有成员属性放在一个数组中，通过返回的数组就能全部获取到。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">// 获取类中的所有成员属性</span></span><br><span class="line">    Ivar *ivarList = class_copyIvarList(<span class="keyword">self</span>, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 根据角标，从数组取出对应的成员属性</span></span><br><span class="line">        Ivar ivar = ivarList[i];</span><br><span class="line">        <span class="comment">// 获取成员属性名</span></span><br><span class="line">        <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</span><br><span class="line">        <span class="comment">// 处理成员属性名-&gt;字典中的key</span></span><br><span class="line">        <span class="comment">// 从第一个角标开始截取</span></span><br><span class="line">        <span class="built_in">NSString</span> *key = [name substringFromIndex:<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 根据成员属性名去字典中查找对应的value</span></span><br><span class="line">        <span class="keyword">id</span> value = dict[key];</span><br><span class="line">        <span class="comment">// 二级转换:如果字典中还有字典，也需要把对应的字典转换成模型</span></span><br><span class="line">        <span class="comment">// 判断下value是否是字典</span></span><br><span class="line">        <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            <span class="comment">// 字典转模型</span></span><br><span class="line">            <span class="comment">// 获取模型的类对象，调用modelWithDict</span></span><br><span class="line">            <span class="comment">// 模型的类名已知，就是成员属性的类型</span></span><br><span class="line">            <span class="comment">// 获取成员属性类型</span></span><br><span class="line">           <span class="built_in">NSString</span> *type = [<span class="built_in">NSString</span> stringWithUTF8String:ivar_getTypeEncoding(ivar)];</span><br><span class="line">          <span class="comment">// 生成的是这种@"@\"User\"" 类型 -》 @"User"  在OC字符串中 \" -&gt; "，\是转义的意思，不占用字符</span></span><br><span class="line">            <span class="comment">// 裁剪类型字符串</span></span><br><span class="line">            <span class="built_in">NSRange</span> range = [type rangeOfString:<span class="string">@"\""</span>];</span><br><span class="line">           type = [type substringFromIndex:range.location + range.length];</span><br><span class="line">            range = [type rangeOfString:<span class="string">@"\""</span>];</span><br><span class="line">            <span class="comment">// 裁剪到哪个角标，不包括当前角标</span></span><br><span class="line">          type = [type substringToIndex:range.location];</span><br><span class="line">            <span class="comment">// 根据字符串类名生成类对象</span></span><br><span class="line">            Class modelClass = <span class="built_in">NSClassFromString</span>(type);</span><br><span class="line">            <span class="keyword">if</span> (modelClass) &#123; <span class="comment">// 有对应的模型才需要转</span></span><br><span class="line">                <span class="comment">// 把字典转模型</span></span><br><span class="line">                value  =  [modelClass modelWithDict:value];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 三级转换：NSArray中也是字典，把数组中的字典转换成模型.</span></span><br><span class="line">        <span class="comment">// 判断值是否是数组</span></span><br><span class="line">        <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            <span class="comment">// 判断对应类有没有实现字典数组转模型数组的协议</span></span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(arrayContainModelClass)]) &#123;  </span><br><span class="line">                <span class="comment">// 转换成id类型，就能调用任何对象的方法</span></span><br><span class="line">                <span class="keyword">id</span> idSelf = <span class="keyword">self</span>;</span><br><span class="line">                <span class="comment">// 获取数组中字典对应的模型</span></span><br><span class="line">                <span class="built_in">NSString</span> *type =  [idSelf arrayContainModelClass][key];</span><br><span class="line">                <span class="comment">// 生成模型</span></span><br><span class="line">               Class classModel = <span class="built_in">NSClassFromString</span>(type);</span><br><span class="line">                <span class="built_in">NSMutableArray</span> *arrM = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">                <span class="comment">// 遍历字典数组，生成模型数组</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> value) &#123;</span><br><span class="line">                    <span class="comment">// 字典转模型</span></span><br><span class="line">                  <span class="keyword">id</span> model =  [classModel modelWithDict:dict];</span><br><span class="line">                    [arrM addObject:model];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 把模型数组赋值给value</span></span><br><span class="line">                value = arrM;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value) &#123; <span class="comment">// 有值，才需要给模型的属性赋值</span></span><br><span class="line">            <span class="comment">// 利用KVC给模型中的属性赋值</span></span><br><span class="line">            [objc setValue:value forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS之多线程</title>
      <link href="/2016/04/09/iOS%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2016/04/09/iOS%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>首先，在了解多线程之前要了解什么是进程，什么是线程<br>进程是指在系统中正在运行的一个应用程序。每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。<br>一个进程要想执行任务，必须得有至少一个线程，线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行。<br>一个线程中任务的执行是串行的，如果要在1个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务。也就是说，在同一时间内，1个线程只能执行1个任务。</p></blockquote><a id="more"></a><h2 id="什么是多线程？"><a href="#什么是多线程？" class="headerlink" title="什么是多线程？"></a>什么是多线程？</h2><p>即在一个进程（程序）中可以开启多条线程，每条线程可以并行（同时）执行不同的任务。</p><p>并行即同时执行。比如同时开启3条线程分别下载3个文件（分别是文件A、文件B、文件C）。</p><p>在同一时间里，CPU只能处理一条线程，只有一条线程在工作（执行）。多线程并发（同时）执行，其实是CPU快速地在多条线程之间快速切换，如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。</p><h2 id="多线程优缺点"><a href="#多线程优缺点" class="headerlink" title="多线程优缺点"></a>多线程优缺点</h2><p>优点:</p><ol><li>能适当提高程序的执行效率。</li><li>能适当提高资源利用率（CPU、内存利用率）</li></ol><p>缺点:</p><ol><li>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能。</li><li>线程越多，CPU在调度线程上的开销就越大。</li><li>程序设计更加复杂：比如线程之间的通信、多线程的数据共享</li></ol><h2 id="开启多线程的方式"><a href="#开启多线程的方式" class="headerlink" title="开启多线程的方式"></a>开启多线程的方式</h2><p>当一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”；它的作用就是刷新显示UI,处理UI事件。</p><ol><li>不要将耗时操作放到主线程中去处理，会卡住线程。</li><li>和UI相关的刷新操作必须放到主线程中进行处理。</li></ol><h3 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h3><p>特点：</p><ol><li>一套通用的多线程API</li><li>适用于Unix\Linux\Windows等系统</li><li>跨平台\可移植</li></ol><p>使用难度：*****<br>使用语言：c语言<br>使用频率：几乎不用<br>线程生命周期：由程序员进行管理</p><p>使用说明：pthread的基本使用（需要包含头文件）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>具体实现代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用pthread创建线程对象</span></span><br><span class="line">pthread_t thread;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一个参数:线程对象</span></span><br><span class="line"><span class="comment">第二个参数:线程属性,NULL</span></span><br><span class="line"><span class="comment">第三个参数:指向函数的指针</span></span><br><span class="line"><span class="comment">第四个参数:前一个参数()方法中需要接受的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">pthread_create(&amp;thread, <span class="literal">NULL</span>, run, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><p>特点：</p><ol><li>使用更加面向对象</li><li>简单易用，可直接操作线程对象</li></ol><p>使用难度：***<br>使用语言：OC语言<br>使用频率：偶尔使用<br>线程生命周期：由程序员进行管理</p><h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><p>第一种创建线程的方式：<code>alloc init</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//特点：需要手动开启线程，可以拿到线程对象进行详细的设置</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一个参数：目标对象</span></span><br><span class="line"><span class="comment">第二个参数：选择器，线程启动要调用哪个方法</span></span><br><span class="line"><span class="comment">第三个参数：前面方法要接收的参数（最多只能接收一个参数，没有则传nil）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">NSThread</span> *newThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">[newThread start];</span><br></pre></td></tr></table></figure><p>第二种创建线程的方式：分离出一条子线程</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//特点：不需要手动开启线程，不可以对线程对象进行详细的设置</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 第一个参数：选择器，线程启动要调用哪个方法</span></span><br><span class="line"><span class="comment"> 第二个参数：目标对象</span></span><br><span class="line"><span class="comment"> 第三个参数：前面方法要接收的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(run) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><p>第三种创建线程的方式：后台线程</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//特点：自动启动线程，不能对线程对象进行详细的设置</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一个参数：线程启动后调用的方法</span></span><br><span class="line"><span class="comment">第二个参数：方法接收的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">[<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(run) withObject:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><h4 id="设置线程的属性"><a href="#设置线程的属性" class="headerlink" title="设置线程的属性"></a>设置线程的属性</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置线程的属性</span></span><br><span class="line"><span class="comment">//设置线程的名称</span></span><br><span class="line">thread.name = <span class="string">@"线程A"</span>;</span><br><span class="line"><span class="comment">//设置线程的优先级,注意线程优先级的取值范围为0.0~1.0之间，1.0表示线程的优先级最高,如果不设置该值，那么理想状态下默认为0.5</span></span><br><span class="line">thread.threadPriority = <span class="number">1.0</span>;</span><br></pre></td></tr></table></figure><h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><p>线程的各种状态：新建-就绪-运行-阻塞-死亡<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用的控制线程状态的方法</span></span><br><span class="line">[<span class="built_in">NSThread</span> exit];<span class="comment">//退出当前线程</span></span><br><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.0</span>];<span class="comment">//阻塞线程</span></span><br><span class="line">[<span class="built_in">NSThread</span> sleepUntilDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">2.0</span>]];<span class="comment">//阻塞线程</span></span><br><span class="line"><span class="comment">//注意：线程死了不能复生</span></span><br></pre></td></tr></table></figure></p><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>前提：多个线程访问同一块资源会发生数据安全问题<br>解决方案：加互斥锁<br>相关代码：@synchronized(self){}<br>专业术语-线程同步<br>原子和非原子属性（是否对setter方法加锁）</p><h4 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="keyword">nonnull</span> <span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="keyword">nullable</span> <span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//开启一条子线程来下载图片</span></span><br><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(downloadImage) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)downloadImage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.确定要下载网络图片的url地址，一个url唯一对应着网络上的一个资源</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://http://p2.wmpic.me/article/2016/03/17/1458205813_mEsdeUon.jpg"</span>];</span><br><span class="line">    <span class="comment">//2.根据url地址下载图片数据到本地（二进制数据）</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">    <span class="comment">//3.把下载到本地的二进制数据转换成图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    <span class="comment">//4.回到主线程刷新UI</span></span><br><span class="line">    <span class="comment">//4.1 第一种方式</span></span><br><span class="line"><span class="comment">//    [self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:YES];</span></span><br><span class="line">    <span class="comment">//4.2 第二种方式</span></span><br><span class="line"><span class="comment">//    [self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:YES];</span></span><br><span class="line">    <span class="comment">//4.3 第三种方式</span></span><br><span class="line">    [<span class="keyword">self</span>.imageView performSelector:<span class="keyword">@selector</span>(setImage:) onThread:[<span class="built_in">NSThread</span> mainThread] withObject:image waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何计算代码段的执行时间"><a href="#如何计算代码段的执行时间" class="headerlink" title="如何计算代码段的执行时间"></a>如何计算代码段的执行时间</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方法</span></span><br><span class="line"><span class="built_in">NSDate</span> *start = [<span class="built_in">NSDate</span> date];</span><br><span class="line"><span class="comment">//2.根据url地址下载图片数据到本地（二进制数据）</span></span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line"><span class="built_in">NSDate</span> *end = [<span class="built_in">NSDate</span> date];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"第二步操作花费的时间为%f"</span>,[end timeIntervalSinceDate:start]);</span><br><span class="line"><span class="comment">//第二种方法</span></span><br><span class="line"><span class="built_in">CFTimeInterval</span> start = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line"><span class="built_in">CFTimeInterval</span> end = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"第二步操作花费的时间为%f"</span>,end - start);</span><br></pre></td></tr></table></figure><h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>特点：</p><ol><li>旨在替代NSThread等线程技术</li><li>充分利用设备的多核（自动）</li></ol><p>使用难度：**<br>使用语言：C语言<br>使用频率：经常使用<br>线程生命周期：自动管理</p><h4 id="GCD基本使用"><a href="#GCD基本使用" class="headerlink" title="GCD基本使用"></a>GCD基本使用</h4><p>异步函数+并发队列：开启多条线程，并发执行任务<br>异步函数+串行队列：开启一条线程，串行执行任务<br>同步函数+并发队列：不开线程，串行执行任务<br>同步函数+串行队列：不开线程，串行执行任务<br>异步函数+主队列：不开线程，在主线程中串行执行任务<br>同步函数+主队列：不开线程，串行执行任务（注意死锁发生）</p><p>注意同步函数和异步函数在执行顺序上面的差异</p><h4 id="GCD线程间通信"><a href="#GCD线程间通信" class="headerlink" title="GCD线程间通信"></a>GCD线程间通信</h4><p>创建串行队列<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一个参数:C语言的字符传,标签</span></span><br><span class="line"><span class="comment">第二个参数:队列的类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *label, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure></p><p>创建并发队列</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一个参数:C语言的字符传,标签</span></span><br><span class="line"><span class="comment">第二个参数:队列的类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *label, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure><p>创建全局队列</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0.获取一个全局的队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//1.先开启一个线程，把下载图片的操作放在子线程中处理</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">//2.下载图片</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://p2.wmpic.me/article/2016/03/17/1458205813_mEsdeUon.jpg"</span>];</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下载操作所在的线程--%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.回到主线程刷新UI</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">self</span>.imageView.image = image;</span><br><span class="line">        <span class="comment">//打印查看当前线程</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"刷新UI---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="GCD其它常用函数"><a href="#GCD其它常用函数" class="headerlink" title="GCD其它常用函数"></a>GCD其它常用函数</h4><p>栅栏函数（控制任务的执行顺序）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--dispatch_barrier_async-"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>延迟执行（延迟·控制在哪个线程执行）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一次性代码（注意不能放到懒加载）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)once</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//整个程序运行过程中只会执行一次</span></span><br><span class="line">    <span class="comment">//onceToken用来记录该部分的代码是否被执行过</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"-----"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速迭代（开多个线程并发完成迭代操作）<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_apply(subpaths.count, queue, ^(size_t index) &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>队列组（同栅栏函数）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建队列组</span></span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    <span class="comment">//队列组中的任务执行完毕之后，执行该函数</span></span><br><span class="line">    dispatch_group_notify(dispatch_group_t group,</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue,</span><br><span class="line">dispatch_block_t block);</span><br></pre></td></tr></table></figure><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><p>在iOS6.0之前，在GCD中凡是使用了带Crearte和retain的函数在最后都需要做一次release操作。而主队列和全局并发队列不需要我们手动release。在iOS6.0之后GCD已经被纳入到了ARC的内存管理范畴中，即便是使用retain或者create函数创建的对象也不再需要开发人员手动释放，我们像对待普通OC对象一样对待GCD就OK。</p><p>在使用栅栏函数的时候，苹果官方明确规定栅栏函数只有在和使用create函数自己的创建的并发队列一起使用的时候才有效</p><h3 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h3><p>特点：</p><ol><li>基于GCD（底层是GCD）</li><li>比GCD多了一些更简单实用的功能</li><li>使用更加面向对象</li></ol><p>使用难度：**<br>使用语言：OC语言<br>使用频率：经常使用<br>线程生命周期：自动管理</p><p>NSOperation是对GCD的包装，其本身是只是抽象类，只有它的子类（三个子类分别是：NSBlockOperation、NSInvocationOperation以及自定义继承自NSOperation的类）才能创建对象</p><h4 id="NSInvocationOperation"><a href="#NSInvocationOperation" class="headerlink" title="NSInvocationOperation"></a>NSInvocationOperation</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.封装操作</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一个参数：目标对象</span></span><br><span class="line"><span class="comment">第二个参数：该操作要调用的方法，最多接受一个参数</span></span><br><span class="line"><span class="comment">第三个参数：调用方法传递的参数，如果方法不接受参数，那么该值传nil</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">NSInvocationOperation</span> *operation = [[<span class="built_in">NSInvocationOperation</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//2.启动操作</span></span><br><span class="line">[operation start];</span><br></pre></td></tr></table></figure><h4 id="NSBlockOperation"><a href="#NSBlockOperation" class="headerlink" title="NSBlockOperation"></a>NSBlockOperation</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.封装操作</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  NSBlockOperation提供了一个类方法，在该类方法中封装操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">NSBlockOperation</span> *operation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="comment">//在主线程中执行</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---download1--%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//2.追加操作，追加的操作在子线程中执行</span></span><br><span class="line">[operation addExecutionBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---download2--%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">[operation addExecutionBlock:^&#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"---download3--%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//3.启动执行操作</span></span><br><span class="line">[operation start];</span><br></pre></td></tr></table></figure><h4 id="自定义NSOperation"><a href="#自定义NSOperation" class="headerlink" title="自定义NSOperation"></a>自定义NSOperation</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如何封装操作？</span></span><br><span class="line"><span class="comment">//自定义的NSOperation,通过重写内部的main方法实现封装操作</span></span><br><span class="line">-(<span class="keyword">void</span>)main</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--main--%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如何使用？</span></span><br><span class="line"><span class="comment">//1.实例化一个自定义操作对象</span></span><br><span class="line">TYOperation *op = [[TYOperation alloc]init];</span><br><span class="line"><span class="comment">//2.执行操作</span></span><br><span class="line">[op start];</span><br></pre></td></tr></table></figure><h4 id="NSOperationQueue"><a href="#NSOperationQueue" class="headerlink" title="NSOperationQueue"></a>NSOperationQueue</h4><p>NSOperation中的两种队列</p><ul><li>主队列 通过mainQueue获得，凡是放到主队列中的任务都将在主线程执行</li><li>非主队列 直接alloc init出来的队列。非主队列同时具备了并发和串行的功能，通过设置最大并发数属性来控制任务是并发执行还是串行执行</li></ul><h5 id="NSInvocationOperation-1"><a href="#NSInvocationOperation-1" class="headerlink" title="NSInvocationOperation"></a>NSInvocationOperation</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)invocation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     GCD中的队列：</span></span><br><span class="line"><span class="comment">     串行队列：自己创建的，主队列</span></span><br><span class="line"><span class="comment">     并发队列：自己创建的，全局并发队列</span></span><br><span class="line"><span class="comment">     NSOperationQueue</span></span><br><span class="line"><span class="comment">     主队列：[NSOperationQueue mainqueue];凡事放在主队列中的操作都在主线程中执行</span></span><br><span class="line"><span class="comment">     非主队列：[[NSOperationQueue alloc]init]，并发和串行，默认是并发执行的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//1.创建队列</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line">    <span class="comment">//2.封装操作</span></span><br><span class="line">    <span class="built_in">NSInvocationOperation</span> *op1 = [[<span class="built_in">NSInvocationOperation</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(download1) object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSInvocationOperation</span> *op2 = [[<span class="built_in">NSInvocationOperation</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(download2) object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSInvocationOperation</span> *op3 = [[<span class="built_in">NSInvocationOperation</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(download3) object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//3.把封装好的操作添加到队列中</span></span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">    [queue addOperation:op3];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="NSBlockOperation-1"><a href="#NSBlockOperation-1" class="headerlink" title="NSBlockOperation"></a>NSBlockOperation</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)freeBlock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.创建队列</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line">    <span class="comment">//2.封装操作</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1----%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2----%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [op2 addExecutionBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"3----%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [op2 addExecutionBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"4----%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">//3.添加操作到队列中</span></span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2]</span><br><span class="line">    <span class="comment">//补充：简便方法</span></span><br><span class="line">    [queue addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"5----%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自定义NSOperation-1"><a href="#自定义NSOperation-1" class="headerlink" title="自定义NSOperation"></a>自定义NSOperation</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)freeOperation</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.创建队列</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line"><span class="comment">//2.封装操作</span></span><br><span class="line"><span class="comment">//好处：1.信息隐蔽</span></span><br><span class="line"><span class="comment">//     2.代码复用</span></span><br><span class="line">TYOperation *op1 = [[TYOperation alloc]init];</span><br><span class="line">TYOperation *op2 = [[TYOperation alloc]init];</span><br><span class="line"><span class="comment">//3.添加操作到队列中</span></span><br><span class="line">[queue addOperation:op1];</span><br><span class="line">[queue addOperation:op2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NSOperation其它用法"><a href="#NSOperation其它用法" class="headerlink" title="NSOperation其它用法"></a>NSOperation其它用法</h4><h5 id="设置最大并发数-最大并发数关系着队列是串行还是并行"><a href="#设置最大并发数-最大并发数关系着队列是串行还是并行" class="headerlink" title="设置最大并发数[最大并发数关系着队列是串行还是并行]"></a>设置最大并发数[最大并发数关系着队列是串行还是并行]</h5><p>创建队列</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br></pre></td></tr></table></figure><p>设置最大并发数</p><ol><li>该属性需要在任务添加到队列中之前进行设置</li><li>该属性控制队列是串行执行还是并发执行</li><li>如果最大并发数等于1，那么该队列是串行的，如果大于1那么是并行的<br>4.系统的最大并发数有个默认的值，为-1，如果该属性设置为0，那么不会执行任何任务</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue.maxConcurrentOperationCount = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h5 id="暂停和恢复以及取消"><a href="#暂停和恢复以及取消" class="headerlink" title="暂停和恢复以及取消"></a>暂停和恢复以及取消</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置暂停和恢复</span></span><br><span class="line"><span class="comment">//suspended设置为YES表示暂停，suspended设置为NO表示恢复</span></span><br><span class="line"><span class="comment">//暂停表示不继续执行队列中的下一个任务，暂停操作是可以恢复的</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.queue.isSuspended) &#123;</span><br><span class="line">    <span class="keyword">self</span>.queue.suspended = <span class="literal">NO</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">self</span>.queue.suspended = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取消队列里面的所有操作</span></span><br><span class="line"><span class="comment">//取消之后，当前正在执行的操作的下一个操作将不再执行，而且永远都不在执行，就像后面的所有任务都从队列里面移除了一样</span></span><br><span class="line"><span class="comment">//取消操作是不可以恢复的</span></span><br><span class="line">[<span class="keyword">self</span>.queue cancelAllOperations];</span><br><span class="line">---------自定义<span class="built_in">NSOperation</span>取消操作--------------------------</span><br><span class="line">-(<span class="keyword">void</span>)main</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//耗时操作1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务1-%d--%@"</span>,i,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"+++++++++++++++++++++++++++++++++"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//苹果官方建议，每当执行完一次耗时操作之后，就查看一下当前队列是否为取消状态，如果是，那么就直接退出</span></span><br><span class="line">    <span class="comment">//好处是可以提高程序的性能</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//耗时操作2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务1-%d--%@"</span>,i,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"+++++++++++++++++++++++++++++++++"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NSOperation实现线程间通信"><a href="#NSOperation实现线程间通信" class="headerlink" title="NSOperation实现线程间通信"></a>NSOperation实现线程间通信</h4><h5 id="开子线程下载图片"><a href="#开子线程下载图片" class="headerlink" title="开子线程下载图片"></a>开子线程下载图片</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建队列</span></span><br><span class="line"><span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用简便方法封装操作并添加到队列中</span></span><br><span class="line">[queue addOperationWithBlock:^&#123;</span><br><span class="line">    <span class="comment">//3.在该block中下载图片</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://p2.wmpic.me/article/2016/03/17/1458205813_mEsdeUon.jpg"</span>];</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下载图片操作--%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="comment">//4.回到主线程刷新UI</span></span><br><span class="line">    [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">        <span class="keyword">self</span>.imageView.image = image;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"刷新UI操作---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h5 id="下载多张图片合成综合案例（设置操作依赖）"><a href="#下载多张图片合成综合案例（设置操作依赖）" class="headerlink" title="下载多张图片合成综合案例（设置操作依赖）"></a>下载多张图片合成综合案例（设置操作依赖）</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)download</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.创建队列</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line">    <span class="comment">//2.封装操作下载图片1</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://p2.wmpic.me/article/2016/03/14/1457926891_nZGraHTj.jpg"</span>];</span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        <span class="comment">//拿到图片数据</span></span><br><span class="line">        <span class="keyword">self</span>.image1 = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">//3.封装操作下载图片2</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://p3.wmpic.me/article/2016/01/08/1452222281_PmFnXZHU.jpg"</span>];</span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        <span class="comment">//拿到图片数据</span></span><br><span class="line">        <span class="keyword">self</span>.image2 = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.合成图片</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *combine = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.1 开启图形上下文</span></span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContext</span>(<span class="built_in">CGSizeMake</span>(<span class="number">200</span>, <span class="number">200</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.2 画第一幅图</span></span><br><span class="line">        [<span class="keyword">self</span>.image1 drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">100</span>)];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.3 画第二幅图</span></span><br><span class="line">        [<span class="keyword">self</span>.image2 drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">100</span>)];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.4 根据图形上下文拿到图片数据</span></span><br><span class="line">        <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        <span class="comment">//NSLog(@"%@",image);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.5 关闭图形上下文</span></span><br><span class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.回到主线程刷新UI</span></span><br><span class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue]addOperationWithBlock:^&#123;</span><br><span class="line">            <span class="keyword">self</span>.imageView.image = image;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"刷新UI---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.设置操作依赖</span></span><br><span class="line">    [combine addDependency:op1];</span><br><span class="line">    [combine addDependency:op2];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.添加操作到队列中执行</span></span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">    [queue addOperation:combine];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><blockquote><p>iOS开发多种设计模式之一—-单例模式</p></blockquote><h3 id="什么是单例"><a href="#什么是单例" class="headerlink" title="什么是单例"></a>什么是单例</h3><p>在程序运行过程，一个类有且只有一个实例对象</p><h3 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h3><p>在整个应用程序中，共享一份资源（这份资源只需要创建初始化1次）</p><h3 id="在不同的内存管理机制下实现单例"><a href="#在不同的内存管理机制下实现单例" class="headerlink" title="在不同的内存管理机制下实现单例:"></a>在不同的内存管理机制下实现单例:</h3><h4 id="ARC实现单例"><a href="#ARC实现单例" class="headerlink" title="ARC实现单例"></a>ARC实现单例</h4><p>步骤:</p><ol><li>在类的内部提供一个static修饰的全局变量</li><li>提供一个类方法，方便外界访问</li><li>重写+allocWithZone方法，保证永远都只为单例对象分配一次内存空间</li><li>严谨起见，重写-copyWithZone方法和-MutableCopyWithZone方法</li></ol><p>代码实现:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提供一个static修饰的全局变量，强引用着已经实例化的单例对象实例</span></span><br><span class="line"><span class="keyword">static</span> TYSingleTools *_instance;</span><br><span class="line"><span class="comment">//类方法，返回一个单例对象</span></span><br><span class="line">+(<span class="keyword">instancetype</span>)shareTools</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//注意：这里建议使用self,而不是直接使用类名Tools（考虑继承）</span></span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc]init];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保证永远只分配一次存储空间</span></span><br><span class="line">+(<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//第一种：使用GCD中的一次性代码</span></span><br><span class="line"><span class="comment">//    static dispatch_once_t onceToken;</span></span><br><span class="line"><span class="comment">//    dispatch_once(&amp;onceToken, ^&#123;</span></span><br><span class="line"><span class="comment">//        _instance = [super allocWithZone:zone];</span></span><br><span class="line"><span class="comment">//    &#125;);</span></span><br><span class="line">    <span class="comment">//第二种：使用加锁的方式，保证只分配一次存储空间</span></span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="literal">nil</span>) &#123;</span><br><span class="line">            _instance = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.mutableCopy 创建一个新的可变对象，并初始化为原对象的值，新对象的引用计数为 1；</span></span><br><span class="line"><span class="comment">2.copy 返回一个不可变对象。分两种情况：（1）若原对象是不可变对象，那么返回原对象，并将其引用计数加 1 ；（2）若原对象是可变对象，那么创建一个新的不可变对象，并初始化为原对象的值，新对象的引用计数为 1。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//让代码更加的严谨</span></span><br><span class="line">-(<span class="keyword">nonnull</span> <span class="keyword">id</span>)copyWithZone:(<span class="keyword">nullable</span> <span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    return [[self class] allocWithZone:zone];</span></span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">nonnull</span> <span class="keyword">id</span>)mutableCopyWithZone:(<span class="keyword">nullable</span> <span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MRC实现单例"><a href="#MRC实现单例" class="headerlink" title="MRC实现单例"></a>MRC实现单例</h4><p>步骤:</p><ol><li>在类的内部提供一个static修饰的全局变量</li><li>提供一个类方法，方便外界访问</li><li>重写+allocWithZone方法，保证永远都只为单例对象分配一次内存空间</li><li>严谨起见，重写-copyWithZone方法和-MutableCopyWithZone方法</li><li>重写release和retain方法</li><li>建议在retainCount方法中返回一个最大值（有经验的程序员通过打印retainCount这个值可以猜到这是一个单例）</li></ol><p>配置MRC环境知识:</p><ol><li>注意ARC不是垃圾回收机制，是编译器特性</li><li>配置MRC环境：build setting -&gt;搜索automatic ref-&gt;修改为NO</li></ol><p>代码实现:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提供一个static修饰的全局变量，强引用着已经实例化的单例对象实例</span></span><br><span class="line"><span class="keyword">static</span> TYSingleTools *_instance;</span><br><span class="line"><span class="comment">//类方法，返回一个单例对象</span></span><br><span class="line">+(<span class="keyword">instancetype</span>)shareTools</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//注意：这里建议使用self,而不是直接使用类名Tools（考虑继承）</span></span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc]init];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保证永远只分配一次存储空间</span></span><br><span class="line">+(<span class="keyword">instancetype</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用GCD中的一次性代码</span></span><br><span class="line"><span class="comment">//    static dispatch_once_t onceToken;</span></span><br><span class="line"><span class="comment">//    dispatch_once(&amp;onceToken, ^&#123;</span></span><br><span class="line"><span class="comment">//        _instance = [super allocWithZone:zone];</span></span><br><span class="line"><span class="comment">//    &#125;);</span></span><br><span class="line">    <span class="comment">//使用加锁的方式，保证只分配一次存储空间</span></span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="literal">nil</span>) &#123;</span><br><span class="line">            _instance = [<span class="keyword">super</span> allocWithZone:zone];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//让代码更加的严谨</span></span><br><span class="line">-(<span class="keyword">nonnull</span> <span class="keyword">id</span>)copyWithZone:(<span class="keyword">nullable</span> <span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    return [[self class] allocWithZone:zone];</span></span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">nonnull</span> <span class="keyword">id</span>)mutableCopyWithZone:(<span class="keyword">nullable</span> <span class="built_in">NSZone</span> *)zone</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在MRC环境下，如果用户retain了一次，那么直接返回instance变量，不对引用计数器+1</span></span><br><span class="line"><span class="comment">//如果用户release了一次，那么什么都不做，因为单例模式在整个程序运行过程中都拥有且只有一份，程序退出之后被释放，所以不需要对引用计数器操作</span></span><br><span class="line">-(<span class="keyword">oneway</span> <span class="keyword">void</span>)release</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">instancetype</span>)<span class="keyword">retain</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//惯用法，有经验的程序员通过打印retainCount这个值可以猜到这是一个单例</span></span><br><span class="line">-(<span class="built_in">NSUInteger</span>)retainCount</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> MAXFLOAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>忽略ARC和MRC的单例通用版本<br>可以使用条件编译来判断当前项目环境是ARC还是MRC，从而实现一份代码在不同的内存管理机制下都可以实现单例。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">条件编译:</span><br><span class="line">#if __has_feature(objc_arc)</span><br><span class="line">//如果是ARC，那么就执行这里的代码1</span><br><span class="line">#else</span><br><span class="line">//如果不是ARC，那么就执行代理的代码2</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：<em>单例是不可以用继承的。</em></p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>GCDAPI:<br><a href="https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html#//apple_ref/c/func/dispatch_queue_create" target="_blank" rel="noopener">https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html#//apple_ref/c/func/dispatch_queue_create</a></li><li>Libdispatch版本源码：<br><a href="http://www.opensource.apple.com/source/libdispatch/libdispatch-187.5/" target="_blank" rel="noopener">http://www.opensource.apple.com/source/libdispatch/libdispatch-187.5/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac搭建hexo + github博客</title>
      <link href="/2015/09/01/Mac%E6%90%AD%E5%BB%BAhexo%20+%20githu%E5%8D%9A%E5%AE%A2/"/>
      <url>/2015/09/01/Mac%E6%90%AD%E5%BB%BAhexo%20+%20githu%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="1-node-js"><a href="#1-node-js" class="headerlink" title="1. node.js"></a>1. node.js</h2><p>用来生成静态页面.Mac中自带了node.js.<a href="https://nodejs.org/en/" target="_blank" rel="noopener">下载地址</a></p><h2 id="2-Git"><a href="#2-Git" class="headerlink" title="2.Git"></a>2.Git</h2><p>用来将本地Hexo内容提交到Github上。Xcode自带Git，这里不再赘述。如果没有Xcode可以参考<a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo官网</a>上的安装方法。<br><a id="more"></a></p><h1 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h1><h2 id="一般搭建方法"><a href="#一般搭建方法" class="headerlink" title="一般搭建方法"></a>一般搭建方法</h2><blockquote><p>待续…</p></blockquote><h2 id="优化搭建方法-全部存放于gitHub中-包括Hexo源文件和生成的静态页面文件"><a href="#优化搭建方法-全部存放于gitHub中-包括Hexo源文件和生成的静态页面文件" class="headerlink" title="优化搭建方法(全部存放于gitHub中,包括Hexo源文件和生成的静态页面文件)"></a>优化搭建方法(全部存放于gitHub中,包括Hexo源文件和生成的静态页面文件)</h2><blockquote><p>概述:<br>Hexo部署到GitHub上的文件，是.md（你的博文）转化之后的.html（静态网页）。因此，当你重装电脑或者想在不同电脑上修改博客时，就不可能了。如果我们将Hexo生成的网站文件存放到GitHub上进行管理的。这样，不仅解决了上述的问题，还可以通过git的版本控制追踪你的博文的修改过程。<br>我们需要有两个分支，一个用来存放Hexo网站的文件，一个用来发布网站。</p></blockquote><h3 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h3><ol><li>创建仓库，<code>Flametinary.github.io</code>；</li><li>创建两个分支：<code>master</code> 与 <code>hexo</code>；</li><li>设置<code>hexo</code>为默认分支（我们只需要手动管理这个分支上的Hexo网站文件）；</li><li>使用<code>git clone git@github.com:FlameTinary/FlameTinary.github.io.git</code>拷贝仓库；</li><li>在本地<code>Flametinary.github.io</code>文件夹下通过<code>Git bash</code>依次执行<code>npm install -g hexo-cli</code>、<code>hexo init</code>、<code>npm install</code> 和 <code>npm install hexo-deployer-git</code>（此时当前分支应显示为<code>hexo</code>）;</li><li>修改<code>_config.yml</code>中的<code>deploy</code>参数，分支应为<code>master</code>；</li><li>依次执行<code>git add .</code>、<code>git commit -m “…”</code>、<code>git push origin hexo</code>提交网站相关的文件；</li><li>执行<code>hexo generate -d</code>生成网站并部署到GitHub上。</li></ol><h1 id="相关问题解决"><a href="#相关问题解决" class="headerlink" title="相关问题解决"></a>相关问题解决</h1><ol><li><p>在将hexo源文件提交到git的hexo目录中出现<code>modified:   themes/next</code>的问题.</p><p> <strong>原因:</strong> 由于next主题是存放于GitHub中的,因此在将next主题clone下来的时候,同时携带了一些GitHub的相关文件,是由这些脏数据引起的.</p><p> <strong>解决办法:</strong> 删除相关文件即可,进入存放hexo的文件夹-&gt;themes-&gt;next,其中有<code>git</code>/<code>GitHub</code>/<code>gitattribute</code>,三个文件,删除即可.</p></li><li><p>git 分支可以commit成功,但是push不到origin hexo.<br><strong>原因:</strong> 本地的hexo分支没有关联到origin上的hexo分支.<br><strong>解决办法:</strong>使用<code>git branch --set-upstream hexo origin/hexo</code>.</p></li><li><p>如果在修改hexo文件,比如修改next主题后,<code>hexo s</code>显示了修改后的效果,但是 <code>hexo generate</code>/<code>hexo deploy</code>后却在GitHub page上没有效果,可以先 <code>hexo clean</code>一下,然后在执行部署<code>hexo g -d</code>.</p></li><li>在<code>hexo deploy</code>后显示error:<code>Deployer not found: git</code>,尝试执行<code>npm install hexo-deployer-git --save</code>可修复.</li><li>执行<code>hexo s</code>命令后，页面访问显示<code>Cannot GET/</code>, 重新执行<code>npm install</code>.</li><li>执行<code>hexo deploy</code>,打开gitHub page,显示页面404 not found.<br><strong>原因:</strong>主要是Jekyll升级所致<br><strong>解决办法:</strong><ol><li>.deploy_git 目录, 添加 .nojekyll 空文件</li><li>source目录, 添加.nojekyll 空文件</li><li>修改 Hexo 上层_config.yml配置文件, 添加<code>include: - .nojekyll</code></li><li>重新部署推送: <code>hexo d -g</code></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
